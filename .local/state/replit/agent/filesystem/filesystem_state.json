{"file_contents":{"public/news.js":{"content":"// Global state\nlet userData = null;\nlet newsData = [];\n\n// Initialize\nasync function init() {\n    await loadUserData();\n    await loadNews();\n}\n\n// Load user data\nasync function loadUserData() {\n    try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        userData = data.gameData;\n        \n        // Update UI\n        document.getElementById('username').textContent = data.discord.username;\n        document.getElementById('userAvatar').src = data.discord.avatar \n            ? `https://cdn.discordapp.com/avatars/${data.discord.id}/${data.discord.avatar}.png`\n            : 'https://cdn.discordapp.com/embed/avatars/0.png';\n        \n        document.getElementById('topGP').textContent = (userData?.gp || 0).toLocaleString();\n        document.getElementById('topEcoins').textContent = userData?.eCoins || 0;\n        \n        // Update mail badge\n        const unclaimedMail = (userData?.mail || []).filter(m => !m.claimed).length;\n        const badge = document.getElementById('mailBadge');\n        if (unclaimedMail > 0) {\n            badge.textContent = unclaimedMail;\n            badge.style.display = 'block';\n        }\n    } catch (error) {\n        console.error('Error loading user data:', error);\n    }\n}\n\n// Load news\nasync function loadNews() {\n    try {\n        const response = await fetch('/api/news');\n        const data = await response.json();\n        newsData = data.news || [];\n        \n        console.log('Loaded news:', newsData);\n        \n        renderNews();\n    } catch (error) {\n        console.error('Error loading news:', error);\n        document.getElementById('emptyState').style.display = 'block';\n    } finally {\n        document.getElementById('loading').style.display = 'none';\n    }\n}\n\n// Render news\nfunction renderNews() {\n    const container = document.getElementById('newsList');\n    container.innerHTML = '';\n    \n    if (newsData.length === 0) {\n        document.getElementById('emptyState').style.display = 'block';\n        return;\n    }\n    \n    document.getElementById('emptyState').style.display = 'none';\n    \n    // Sort by date (newest first)\n    const sortedNews = [...newsData].sort((a, b) => new Date(b.date) - new Date(a.date));\n    \n    sortedNews.forEach(news => {\n        const newsItem = document.createElement('div');\n        newsItem.className = 'news-item';\n        newsItem.onclick = () => openNewsModal(news);\n        \n        const date = new Date(news.date);\n        const formattedDate = date.toLocaleDateString('en-US', {\n            day: '2-digit',\n            month: '2-digit',\n            year: 'numeric'\n        });\n        \n        // Get category icon and color\n        const categoryInfo = getCategoryInfo(news.category);\n        \n        newsItem.innerHTML = `\n            <div class=\"news-icon\" style=\"background: ${categoryInfo.color}\">\n                <span>${categoryInfo.icon}</span>\n                <div class=\"news-category\">${news.category || 'Update'}</div>\n            </div>\n            <div class=\"news-content\">\n                <div class=\"news-item-title\">${news.title}</div>\n                <div class=\"news-preview\">${news.preview || news.content.substring(0, 60) + '...'}</div>\n            </div>\n            <div class=\"news-date\">${formattedDate}</div>\n        `;\n        \n        container.appendChild(newsItem);\n    });\n}\n\n// Get category info\nfunction getCategoryInfo(category) {\n    const categories = {\n        'Update': { icon: '‚¨ÜÔ∏è', color: 'linear-gradient(135deg, #4CAF50, #45a049)' },\n        'Issue': { icon: '‚úï', color: 'linear-gradient(135deg, #E91E63, #C2185B)' },\n        'Event': { icon: 'üéâ', color: 'linear-gradient(135deg, #FF9800, #F57C00)' },\n        'Maintenance': { icon: 'üîß', color: 'linear-gradient(135deg, #9C27B0, #7B1FA2)' },\n        'Announcement': { icon: 'üì¢', color: 'linear-gradient(135deg, #2196F3, #1976D2)' }\n    };\n    \n    return categories[category] || categories['Update'];\n}\n\n// Open news modal\nfunction openNewsModal(news) {\n    const modal = document.getElementById('newsModal');\n    const categoryInfo = getCategoryInfo(news.category);\n    \n    document.getElementById('newsModalIcon').innerHTML = `\n        <div style=\"background: ${categoryInfo.color}; width: 100%; height: 150px; display: flex; align-items: center; justify-content: center; border-radius: 15px 15px 0 0;\">\n            <span style=\"font-size: 4em;\">${categoryInfo.icon}</span>\n        </div>\n    `;\n    document.getElementById('newsModalTitle').textContent = news.title;\n    document.getElementById('newsModalBody').innerHTML = `\n        <p style=\"color: rgba(255,255,255,0.7); margin-bottom: 20px;\">\n            ${new Date(news.date).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' })}\n        </p>\n        <div style=\"line-height: 1.8; white-space: pre-wrap;\">${news.content}</div>\n    `;\n    \n    modal.style.display = 'flex';\n    setTimeout(() => modal.classList.add('active'), 10);\n}\n\n// Close news modal\nfunction closeNewsModal() {\n    const modal = document.getElementById('newsModal');\n    modal.classList.remove('active');\n    setTimeout(() => modal.style.display = 'none', 300);\n}\n\n// Initialize on load\ndocument.addEventListener('DOMContentLoaded', init);\n","size_bytes":5271},"commands/penalty.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nconst START_STEPS = 35;\nconst ON_SCORE = 8;\nconst ON_MISS = 4;\n\nfunction todayKey() {\n  const d = new Date();\n  return d.toISOString().slice(0, 10);\n}\n\nfunction ensurePenaltyState(userData) {\n  if (!userData.minigames) userData.minigames = {};\n  if (!userData.minigames.penalty) {\n    userData.minigames.penalty = {\n      date: '',\n      lastPlay: '',\n      remaining: START_STEPS,\n      milestones: {},\n    };\n  }\n  return userData.minigames.penalty;\n}\n\nfunction rewardUserToMail(userData) {\n  if (!userData.mail) userData.mail = [];\n  const roll = Math.random();\n  // 0.6% chance to get an S+ Trainer (1,000,000 EXP)\n  if (roll < 0.006) {\n    userData.mail.push({\n      id: Math.random().toString(36).slice(2, 10),\n      type: 'trainer',\n      trainerName: 'S+ Trainer',\n      exp: 1000000,\n      date: todayKey(),\n    });\n    return 'üßë‚Äçüè´ Ultra Rare Reward: **S+ Trainer** (+1,000,000 EXP) added to your mail!';\n  } else if (roll < 0.34) {\n    const rarities = ['Iconic', 'Legend', 'Black'];\n    const r = rarities[Math.floor(Math.random() * rarities.length)];\n    userData.mail.push({\n      id: Math.random().toString(36).slice(2, 10),\n      type: 'pack',\n      rarity: r,\n      qty: 1,\n      date: todayKey(),\n    });\n    return `üéÅ Free **${r} Pack** added to your mail.`;\n  } else if (roll < 0.67) {\n    const amount = 100;\n    userData.mail.push({\n      id: Math.random().toString(36).slice(2, 10),\n      type: 'eCoins',\n      amount,\n      date: todayKey(),\n    });\n    return `üí∞ **+${amount} eCoins** added to your mail.`;\n  } else {\n    const amount = 5000;\n    userData.mail.push({\n      id: Math.random().toString(36).slice(2, 10),\n      type: 'gp',\n      amount,\n      date: todayKey(),\n    });\n    return `üíµ **+${amount.toLocaleString()} GP** added to your mail.`;\n  }\n}\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('penalty')\n    .setDescription('Daily penalty minigame')\n    .addSubcommand(sc => sc.setName('status').setDescription('View your daily penalty progress'))\n    .addSubcommand(sc => sc.setName('shoot').setDescription('Take your daily penalty shot (once per day)')),\n\n  async execute(interaction) {\n    const { client } = interaction;\n    const userData = client.getUserData(interaction.user.id);\n    const sub = interaction.options.getSubcommand();\n    const state = ensurePenaltyState(userData);\n\n    const today = todayKey();\n    if (state.date !== today) {\n      state.date = today;\n      state.milestones = {};\n    }\n\n    if (sub === 'status') {\n      const embed = new EmbedBuilder()\n        .setTitle('üìä Daily Penalty ‚Äî Status')\n        .setColor('#5865F2')\n        .setDescription(`üéØ Remaining path: **${state.remaining}**\\n‚öΩ On Goal: -${ON_SCORE} ‚Ä¢ ‚ùå On Miss: -${ON_MISS}`)\n        .addFields({ name: \"üìÖ Today's Shot\", value: state.lastPlay === today ? '‚úîÔ∏è Used' : '‚è≥ Available', inline: true })\n        .setFooter({ text: 'You only get 1 shot per day. Reach 0 to earn a reward, then it resets to 35.' });\n\n      return await interaction.reply({ embeds: [embed], ephemeral: true });\n    }\n\n    if (sub === 'shoot') {\n      if (state.lastPlay === today) {\n        const embed = new EmbedBuilder()\n          .setTitle('‚öΩ Daily Penalty')\n          .setColor('#F1C40F')\n          .setDescription('‚õî You already used your penalty shot today.\\nCome back tomorrow!');\n        return await interaction.reply({ embeds: [embed], ephemeral: true });\n      }\n\n      const embed = new EmbedBuilder()\n        .setTitle('‚öΩ Daily Penalty ‚Äî Choose Your Aim')\n        .setColor('#2ECC71')\n        .setDescription('Pick your shot direction by pressing a button:\\n\\n```      üßç Keeper\\n   |   ‚öΩ   |   \\n```')\n        .setFooter({ text: 'You only get 1 shot per day. Choose wisely!' });\n\n      const row = new ActionRowBuilder().addComponents(\n        new ButtonBuilder().setCustomId(`penalty_left_${interaction.user.id}`).setLabel('Left').setEmoji('‚¨ÖÔ∏è').setStyle(ButtonStyle.Primary),\n        new ButtonBuilder().setCustomId(`penalty_center_${interaction.user.id}`).setLabel('Center').setEmoji('‚¨ÜÔ∏è').setStyle(ButtonStyle.Primary),\n        new ButtonBuilder().setCustomId(`penalty_right_${interaction.user.id}`).setLabel('Right').setEmoji('‚û°Ô∏è').setStyle(ButtonStyle.Primary)\n      );\n\n      return await interaction.reply({ embeds: [embed], components: [row] });\n    }\n  },\n\n  async handleButton(interaction) {\n    try {\n      const [action, direction, userId] = interaction.customId.split('_');\n      if (action !== 'penalty') return;\n\n      if (interaction.user.id !== userId) {\n        return await interaction.reply({ content: '‚õî This button isn\\'t for you.', ephemeral: true });\n      }\n\n      const { client } = interaction;\n      const userData = client.getUserData(interaction.user.id);\n      const state = ensurePenaltyState(userData);\n      const today = todayKey();\n\n      if (state.lastPlay === today) {\n        return await interaction.reply({ content: '‚õî You already shot today.', ephemeral: true });\n      }\n\n      const keeper = ['left', 'center', 'right'][Math.floor(Math.random() * 3)];\n      const scored = direction !== keeper;\n      const delta = scored ? ON_SCORE : ON_MISS;\n\n      state.remaining = Math.max(0, state.remaining - delta);\n      state.lastPlay = today;\n\n      let desc = scored\n        ? `‚úÖ **GOAL!**\\nYou aimed **${direction}** and the keeper went **${keeper}**.\\n\\nüü¢ Progress: **-${ON_SCORE}** steps`\n        : `‚ùå **MISS!**\\nYou aimed **${direction}** but the keeper went **${keeper}**.\\n\\nüî¥ Progress: **-${ON_MISS}** steps`;\n\n      let rewardText = '';\n\n      // Milestone: 50 eCoins at 19\n      if (state.remaining === 19 && !state.milestones.ecoin19) {\n        if (!userData.mail) userData.mail = [];\n        userData.mail.push({ id: Math.random().toString(36).slice(2, 10), type: 'eCoins', amount: 50, date: today });\n        state.milestones.ecoin19 = true;\n        rewardText += '\\n\\n‚≠ê Milestone: **+50 eCoins** (reached 19).';\n      }\n\n      // Milestones: +500 GP for ranges 35‚Äì20 and 18‚Äì1\n      if ((state.remaining <= 35 && state.remaining >= 20) || (state.remaining <= 18 && state.remaining >= 1)) {\n        state.milestones.gp = state.milestones.gp || {};\n        if (!state.milestones.gp[state.remaining]) {\n          if (!userData.mail) userData.mail = [];\n          userData.mail.push({ id: Math.random().toString(36).slice(2, 10), type: 'gp', amount: 500, date: today });\n          state.milestones.gp[state.remaining] = true;\n          rewardText += `\\n\\nüíµ Milestone: **+500 GP** (landed on ${state.remaining}).`;\n        }\n      }\n\n      if (state.remaining === 0) {\n        const rewardMsg = rewardUserToMail(userData);\n        rewardText = rewardText ? `${rewardText}\\n\\n${rewardMsg}` : rewardMsg;\n        state.remaining = START_STEPS;\n      }\n\n      client.setUserData(interaction.user.id, userData);\n\n      const embed = new EmbedBuilder()\n        .setTitle('‚öΩ Daily Penalty ‚Äî Result ‚öΩ')\n        .setColor(scored ? '#2ECC71' : '#E74C3C')\n        .setDescription(desc)\n        .addFields(\n          { name: 'üìä Remaining Steps', value: `${state.remaining}`, inline: true },\n          { name: \"üìÖ Today's Shot\", value: '‚úîÔ∏è Used', inline: true }\n        )\n        .setFooter({ text: 'You can only shoot once per day. Reach 0 to earn a reward, then it resets to 35.' });\n\n      if (rewardText) {\n        embed.addFields({ name: 'üéÅ Rewards', value: rewardText });\n      }\n\n      await interaction.update({ embeds: [embed], components: [] });\n    } catch (error) {\n      console.error('Penalty button error:', error);\n      try {\n        await interaction.reply({ content: 'An error occurred. Please try again.', ephemeral: true });\n      } catch (e) {\n        console.error('Failed to send error message:', e);\n      }\n    }\n  }\n};","size_bytes":7944},"commands/squad.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\n\nconst FORMATION_POSITIONS = {\n    '4-3-3': ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', 'LWF', 'CF', 'RWF'],\n    '4-4-2': ['GK', 'LB', 'CB', 'CB', 'RB', 'LMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n    '3-5-2': ['GK', 'CB', 'CB', 'CB', 'LMF', 'CMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n    '4-2-3-1': ['GK', 'LB', 'CB', 'CB', 'RB', 'DMF', 'DMF', 'AMF', 'AMF', 'AMF', 'CF']\n};\n\nconst POSITION_EMOJIS = {\n    'GK': 'ü•Ö', 'CB': 'üõ°Ô∏è', 'LB': '‚¨ÖÔ∏è', 'RB': '‚û°Ô∏è', \n    'DMF': 'üîí', 'CMF': '‚öΩ', 'AMF': 'üéØ', 'LMF': '‚¨ÖÔ∏è', 'RMF': '‚û°Ô∏è',\n    'CF': '‚ö°', 'LWF': 'üèÉ', 'RWF': 'üèÉ'\n};\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('squad')\n        .setDescription('Manage your squad and formations')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('view')\n                .setDescription('View your current squad'))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('autoset')\n                .setDescription('Automatically set best XI by position and fill the bench'))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('set')\n                .setDescription('Set a player in your squad')\n                .addIntegerOption(option =>\n                    option.setName('position')\n                        .setDescription('Position number (1-11)')\n                        .setRequired(true)\n                        .setMinValue(1)\n                        .setMaxValue(11))\n                .addStringOption(option =>\n                    option.setName('player')\n                        .setDescription('Player name')\n                        .setRequired(true)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remove')\n                .setDescription('Remove a player from your squad')\n                .addIntegerOption(option =>\n                    option.setName('position')\n                        .setDescription('Position number (1-11)')\n                        .setRequired(true)\n                        .setMinValue(1)\n                        .setMaxValue(11)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('formation')\n                .setDescription('Change your team formation')\n                .addStringOption(option =>\n                    option.setName('formation')\n                        .setDescription('Choose formation')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: '4-3-3', value: '4-3-3' },\n                            { name: '4-4-2', value: '4-4-2' },\n                            { name: '3-5-2', value: '3-5-2' },\n                            { name: '4-2-3-1', value: '4-2-3-1' }\n                        )))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('bench')\n                .setDescription('Manage bench players')\n                .addStringOption(option =>\n                    option.setName('action')\n                        .setDescription('Add or remove from bench')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Add', value: 'add' },\n                            { name: 'Remove', value: 'remove' }\n                        ))\n                .addStringOption(option =>\n                    option.setName('player')\n                        .setDescription('Player name')\n                        .setRequired(true))),\n    async execute(interaction) {\n        const { client } = interaction;\n        const userData = client.getUserData(interaction.user.id);\n        \n        // Initialize squad structure if it doesn't exist\n        if (!userData.squad) {\n            userData.squad = { main: new Array(11).fill(null), bench: [] };\n            client.setUserData(interaction.user.id, userData);\n        }\n        \n        const subcommand = interaction.options.getSubcommand();\n\n        switch (subcommand) {\n            case 'view':\n                await showSquad(interaction, userData);\n                break;\n            case 'autoset':\n                await autosetSquad(interaction, userData, client);\n                break;\n            case 'set':\n                await setPlayer(interaction, userData, client);\n                break;\n            case 'remove':\n                await removePlayer(interaction, userData, client);\n                break;\n            case 'formation':\n                await setFormation(interaction, userData, client);\n                break;\n            case 'bench':\n                await manageBench(interaction, userData, client);\n                break;\n        }\n    },\n};\n\nasync function showSquad(interaction, userData) {\n    const embed = new EmbedBuilder()\n        .setTitle(`‚öΩ ${interaction.user.username}'s Squad`)\n        .setColor('#00ff00')\n        .setThumbnail(interaction.user.displayAvatarURL());\n\n    const formation = userData.formation || '4-3-3';\n    const requiredPositions = FORMATION_POSITIONS[formation];\n    \n    // Calculate team overall\n    const mainPlayers = userData.squad.main\n        .map(playerId => userData.players?.find(p => p.id === playerId))\n        .filter(Boolean);\n    \n    const teamOverall = mainPlayers.length > 0 \n        ? Math.round(mainPlayers.reduce((sum, p) => sum + p.overall, 0) / mainPlayers.length)\n        : 0;\n\n    embed.addFields({ \n        name: 'Formation & Team Rating', \n        value: `**${formation}** | Team Overall: **${teamOverall}**`, \n        inline: false \n    });\n\n    // Show main squad with better formatting\n    if (userData.squad.main.some(id => id !== null)) {\n        const mainSquad = userData.squad.main\n            .map((playerId, index) => {\n                const player = userData.players?.find(p => p.id === playerId);\n                const position = requiredPositions[index] || 'SUB';\n                const emoji = POSITION_EMOJIS[position] || '‚öΩ';\n                \n                if (player) {\n                    return `${emoji} ${position}: **${player.name}** (${player.overall})`;\n                } else {\n                    return `${emoji} ${position}: *Empty*`;\n                }\n            })\n            .join('\\n');\n        embed.addFields({ name: 'üèüÔ∏è Starting XI', value: mainSquad, inline: false });\n    } else {\n        embed.addFields({ name: 'üèüÔ∏è Starting XI', value: '*No players set - Use `/squad autoset` to fill automatically*', inline: false });\n    }\n\n    // Show bench with better formatting\n    if (userData.squad.bench.length > 0) {\n        const bench = userData.squad.bench\n            .map((playerId, index) => {\n                const player = userData.players?.find(p => p.id === playerId);\n                return player ? `${index + 1}. **${player.name}** (${player.overall})` : `${index + 1}. *Unknown Player*`;\n            })\n            .join('\\n');\n        embed.addFields({ name: 'ü™ë Bench Players', value: bench, inline: false });\n    } else {\n        embed.addFields({ name: 'ü™ë Bench Players', value: '*No bench players*', inline: false });\n    }\n\n    embed.setFooter({ text: 'Use /squad set to manually set players or /squad autoset for automatic setup' });\n    \n    await interaction.reply({ embeds: [embed] });\n}\n\nasync function setPlayer(interaction, userData, client) {\n    const position = interaction.options.getInteger('position') - 1;\n    const playerName = interaction.options.getString('player').toLowerCase();\n\n    if (!userData.players || userData.players.length === 0) {\n        return await interaction.reply({ content: '‚ùå You have no players. Use `/contract` to obtain players first.', ephemeral: true });\n    }\n\n    // Find the player with fuzzy matching\n    const player = userData.players.find(p => \n        p.name.toLowerCase().includes(playerName) || \n        p.name.toLowerCase().startsWith(playerName)\n    );\n\n    if (!player) {\n        return await interaction.reply({ content: `‚ùå Player \"${playerName}\" not found in your collection.`, ephemeral: true });\n    }\n\n    // Check if player is already in squad or bench\n    if (userData.squad.main.includes(player.id) || userData.squad.bench.includes(player.id)) {\n        return await interaction.reply({ content: `‚ùå **${player.name}** is already in your squad or bench.`, ephemeral: true });\n    }\n\n    // Remove any existing player at this position\n    const existingPlayerId = userData.squad.main[position];\n    const existingPlayer = existingPlayerId ? userData.players.find(p => p.id === existingPlayerId) : null;\n\n    // Set the new player\n    userData.squad.main[position] = player.id;\n    client.setUserData(interaction.user.id, userData);\n\n    const formation = userData.formation || '4-3-3';\n    const positionName = FORMATION_POSITIONS[formation][position] || 'SUB';\n    const emoji = POSITION_EMOJIS[positionName] || '‚öΩ';\n\n    let message = `‚úÖ Set **${player.name}** as ${emoji} ${positionName} (Position ${position + 1}).`;\n    if (existingPlayer) {\n        message += `\\n*Replaced ${existingPlayer.name}*`;\n    }\n\n    await interaction.reply({ content: message });\n}\n\nasync function removePlayer(interaction, userData, client) {\n    const position = interaction.options.getInteger('position') - 1;\n\n    if (!userData.squad.main[position]) {\n        return await interaction.reply({ content: `‚ùå Position ${position + 1} is already empty.`, ephemeral: true });\n    }\n\n    const playerId = userData.squad.main[position];\n    const player = userData.players?.find(p => p.id === playerId);\n    userData.squad.main[position] = null;\n\n    client.setUserData(interaction.user.id, userData);\n    \n    const formation = userData.formation || '4-3-3';\n    const positionName = FORMATION_POSITIONS[formation][position] || 'SUB';\n    \n    await interaction.reply({ content: `‚úÖ Removed **${player ? player.name : 'Unknown Player'}** from ${positionName} (Position ${position + 1}).` });\n}\n\nasync function setFormation(interaction, userData, client) {\n    const formation = interaction.options.getString('formation');\n    const oldFormation = userData.formation || '4-3-3';\n\n    userData.formation = formation;\n    client.setUserData(interaction.user.id, userData);\n    \n    let message = `‚úÖ Formation changed from **${oldFormation}** to **${formation}**.`;\n    if (oldFormation !== formation) {\n        message += '\\n*Your current players will stay in their positions, but may need repositioning for optimal chemistry.*';\n    }\n    \n    await interaction.reply({ content: message });\n}\n\nasync function manageBench(interaction, userData, client) {\n    const action = interaction.options.getString('action');\n    const playerName = interaction.options.getString('player').toLowerCase();\n\n    if (!userData.players || userData.players.length === 0) {\n        return await interaction.reply({ content: '‚ùå You have no players. Use `/contract` to obtain players first.', ephemeral: true });\n    }\n\n    if (action === 'add') {\n        if (userData.squad.bench.length >= 7) {\n            return await interaction.reply({ content: '‚ùå Your bench is full (7 players maximum).', ephemeral: true });\n        }\n\n        const player = userData.players.find(p => \n            p.name.toLowerCase().includes(playerName) ||\n            p.name.toLowerCase().startsWith(playerName)\n        );\n\n        if (!player) {\n            return await interaction.reply({ content: `‚ùå Player \"${playerName}\" not found in your collection.`, ephemeral: true });\n        }\n\n        if (userData.squad.main.includes(player.id) || userData.squad.bench.includes(player.id)) {\n            return await interaction.reply({ content: `‚ùå **${player.name}** is already in your squad or bench.`, ephemeral: true });\n        }\n\n        userData.squad.bench.push(player.id);\n        client.setUserData(interaction.user.id, userData);\n        await interaction.reply({ content: `‚úÖ Added **${player.name}** (${player.overall}) to the bench.` });\n\n    } else if (action === 'remove') {\n        const benchPlayer = userData.players.find(p => \n            (p.name.toLowerCase().includes(playerName) || p.name.toLowerCase().startsWith(playerName)) && \n            userData.squad.bench.includes(p.id)\n        );\n\n        if (!benchPlayer) {\n            return await interaction.reply({ content: `‚ùå Player \"${playerName}\" not found on your bench.`, ephemeral: true });\n        }\n\n        userData.squad.bench = userData.squad.bench.filter(id => id !== benchPlayer.id);\n        client.setUserData(interaction.user.id, userData);\n        await interaction.reply({ content: `‚úÖ Removed **${benchPlayer.name}** from the bench.` });\n    }\n}\n\n// --- Improved Autoset Logic ---\nfunction pickBestByPosition(playersPool, position, takenIds) {\n    const candidates = playersPool\n        .filter(p => p.position === position && !takenIds.has(p.id))\n        .sort((a, b) => b.overall - a.overall);\n    return candidates.length ? candidates[0] : null;\n}\n\nfunction pickBestCompatible(playersPool, requiredPosition, takenIds) {\n    // Position compatibility mapping\n    const compatibility = {\n        'GK': ['GK'],\n        'CB': ['CB', 'LB', 'RB'],\n        'LB': ['LB', 'CB', 'LMF'],\n        'RB': ['RB', 'CB', 'RMF'],\n        'DMF': ['DMF', 'CMF', 'CB'],\n        'CMF': ['CMF', 'DMF', 'AMF'],\n        'AMF': ['AMF', 'CMF', 'CF'],\n        'LMF': ['LMF', 'LB', 'LWF'],\n        'RMF': ['RMF', 'RB', 'RWF'],\n        'CF': ['CF', 'AMF'],\n        'LWF': ['LWF', 'CF', 'LMF'],\n        'RWF': ['RWF', 'CF', 'RMF']\n    };\n\n    const compatiblePositions = compatibility[requiredPosition] || [requiredPosition];\n    \n    for (const pos of compatiblePositions) {\n        const candidate = pickBestByPosition(playersPool, pos, takenIds);\n        if (candidate) return candidate;\n    }\n    \n    return null;\n}\n\nfunction pickBestAny(playersPool, takenIds) {\n    const candidates = playersPool\n        .filter(p => !takenIds.has(p.id))\n        .sort((a, b) => b.overall - a.overall);\n    return candidates.length ? candidates[0] : null;\n}\n\nasync function autosetSquad(interaction, userData, client) {\n    const formation = userData.formation || '4-3-3';\n    const requiredPositions = FORMATION_POSITIONS[formation];\n\n    if (!userData.players || userData.players.length === 0) {\n        return await interaction.reply({ content: '‚ùå You have no players. Use `/contract` to obtain players first.', ephemeral: true });\n    }\n\n    const taken = new Set();\n    const main = new Array(11).fill(null);\n\n    // First pass: exact position matches\n    for (let i = 0; i < requiredPositions.length; i++) {\n        const pos = requiredPositions[i];\n        const best = pickBestByPosition(userData.players, pos, taken);\n        if (best) {\n            main[i] = best.id;\n            taken.add(best.id);\n        }\n    }\n\n    // Second pass: compatible positions\n    for (let i = 0; i < requiredPositions.length; i++) {\n        if (!main[i]) {\n            const pos = requiredPositions[i];\n            const compatible = pickBestCompatible(userData.players, pos, taken);\n            if (compatible) {\n                main[i] = compatible.id;\n                taken.add(compatible.id);\n            }\n        }\n    }\n\n    // Third pass: fill remaining with best available\n    for (let i = 0; i < requiredPositions.length; i++) {\n        if (!main[i]) {\n            const bestAny = pickBestAny(userData.players, taken);\n            if (bestAny) {\n                main[i] = bestAny.id;\n                taken.add(bestAny.id);\n            }\n        }\n    }\n\n    // Fill bench with top 7 remaining players\n    const bench = userData.players\n        .filter(p => !taken.has(p.id))\n        .sort((a, b) => b.overall - a.overall)\n        .slice(0, 7)\n        .map(p => p.id);\n\n    userData.squad.main = main;\n    userData.squad.bench = bench;\n    client.setUserData(interaction.user.id, userData);\n\n    // Calculate team overall\n    const teamPlayers = main\n        .map(pid => userData.players.find(p => p.id === pid))\n        .filter(Boolean);\n    const teamOverall = teamPlayers.length > 0 \n        ? Math.round(teamPlayers.reduce((sum, p) => sum + p.overall, 0) / teamPlayers.length)\n        : 0;\n\n    const embed = new EmbedBuilder()\n        .setTitle('‚úÖ Squad Auto-Set Complete')\n        .setColor('#00ff00')\n        .setDescription(`**Formation:** ${formation}\\n**Team Overall:** ${teamOverall}`)\n        .addFields(\n            { \n                name: 'üèüÔ∏è Starting XI', \n                value: main.map((pid, idx) => {\n                    const pos = requiredPositions[idx];\n                    const player = userData.players.find(p => p.id === pid);\n                    const emoji = POSITION_EMOJIS[pos] || '‚öΩ';\n                    return player ? `${emoji} ${pos}: **${player.name}** (${player.overall})` : `${emoji} ${pos}: *Empty*`;\n                }).join('\\n'),\n                inline: false\n            },\n            { \n                name: 'ü™ë Bench', \n                value: bench.length > 0 \n                    ? bench.map(pid => {\n                        const player = userData.players.find(p => p.id === pid);\n                        return player ? `**${player.name}** (${player.overall})` : '*Unknown*';\n                    }).join(', ')\n                    : '*No bench players*',\n                inline: false\n            }\n        );\n\n    await interaction.reply({ embeds: [embed] });\n}","size_bytes":17509},"public/my-team.js":{"content":"// Global state\nlet userData = null;\nlet allPlayers = [];\nlet currentSquad = { main: [], bench: [] };\nlet currentFormation = '4-3-3';\nlet availablePlayersList = [];\nlet autoScrollInterval = null;\n\nconst FORMATIONS = {\n    '4-3-3': ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', 'LWF', 'CF', 'RWF'],\n    '4-4-2': ['GK', 'LB', 'CB', 'CB', 'RB', 'LMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n    '3-5-2': ['GK', 'CB', 'CB', 'CB', 'LMF', 'CMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n    '4-2-3-1': ['GK', 'LB', 'CB', 'CB', 'RB', 'DMF', 'DMF', 'AMF', 'AMF', 'AMF', 'CF']\n};\n\nconst RARITY_EMOJIS = {\n    'Iconic': 'üíé',\n    'Legend': 'üåü',\n    'Black': '‚ö´',\n    'Gold': 'üü°',\n    'Silver': '‚ö™',\n    'Bronze': 'üü§',\n    'White': '‚¨ú'\n};\n\n// Initialize dashboard\nasync function init() {\n    await loadUserData();\n    await loadPlayers();\n    await loadSquad(); // This now handles rendering internally\n    renderAllPlayers();\n}\n\n// Load user data\nasync function loadUserData() {\n    try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        userData = data;\n        \n        // Update UI\n        document.getElementById('username').textContent = data.discord.username;\n        document.getElementById('userAvatar').src = `https://cdn.discordapp.com/avatars/${data.discord.id}/${data.discord.avatar}.png`;\n        \n        if (data.gameData) {\n            document.getElementById('gpAmount').textContent = (data.gameData.gp || 0).toLocaleString();\n            document.getElementById('eCoinsAmount').textContent = data.gameData.eCoins || 0;\n            document.getElementById('playerCount').textContent = (data.gameData.players || []).length;\n        }\n    } catch (error) {\n        console.error('Error loading user data:', error);\n    }\n}\n\n// Load players\nasync function loadPlayers() {\n    try {\n        const response = await fetch('/api/players');\n        const data = await response.json();\n        allPlayers = data.players || [];\n        availablePlayersList = [...allPlayers];\n    } catch (error) {\n        console.error('Error loading players:', error);\n    }\n}\n\n// Load squad\nasync function loadSquad() {\n    try {\n        const response = await fetch('/api/squad');\n        const data = await response.json();\n        currentSquad = data.squad || { main: [], bench: [] };\n        \n        currentFormation = data.formation || '4-3-3';\n        document.getElementById('formationSelect').value = currentFormation;\n        \n        // CRITICAL: Remove duplicates from loaded squad\n        const hadDuplicates = cleanupDuplicates();\n        \n        // If duplicates were found and removed, auto-save the cleaned squad\n        if (hadDuplicates) {\n            console.log('Duplicates detected and removed. Auto-saving cleaned squad...');\n            await saveSquad(true); // Silent save\n        }\n        \n        // FORCE RE-RENDER after cleanup\n        renderSquadPitch();\n        renderAvailablePlayers();\n        calculateTeamRating();\n    } catch (error) {\n        console.error('Error loading squad:', error);\n    }\n}\n\n// Clean up duplicate players in squad\nfunction cleanupDuplicates() {\n    const seenIds = new Set();\n    const cleanMain = [];\n    let foundDuplicates = false;\n    \n    // Clean main squad - keep first occurrence, remove duplicates\n    for (let i = 0; i < currentSquad.main.length; i++) {\n        const playerId = currentSquad.main[i];\n        \n        if (playerId === null || playerId === undefined) {\n            cleanMain.push(null);\n        } else if (!seenIds.has(playerId)) {\n            seenIds.add(playerId);\n            cleanMain.push(playerId);\n        } else {\n            // Duplicate found - replace with null\n            console.warn(`Duplicate player ${playerId} found at position ${i}, removing...`);\n            cleanMain.push(null);\n            foundDuplicates = true;\n        }\n    }\n    \n    // Clean bench - remove duplicates and players already in main squad\n    const cleanBench = [];\n    for (const playerId of currentSquad.bench) {\n        if (playerId !== null && playerId !== undefined && !seenIds.has(playerId)) {\n            seenIds.add(playerId);\n            cleanBench.push(playerId);\n        } else if (playerId !== null && playerId !== undefined) {\n            console.warn(`Duplicate player ${playerId} found in bench, removing...`);\n            foundDuplicates = true;\n        }\n    }\n    \n    // Update squad with cleaned data\n    currentSquad.main = cleanMain;\n    currentSquad.bench = cleanBench.slice(0, 8); // Enforce 8 player limit\n    \n    if (foundDuplicates) {\n        console.log('Squad cleaned - duplicates removed:', {\n            main: cleanMain.filter(id => id !== null).length,\n            bench: cleanBench.length\n        });\n    }\n    \n    return foundDuplicates;\n}\n\n// Calculate team rating\nfunction calculateTeamRating() {\n    const mainPlayers = currentSquad.main.filter(id => id !== null);\n    if (mainPlayers.length === 0) {\n        document.getElementById('teamRating').textContent = '0';\n        return;\n    }\n    \n    let totalRating = 0;\n    let count = 0;\n    \n    mainPlayers.forEach(playerId => {\n        const player = allPlayers.find(p => p.id === playerId);\n        if (player) {\n            totalRating += player.overall;\n            count++;\n        }\n    });\n    \n    const avgRating = count > 0 ? Math.round(totalRating / count) : 0;\n    document.getElementById('teamRating').textContent = avgRating;\n}\n\n// Render squad pitch\nfunction renderSquadPitch() {\n    const pitch = document.getElementById('squadPitch');\n    const positions = FORMATIONS[currentFormation];\n    \n    // Group positions by rows\n    const rows = {\n        'GK': [positions[0]],\n        'DEF': positions.slice(1, 5).filter(p => p.includes('B')),\n        'MID': positions.filter(p => p.includes('MF')),\n        'ATT': positions.filter(p => p.includes('WF') || p === 'CF')\n    };\n    \n    pitch.innerHTML = '';\n    \n    // Render from attack to defense\n    ['ATT', 'MID', 'DEF', 'GK'].forEach(line => {\n        if (rows[line] && rows[line].length > 0) {\n            const row = document.createElement('div');\n            row.className = 'squad-row';\n            \n            // Track which indices we've already used to avoid duplicates\n            const usedIndices = new Set();\n            \n            rows[line].forEach((position, idx) => {\n                // Find the NEXT occurrence of this position that we haven't used yet\n                let posIndex = -1;\n                for (let i = 0; i < positions.length; i++) {\n                    if (positions[i] === position && !usedIndices.has(i)) {\n                        posIndex = i;\n                        usedIndices.add(i);\n                        break;\n                    }\n                }\n                \n                if (posIndex === -1) return; // Skip if not found\n                \n                const playerId = currentSquad.main[posIndex];\n                const player = playerId ? allPlayers.find(p => p.id === playerId) : null;\n                \n                const slot = document.createElement('div');\n                slot.className = player ? 'player-slot filled' : 'player-slot';\n                slot.dataset.position = posIndex;\n                \n                // Add drag and drop events\n                slot.draggable = player ? true : false;\n                if (player) {\n                    slot.dataset.playerId = player.id;\n                    slot.dataset.rarity = player.rarity;\n                    slot.addEventListener('dragstart', handleDragStart);\n                    slot.addEventListener('dragend', handleDragEnd);\n                    \n                    // Get player image from local assets - try multiple formats\n                    // Sanitize player name: lowercase, replace non-alphanumeric with _, collapse multiple _, trim trailing _\n                    const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n                    const playerImagePng = `/assets/faces/${playerImageName}.png`;\n                    const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n                    \n                    slot.innerHTML = `\n                        <div class=\"pitch-card\">\n                            <div class=\"pitch-card-rating\">${player.overall}</div>\n                            <div class=\"pitch-card-position\">${position}</div>\n                            <div class=\"pitch-card-image\">\n                                <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                                     onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n                            </div>\n                            <div class=\"pitch-card-name\">${player.name}</div>\n                            <div class=\"pitch-card-stats\">\n                                <span class=\"stat-badge\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</span>\n                            </div>\n                        </div>\n                    `;\n                } else {\n                    slot.onclick = () => openPlayerSelector(posIndex);\n                    slot.innerHTML = `\n                        <div class=\"pitch-card-empty\">\n                            <div class=\"empty-position\">${position}</div>\n                            <div class=\"empty-text\">Click to add</div>\n                        </div>\n                    `;\n                }\n                \n                slot.addEventListener('dragover', handleDragOver);\n                slot.addEventListener('drop', handleDrop);\n                slot.addEventListener('dragleave', handleDragLeave);\n                \n                row.appendChild(slot);\n            });\n            \n            pitch.appendChild(row);\n        }\n    });\n    \n    renderBench();\n}\n\n// Render bench\nfunction renderBench() {\n    const benchContainer = document.getElementById('benchPlayers');\n    benchContainer.innerHTML = '';\n    \n    if (!currentSquad.bench || currentSquad.bench.length === 0) {\n        benchContainer.innerHTML = '<p style=\"color: #999;\">No bench players</p>';\n        return;\n    }\n    \n    currentSquad.bench.forEach((playerId, idx) => {\n        const player = allPlayers.find(p => p.id === playerId);\n        if (player) {\n            const benchPlayer = document.createElement('div');\n            benchPlayer.className = 'bench-player';\n            benchPlayer.draggable = true;\n            benchPlayer.dataset.playerId = player.id;\n            benchPlayer.dataset.rarity = player.rarity;\n            benchPlayer.dataset.benchIndex = idx;\n            benchPlayer.dataset.source = 'bench';\n            \n            // Add drag events for bench players\n            benchPlayer.addEventListener('dragstart', handleBenchDragStart);\n            benchPlayer.addEventListener('dragend', handleDragEnd);\n            benchPlayer.addEventListener('dragover', handleDragOver);\n            benchPlayer.addEventListener('drop', handleBenchDrop);\n            benchPlayer.addEventListener('dragleave', handleDragLeave);\n            \n            benchPlayer.onclick = () => showPlayerDetails(player);\n            \n            // Sanitize player name: lowercase, replace non-alphanumeric with _, collapse multiple _, trim trailing _\n            const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n            const playerImagePng = `/assets/faces/${playerImageName}.png`;\n            const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n            \n            benchPlayer.innerHTML = `\n                <div class=\"bench-card-rating\">${player.overall}</div>\n                <div class=\"bench-card-position\">${player.position}</div>\n                <div class=\"bench-card-image\">\n                    <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                         onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n                </div>\n                <div class=\"bench-card-name\">${player.name}</div>\n            `;\n            benchContainer.appendChild(benchPlayer);\n        }\n    });\n}\n\nfunction renderAvailablePlayers() {\n    const container = document.getElementById('availablePlayers');\n    container.innerHTML = '';\n    \n    // Filter out players already in squad or bench\n    const usedPlayerIds = [\n        ...currentSquad.main.filter(id => id !== null),\n        ...currentSquad.bench.filter(id => id !== null)\n    ];\n    const available = availablePlayersList.filter(p => !usedPlayerIds.includes(p.id));\n    \n    if (available.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No available players</p>';\n        return;\n    }\n    \n    available.forEach(player => {\n        const card = document.createElement('div');\n        card.className = 'available-player-card';\n        card.draggable = true;\n        card.dataset.playerId = player.id;\n        card.dataset.rarity = player.rarity;\n        \n        // Add drag events\n        card.addEventListener('dragstart', (e) => {\n            draggedPlayerId = player.id;\n            draggedFromPosition = null;\n            draggedFromBench = false;\n            card.classList.add('dragging');\n            e.dataTransfer.effectAllowed = 'move';\n            startAutoScroll(e);\n        });\n        \n        card.addEventListener('dragend', (e) => {\n            card.classList.remove('dragging');\n            stopAutoScroll();\n        });\n        \n        card.onclick = () => showPlayerDetails(player);\n        \n        // Sanitize player name: lowercase, replace non-alphanumeric with _, collapse multiple _, trim trailing _\n        const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n        const playerImagePng = `/assets/faces/${playerImageName}.png`;\n        const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n        \n        card.innerHTML = `\n            <div class=\"available-card-rating\">${player.overall}</div>\n            <div class=\"available-card-position\">${player.position}</div>\n            <div class=\"available-card-rarity\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</div>\n            <div class=\"available-card-image\">\n                <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                     onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n            </div>\n            <div class=\"available-card-name\">${player.name}</div>\n        `;\n        \n        container.appendChild(card);\n    });\n}\n\n// Render all players\nfunction renderAllPlayers() {\n    const container = document.getElementById('allPlayersGrid');\n    container.innerHTML = '';\n    \n    if (allPlayers.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No players in collection</p>';\n        return;\n    }\n    \n    allPlayers.forEach(player => {\n        const card = createPlayerCard(player, () => showPlayerDetails(player));\n        container.appendChild(card);\n    });\n}\n\n// Show player details modal\nfunction showPlayerDetails(player) {\n    const modal = document.getElementById('playerModal');\n    const content = document.getElementById('playerModalContent');\n    \n    const stats = player.stats || {};\n    \n    content.innerHTML = `\n        <h2>${RARITY_EMOJIS[player.rarity] || '‚öΩ'} ${player.name}</h2>\n        <div style=\"margin: 20px 0;\">\n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;\">\n                <div><strong>Overall:</strong> ${player.overall}</div>\n                <div><strong>Position:</strong> ${player.position}</div>\n                <div><strong>Rarity:</strong> ${player.rarity}</div>\n                <div><strong>Style:</strong> ${player.playingStyle || 'N/A'}</div>\n            </div>\n            \n            <h3 style=\"color: var(--primary); margin: 20px 0 10px 0;\">Stats</h3>\n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 10px;\">\n                <div>‚öîÔ∏è Attacking: ${stats.attacking || 0}</div>\n                <div>üéØ Dribbling: ${stats.dribbling || 0}</div>\n                <div>üéØ Passing: ${stats.passing || 0}</div>\n                <div>üõ°Ô∏è Defending: ${stats.defending || 0}</div>\n                <div>üí™ Physicality: ${stats.physicality || 0}</div>\n                <div>üß§ Goalkeeping: ${stats.goalkeeping || 0}</div>\n            </div>\n            \n            ${player.skills && player.skills.length > 0 ? `\n                <h3 style=\"color: var(--primary); margin: 20px 0 10px 0;\">Skills</h3>\n                <div style=\"color: #666;\">${player.skills.slice(0, 5).join(', ')}</div>\n            ` : ''}\n        </div>\n    `;\n    \n    modal.classList.add('active');\n    modal.style.display = 'flex';\n}\n\n// Close modal\nfunction closeModal() {\n    const modal = document.getElementById('playerModal');\n    modal.classList.remove('active');\n    modal.style.display = 'none';\n}\n\n// Open player selector for position\nlet selectedPosition = null;\n\nfunction openPlayerSelector(positionIndex) {\n    selectedPosition = positionIndex;\n    \n    // Show available players filtered by position\n    const requiredPos = FORMATIONS[currentFormation][positionIndex];\n    \n    // Get all used player IDs (filter out null and undefined)\n    const usedPlayerIds = [\n        ...currentSquad.main.filter(id => id !== null && id !== undefined),\n        ...currentSquad.bench.filter(id => id !== null && id !== undefined)\n    ];\n    \n    // Filter players by compatible positions\n    const compatible = allPlayers.filter(p => {\n        // Exclude players already in squad or bench\n        if (usedPlayerIds.includes(p.id)) return false;\n        \n        // Position compatibility\n        if (requiredPos === 'GK') return p.position === 'GK';\n        if (requiredPos.includes('B')) return ['CB', 'LB', 'RB'].includes(p.position);\n        if (requiredPos.includes('MF')) return ['DMF', 'CMF', 'AMF', 'LMF', 'RMF'].includes(p.position);\n        if (requiredPos.includes('WF') || requiredPos === 'CF') return ['LWF', 'RWF', 'CF'].includes(p.position);\n        return p.position === requiredPos;\n    });\n    \n    const container = document.getElementById('availablePlayers');\n    container.innerHTML = '';\n    \n    if (compatible.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No compatible players available</p>';\n        return;\n    }\n    \n    compatible.forEach(player => {\n        const card = createPlayerCard(player, () => {\n            assignPlayerToPosition(player.id, selectedPosition);\n        });\n        container.appendChild(card);\n    });\n    \n    // Switch to squad tab\n    showTab('squad');\n}\n\n// Assign player to position\nfunction assignPlayerToPosition(playerId, positionIndex) {\n    // CRITICAL: Check if player already exists ANYWHERE in squad or bench\n    const inSquad = currentSquad.main.filter(id => id !== null).indexOf(playerId);\n    const inBench = currentSquad.bench.filter(id => id !== null).indexOf(playerId);\n    \n    if (inSquad !== -1 && inSquad !== positionIndex) {\n        alert('‚ö†Ô∏è This player is already in your squad at another position!');\n        return;\n    }\n    \n    if (inBench !== -1) {\n        alert('‚ö†Ô∏è This player is already on your bench!');\n        return;\n    }\n    \n    // If position is already occupied, move that player to bench\n    const currentPlayerAtPosition = currentSquad.main[positionIndex];\n    if (currentPlayerAtPosition && currentPlayerAtPosition !== playerId) {\n        // Check bench limit (max 8 players)\n        if (currentSquad.bench.length >= 8) {\n            alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed on bench.');\n            return;\n        }\n        currentSquad.bench.push(currentPlayerAtPosition);\n    }\n    \n    // Assign player to position\n    currentSquad.main[positionIndex] = playerId;\n    \n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n}\n\n// Change formation\nfunction changeFormation() {\n    const newFormation = document.getElementById('formationSelect').value;\n    \n    if (confirm(`Change formation to ${newFormation}? Your current squad will be cleared.`)) {\n        currentFormation = newFormation;\n        currentSquad.main = new Array(11).fill(null);\n        renderSquadPitch();\n        renderAvailablePlayers();\n        calculateTeamRating();\n    } else {\n        document.getElementById('formationSelect').value = currentFormation;\n    }\n}\n\n// Save squad\nasync function saveSquad(silent = false) {\n    try {\n        const response = await fetch('/api/squad/update', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                squad: currentSquad,\n                formation: currentFormation\n            })\n        });\n        \n        const result = await response.json();\n        \n        if (result.success) {\n            if (!silent) {\n                alert('‚úÖ Squad saved successfully!');\n            } else {\n                console.log('‚úÖ Squad auto-saved after cleanup');\n            }\n        } else {\n            if (!silent) {\n                alert('‚ùå Failed to save squad: ' + (result.error || 'Unknown error'));\n            }\n        }\n    } catch (error) {\n        console.error('Error saving squad:', error);\n        if (!silent) {\n            alert('‚ùå Failed to save squad. Please try again.');\n        }\n    }\n}\n\n// Filter players\nfunction filterPlayers() {\n    const searchTerm = document.getElementById('playerSearch').value.toLowerCase();\n    const positionFilter = document.getElementById('positionFilter').value;\n    const ratingSort = document.getElementById('availableRatingSort').value;\n    \n    availablePlayersList = allPlayers.filter(player => {\n        const matchesSearch = player.name.toLowerCase().includes(searchTerm);\n        let matchesPosition = true;\n        \n        if (positionFilter) {\n            if (positionFilter === 'DEF') {\n                matchesPosition = ['CB', 'LB', 'RB'].includes(player.position);\n            } else if (positionFilter === 'MID') {\n                matchesPosition = ['DMF', 'CMF', 'AMF', 'LMF', 'RMF'].includes(player.position);\n            } else if (positionFilter === 'ATT') {\n                matchesPosition = ['LWF', 'RWF', 'CF'].includes(player.position);\n            } else {\n                matchesPosition = player.position === positionFilter;\n            }\n        }\n        \n        return matchesSearch && matchesPosition;\n    });\n    \n    // Sort by rating if selected\n    if (ratingSort === 'high-low') {\n        availablePlayersList.sort((a, b) => b.overall - a.overall);\n    } else if (ratingSort === 'low-high') {\n        availablePlayersList.sort((a, b) => a.overall - b.overall);\n    }\n    \n    renderAvailablePlayers();\n}\n\n// Filter all players\nfunction filterAllPlayers() {\n    const searchTerm = document.getElementById('allPlayersSearch').value.toLowerCase();\n    const rarityFilter = document.getElementById('rarityFilter').value;\n    const ratingSort = document.getElementById('ratingSort').value;\n    \n    let filtered = allPlayers.filter(player => {\n        const matchesSearch = player.name.toLowerCase().includes(searchTerm);\n        const matchesRarity = !rarityFilter || player.rarity === rarityFilter;\n        return matchesSearch && matchesRarity;\n    });\n    \n    // Sort by rating if selected\n    if (ratingSort === 'high-low') {\n        filtered.sort((a, b) => b.overall - a.overall);\n    } else if (ratingSort === 'low-high') {\n        filtered.sort((a, b) => a.overall - b.overall);\n    }\n    \n    const container = document.getElementById('allPlayersGrid');\n    container.innerHTML = '';\n    \n    if (filtered.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No players found</p>';\n        return;\n    }\n    \n    filtered.forEach(player => {\n        const card = createPlayerCard(player, () => showPlayerDetails(player));\n        container.appendChild(card);\n    });\n}\n\n// Show team tab\nfunction showTeamTab(tabName) {\n    // Hide all tabs\n    document.querySelectorAll('.team-tab-content').forEach(tab => {\n        tab.classList.remove('active');\n    });\n    \n    // Show selected tab\n    document.getElementById(`${tabName}-tab`).classList.add('active');\n    \n    // Update tab buttons\n    document.querySelectorAll('.team-tab').forEach(btn => {\n        btn.classList.remove('active');\n    });\n    event.target.classList.add('active');\n}\n\n// Close modal on outside click\nwindow.onclick = function(event) {\n    const modal = document.getElementById('playerModal');\n    if (event.target === modal) {\n        closeModal();\n    }\n}\n\n// Drag and Drop Handlers\nlet draggedElement = null;\nlet draggedPlayerId = null;\nlet draggedFromPosition = null;\nlet draggedFromBench = false;\nlet draggedBenchIndex = null;\n\nfunction handleDragStart(e) {\n    draggedElement = e.target;\n    draggedPlayerId = e.target.dataset.playerId;\n    draggedFromPosition = parseInt(e.target.dataset.position);\n    draggedFromBench = false;\n    draggedBenchIndex = null;\n    \n    e.target.classList.add('dragging');\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/html', e.target.innerHTML);\n    \n    // Start auto-scroll\n    startAutoScroll(e);\n}\n\nfunction handleBenchDragStart(e) {\n    draggedElement = e.target;\n    draggedPlayerId = e.target.dataset.playerId;\n    draggedFromPosition = null;\n    draggedFromBench = true;\n    draggedBenchIndex = parseInt(e.target.dataset.benchIndex);\n    \n    e.target.classList.add('dragging');\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/html', e.target.innerHTML);\n    \n    // Start auto-scroll\n    startAutoScroll(e);\n}\n\nfunction handleDragEnd(e) {\n    e.target.classList.remove('dragging');\n    \n    // Stop auto-scroll\n    stopAutoScroll();\n    \n    // Remove drag-over class from all slots\n    document.querySelectorAll('.player-slot').forEach(slot => {\n        slot.classList.remove('drag-over');\n    });\n}\n\nfunction handleDragOver(e) {\n    if (e.preventDefault) {\n        e.preventDefault();\n    }\n    \n    e.dataTransfer.dropEffect = 'move';\n    e.target.closest('.player-slot')?.classList.add('drag-over');\n    \n    return false;\n}\n\nfunction handleDragLeave(e) {\n    e.target.closest('.player-slot')?.classList.remove('drag-over');\n}\n\nfunction handleDrop(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n    \n    e.preventDefault();\n    \n    const dropSlot = e.target.closest('.player-slot');\n    if (!dropSlot) return;\n    \n    const dropPosition = parseInt(dropSlot.dataset.position);\n    const dropPlayerId = dropSlot.dataset.playerId;\n    \n    // Don't drop on the same position\n    if (!draggedFromBench && draggedFromPosition === dropPosition) {\n        dropSlot.classList.remove('drag-over');\n        return false;\n    }\n    \n    // If dragging from bench\n    if (draggedFromBench) {\n        // Remove from bench\n        currentSquad.bench.splice(draggedBenchIndex, 1);\n        \n        // If dropping on occupied slot, move that player to bench\n        if (dropPlayerId) {\n            // Check bench limit before adding\n            if (currentSquad.bench.length >= 8) {\n                alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n                currentSquad.bench.splice(draggedBenchIndex, 0, draggedPlayerId); // Put back\n                dropSlot.classList.remove('drag-over');\n                return false;\n            }\n            currentSquad.bench.push(dropPlayerId);\n        }\n        \n        // Add to squad position\n        currentSquad.main[dropPosition] = draggedPlayerId;\n    }\n    // If dragging from available players (not from pitch or bench)\n    else if (draggedFromPosition === null && !draggedFromBench) {\n        // Check if player already exists in squad (strict check)\n        const inSquad = currentSquad.main.filter(id => id !== null).indexOf(draggedPlayerId);\n        if (inSquad !== -1) {\n            alert('‚ö†Ô∏è This player is already in your squad!');\n            dropSlot.classList.remove('drag-over');\n            return false;\n        }\n        \n        // Check if player is in bench (strict check)\n        const inBench = currentSquad.bench.filter(id => id !== null).indexOf(draggedPlayerId);\n        if (inBench !== -1) {\n            alert('‚ö†Ô∏è This player is already on your bench!');\n            dropSlot.classList.remove('drag-over');\n            return false;\n        }\n        \n        // If dropping on occupied slot, move that player to bench\n        if (dropPlayerId) {\n            // Check bench limit before adding\n            if (currentSquad.bench.length >= 8) {\n                alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n                dropSlot.classList.remove('drag-over');\n                return false;\n            }\n            currentSquad.bench.push(dropPlayerId);\n        }\n        \n        // Add to position\n        currentSquad.main[dropPosition] = draggedPlayerId;\n    } else {\n        // Swap players from pitch\n        if (dropPlayerId) {\n            // Swap the two players\n            currentSquad.main[draggedFromPosition] = dropPlayerId;\n            currentSquad.main[dropPosition] = draggedPlayerId;\n        } else {\n            // Move to empty slot\n            currentSquad.main[dropPosition] = draggedPlayerId;\n            currentSquad.main[draggedFromPosition] = null;\n        }\n    }\n    \n    // Re-render the pitch\n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n    \n    return false;\n}\n\n// Handle drop on bench\nfunction handleBenchDrop(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n    \n    e.preventDefault();\n    \n    const dropTarget = e.target.closest('.bench-player');\n    \n    // If dragging from squad to bench\n    if (draggedFromPosition !== null && !draggedFromBench) {\n        // Check bench limit\n        if (currentSquad.bench.length >= 8) {\n            alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n            return false;\n        }\n        \n        // Remove from squad\n        currentSquad.main[draggedFromPosition] = null;\n        \n        // Add to bench if not already there\n        if (!currentSquad.bench.includes(draggedPlayerId)) {\n            currentSquad.bench.push(draggedPlayerId);\n        }\n    }\n    // If dragging from available players to bench\n    else if (draggedFromPosition === null && !draggedFromBench) {\n        // Check bench limit\n        if (currentSquad.bench.length >= 8) {\n            alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n            return false;\n        }\n        \n        // Check if already in squad or bench (strict check)\n        const inSquad = currentSquad.main.filter(id => id !== null).includes(draggedPlayerId);\n        const inBench = currentSquad.bench.filter(id => id !== null).includes(draggedPlayerId);\n        \n        if (inSquad) {\n            alert('‚ö†Ô∏è This player is already in your squad!');\n            return false;\n        }\n        if (inBench) {\n            alert('‚ö†Ô∏è This player is already on your bench!');\n            return false;\n        }\n        \n        // Add to bench\n        currentSquad.bench.push(draggedPlayerId);\n    }\n    // If swapping bench players\n    else if (draggedFromBench && dropTarget) {\n        const dropBenchIndex = parseInt(dropTarget.dataset.benchIndex);\n        if (draggedBenchIndex !== dropBenchIndex) {\n            // Swap bench positions\n            const temp = currentSquad.bench[draggedBenchIndex];\n            currentSquad.bench[draggedBenchIndex] = currentSquad.bench[dropBenchIndex];\n            currentSquad.bench[dropBenchIndex] = temp;\n        }\n    }\n    \n    // Re-render\n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n    \n    return false;\n}\n\n// Make player cards draggable too\nfunction createPlayerCard(player, onClick) {\n    const card = document.createElement('div');\n    card.className = 'player-card';\n    card.draggable = true;\n    card.dataset.playerId = player.id;\n    card.dataset.rarity = player.rarity;\n    \n    // Drag events for player cards\n    card.addEventListener('dragstart', (e) => {\n        draggedPlayerId = player.id;\n        draggedFromPosition = null; // Coming from available players\n        e.target.classList.add('dragging');\n        e.dataTransfer.effectAllowed = 'copy';\n    });\n    \n    card.addEventListener('dragend', (e) => {\n        e.target.classList.remove('dragging');\n    });\n    \n    card.onclick = onClick;\n    \n    // Sanitize player name for image\n    const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n    const playerImagePng = `/assets/faces/${playerImageName}.png`;\n    const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n    \n    card.innerHTML = `\n        <div class=\"player-image-container\">\n            <div class=\"player-overall\">${player.overall}</div>\n            <div class=\"player-position\">${player.position}</div>\n            <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                 onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n        </div>\n        <div class=\"rarity\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</div>\n        <div class=\"name\">${player.name}</div>\n    `;\n    \n    return card;\n}\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    init();\n    \n    // Make bench section a drop zone\n    const benchSection = document.getElementById('benchSection');\n    if (benchSection) {\n        benchSection.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            benchSection.classList.add('drag-over');\n        });\n        \n        benchSection.addEventListener('dragleave', (e) => {\n            if (e.target === benchSection) {\n                benchSection.classList.remove('drag-over');\n            }\n        });\n        \n        benchSection.addEventListener('drop', (e) => {\n            e.preventDefault();\n            benchSection.classList.remove('drag-over');\n            \n            // Check bench limit first\n            if (currentSquad.bench.length >= 8 && !draggedFromBench) {\n                alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n                return;\n            }\n            \n            // If dragging from squad to bench\n            if (draggedFromPosition !== null && !draggedFromBench) {\n                currentSquad.main[draggedFromPosition] = null;\n                if (!currentSquad.bench.includes(draggedPlayerId)) {\n                    currentSquad.bench.push(draggedPlayerId);\n                }\n            }\n            // If dragging from available players to bench\n            else if (draggedFromPosition === null && !draggedFromBench) {\n                // Strict duplicate check\n                const inSquad = currentSquad.main.filter(id => id !== null).includes(draggedPlayerId);\n                const inBench = currentSquad.bench.filter(id => id !== null).includes(draggedPlayerId);\n                \n                if (!inSquad && !inBench) {\n                    currentSquad.bench.push(draggedPlayerId);\n                } else {\n                    alert('‚ö†Ô∏è This player is already in your squad or bench!');\n                    return;\n                }\n            }\n            \n            renderSquadPitch();\n            renderAvailablePlayers();\n            calculateTeamRating();\n        });\n    }\n});\n\n// Auto-scroll functionality\nfunction startAutoScroll(e) {\n    // Store initial mouse position\n    document.addEventListener('dragover', handleAutoScroll);\n}\n\nfunction handleAutoScroll(e) {\n    const scrollZone = 100; // pixels from edge to trigger scroll\n    const scrollSpeed = 10; // pixels per frame\n    \n    const viewportHeight = window.innerHeight;\n    const mouseY = e.clientY;\n    \n    // Scroll up if near top\n    if (mouseY < scrollZone) {\n        window.scrollBy(0, -scrollSpeed);\n    }\n    // Scroll down if near bottom\n    else if (mouseY > viewportHeight - scrollZone) {\n        window.scrollBy(0, scrollSpeed);\n    }\n}\n\nfunction stopAutoScroll() {\n    document.removeEventListener('dragover', handleAutoScroll);\n}\n","size_bytes":36627},"commands/managenews.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst NEWS_FILE = path.join(__dirname, '..', 'news.json');\nconst ADMIN_IDS = process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',') : [];\n\n// Ensure news file exists\nfunction ensureNewsFile() {\n    if (!fs.existsSync(NEWS_FILE)) {\n        fs.writeFileSync(NEWS_FILE, JSON.stringify([], null, 2));\n    }\n}\n\n// Load news\nfunction loadNews() {\n    ensureNewsFile();\n    const data = fs.readFileSync(NEWS_FILE, 'utf8');\n    return JSON.parse(data);\n}\n\n// Save news\nfunction saveNews(newsArray) {\n    fs.writeFileSync(NEWS_FILE, JSON.stringify(newsArray, null, 2));\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('managenews')\n        .setDescription('Manage game news (Admin only)')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Add a new news article')\n                .addStringOption(option =>\n                    option.setName('category')\n                        .setDescription('Category of news')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: '‚¨ÜÔ∏è Update', value: 'Update' },\n                            { name: '‚úï Issue', value: 'Issue' },\n                            { name: 'üéâ Event', value: 'Event' },\n                            { name: 'üîß Maintenance', value: 'Maintenance' },\n                            { name: 'üì¢ Announcement', value: 'Announcement' }\n                        ))\n                .addStringOption(option =>\n                    option.setName('title')\n                        .setDescription('News title')\n                        .setRequired(true)\n                        .setMaxLength(100))\n                .addStringOption(option =>\n                    option.setName('content')\n                        .setDescription('News content/description')\n                        .setRequired(true)\n                        .setMaxLength(1000)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remove')\n                .setDescription('Remove a news article by ID')\n                .addStringOption(option =>\n                    option.setName('id')\n                        .setDescription('News ID to remove (e.g., news_001)')\n                        .setRequired(true)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('list')\n                .setDescription('List all news articles with IDs'))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('clear')\n                .setDescription('Clear all news articles (use with caution!)')),\n    \n    async execute(interaction) {\n        // Check if user is admin\n        if (!ADMIN_IDS.includes(interaction.user.id) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {\n            return interaction.reply({\n                content: '‚ùå You do not have permission to use this command.',\n                ephemeral: true\n            });\n        }\n        \n        const subcommand = interaction.options.getSubcommand();\n        \n        try {\n            const newsArray = loadNews();\n            \n            if (subcommand === 'add') {\n                const category = interaction.options.getString('category');\n                const title = interaction.options.getString('title');\n                const content = interaction.options.getString('content');\n                \n                // Generate unique ID\n                const existingIds = newsArray.map(n => parseInt(n.id.replace('news_', '')));\n                const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;\n                \n                const newNews = {\n                    id: `news_${String(nextId).padStart(3, '0')}`,\n                    title: title,\n                    category: category,\n                    preview: content.substring(0, 60) + (content.length > 60 ? '...' : ''),\n                    content: content,\n                    date: new Date().toISOString()\n                };\n                \n                newsArray.push(newNews);\n                saveNews(newsArray);\n                \n                const categoryEmoji = {\n                    'Update': '‚¨ÜÔ∏è',\n                    'Issue': '‚úï',\n                    'Event': 'üéâ',\n                    'Maintenance': 'üîß',\n                    'Announcement': 'üì¢'\n                };\n                \n                const embed = new EmbedBuilder()\n                    .setColor('#27ae60')\n                    .setTitle('‚úÖ News Article Created')\n                    .setDescription('The news article has been successfully added to the website!')\n                    .addFields(\n                        { name: 'ID', value: newNews.id, inline: true },\n                        { name: 'Category', value: `${categoryEmoji[category]} ${category}`, inline: true },\n                        { name: 'Title', value: title, inline: false },\n                        { name: 'Content', value: content, inline: false }\n                    )\n                    .setFooter({ text: `Created by ${interaction.user.tag}` })\n                    .setTimestamp();\n                \n                await interaction.reply({ embeds: [embed] });\n                \n            } else if (subcommand === 'remove') {\n                const id = interaction.options.getString('id');\n                const newsIndex = newsArray.findIndex(n => n.id === id);\n                \n                if (newsIndex === -1) {\n                    return interaction.reply({\n                        content: `‚ùå No news article found with ID ${id}.`,\n                        ephemeral: true\n                    });\n                }\n                \n                const removedNews = newsArray[newsIndex];\n                newsArray.splice(newsIndex, 1);\n                saveNews(newsArray);\n                \n                const embed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('üóëÔ∏è News Article Removed')\n                    .setDescription(`Successfully removed news article ${id}`)\n                    .addFields(\n                        { name: 'Title', value: removedNews.title, inline: false },\n                        { name: 'Content', value: removedNews.content, inline: false }\n                    )\n                    .setTimestamp();\n                \n                await interaction.reply({ embeds: [embed] });\n                \n            } else if (subcommand === 'list') {\n                if (newsArray.length === 0) {\n                    return interaction.reply({\n                        content: 'üì∞ No news articles found.',\n                        ephemeral: true\n                    });\n                }\n                \n                const sortedNews = newsArray.sort((a, b) => new Date(b.date) - new Date(a.date));\n                \n                const embed = new EmbedBuilder()\n                    .setColor('#3498db')\n                    .setTitle('üìã All News Articles')\n                    .setDescription(`Total: ${sortedNews.length} article(s)`)\n                    .setTimestamp();\n                \n                const categoryEmoji = {\n                    'Update': '‚¨ÜÔ∏è',\n                    'Issue': '‚úï',\n                    'Event': 'üéâ',\n                    'Maintenance': 'üîß',\n                    'Announcement': 'üì¢'\n                };\n                \n                sortedNews.forEach(news => {\n                    const newsDate = new Date(news.date);\n                    const formattedDate = newsDate.toLocaleDateString('en-US', {\n                        year: 'numeric',\n                        month: 'short',\n                        day: 'numeric'\n                    });\n                    \n                    const emoji = categoryEmoji[news.category] || 'üì∞';\n                    \n                    embed.addFields({\n                        name: `${news.id} - ${emoji} ${news.title}`,\n                        value: `${news.preview || news.content.substring(0, 100)}\\n*${formattedDate}*`,\n                        inline: false\n                    });\n                });\n                \n                await interaction.reply({ embeds: [embed], ephemeral: true });\n                \n            } else if (subcommand === 'clear') {\n                const count = newsArray.length;\n                saveNews([]);\n                \n                const embed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('üóëÔ∏è All News Cleared')\n                    .setDescription(`Successfully removed ${count} news article(s).`)\n                    .setTimestamp();\n                \n                await interaction.reply({ embeds: [embed] });\n            }\n            \n        } catch (error) {\n            console.error('Error in managenews command:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while managing news.',\n                ephemeral: true\n            });\n        }\n    }\n};\n","size_bytes":9356},"web-server.js":{"content":"require('dotenv').config();\nconst express = require('express');\nconst session = require('express-session');\nconst passport = require('passport');\nconst DiscordStrategy = require('passport-discord').Strategy;\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst path = require('path');\nconst { spawn } = require('child_process');\nconst fs = require('fs');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\nconst CALLBACK_URL = process.env.CALLBACK_URL || `http://localhost:${PORT}/auth/discord/callback`;\n\n// Bot process management\nlet botProcess = null;\nlet botStatus = {\n    isRunning: false,\n    startTime: null,\n    restarts: 0,\n    lastError: null\n};\n\n// Discord OAuth2 Strategy\npassport.use(new DiscordStrategy({\n    clientID: process.env.DISCORD_CLIENT_ID,\n    clientSecret: process.env.DISCORD_CLIENT_SECRET,\n    callbackURL: CALLBACK_URL,\n    scope: ['identify', 'guilds']\n}, (accessToken, refreshToken, profile, done) => {\n    return done(null, profile);\n}));\n\npassport.serializeUser((user, done) => {\n    done(null, user);\n});\n\npassport.deserializeUser((obj, done) => {\n    done(null, obj);\n});\n\n// Middleware\napp.use(cookieParser());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({\n    secret: process.env.SESSION_SECRET || 'efotball-secret-key-change-this',\n    resave: false,\n    saveUninitialized: false,\n    cookie: { maxAge: 7 * 24 * 60 * 60 * 1000 } // 7 days\n}));\napp.use(passport.initialize());\napp.use(passport.session());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use('/assets', express.static(path.join(__dirname, 'assets')));\n\n// Helper: Get user data from bot's data directory\nfunction getUserData(userId) {\n    const dataPath = path.join(__dirname, 'data');\n    const userFile = path.join(dataPath, `${userId}.json`);\n    \n    if (fs.existsSync(userFile)) {\n        return JSON.parse(fs.readFileSync(userFile, 'utf8'));\n    }\n    return null;\n}\n\n// Helper: Save user data\nfunction setUserData(userId, data) {\n    const dataPath = path.join(__dirname, 'data');\n    if (!fs.existsSync(dataPath)) {\n        fs.mkdirSync(dataPath);\n    }\n    const userFile = path.join(dataPath, `${userId}.json`);\n    fs.writeFileSync(userFile, JSON.stringify(data, null, 2));\n}\n\n// Helper: Get all players data\nfunction getAllPlayers() {\n    const playersFile = path.join(__dirname, 'players.json');\n    if (fs.existsSync(playersFile)) {\n        return JSON.parse(fs.readFileSync(playersFile, 'utf8'));\n    }\n    return [];\n}\n\n// Middleware: Check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n    if (req.isAuthenticated()) {\n        return next();\n    }\n    res.redirect('/login');\n}\n\n// Start Discord bot\nfunction startBot() {\n    console.log('üöÄ Starting Discord bot...');\n    \n    botProcess = spawn('node', ['index.js'], {\n        cwd: __dirname,\n        stdio: 'inherit'\n    });\n\n    botStatus.isRunning = true;\n    botStatus.startTime = new Date();\n\n    botProcess.on('error', (error) => {\n        console.error('‚ùå Bot process error:', error);\n        botStatus.lastError = error.message;\n        botStatus.isRunning = false;\n    });\n\n    botProcess.on('exit', (code, signal) => {\n        console.log(`‚ö†Ô∏è Bot process exited with code ${code}`);\n        botStatus.isRunning = false;\n        \n        if (code !== 0) {\n            botStatus.restarts++;\n            console.log(`üîÑ Restarting bot... (Restart #${botStatus.restarts})`);\n            setTimeout(startBot, 5000);\n        }\n    });\n}\n\n// Routes\napp.get('/', (req, res) => {\n    if (req.isAuthenticated()) {\n        return res.redirect('/dashboard');\n    }\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.get('/login', (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'login.html'));\n});\n\n// Discord OAuth2 routes\napp.get('/auth/discord', passport.authenticate('discord'));\n\napp.get('/auth/discord/callback', \n    passport.authenticate('discord', { failureRedirect: '/login' }),\n    (req, res) => {\n        res.redirect('/dashboard');\n    }\n);\n\napp.get('/logout', (req, res) => {\n    req.logout((err) => {\n        if (err) console.error(err);\n        res.redirect('/');\n    });\n});\n\n// Dashboard route\napp.get('/dashboard', isAuthenticated, (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));\n});\n\n// Contracts route\napp.get('/contracts', isAuthenticated, (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'contracts.html'));\n});\n\n// My Team route\napp.get('/my-team', isAuthenticated, (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'my-team.html'));\n});\n\n// Mail route\napp.get('/mail', isAuthenticated, (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'mail.html'));\n});\n\n// News route\napp.get('/news', isAuthenticated, (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'news.html'));\n});\n\n// API Routes\napp.get('/api/user', isAuthenticated, (req, res) => {\n    const userData = getUserData(req.user.id);\n    res.json({\n        discord: req.user,\n        gameData: userData\n    });\n});\n\napp.get('/api/players', isAuthenticated, (req, res) => {\n    const userData = getUserData(req.user.id);\n    if (!userData || !userData.players) {\n        return res.json({ players: [] });\n    }\n    res.json({ players: userData.players });\n});\n\napp.get('/api/squad', isAuthenticated, (req, res) => {\n    const userData = getUserData(req.user.id);\n    if (!userData) {\n        return res.json({ squad: { main: [], bench: [] }, formation: '4-3-3' });\n    }\n    res.json({\n        squad: userData.squad || { main: [], bench: [] },\n        formation: userData.formation || '4-3-3'\n    });\n});\n\napp.post('/api/squad/update', isAuthenticated, (req, res) => {\n    try {\n        const userData = getUserData(req.user.id);\n        if (!userData) {\n            return res.status(404).json({ error: 'User data not found' });\n        }\n\n        const { squad, formation } = req.body;\n        \n        if (squad) {\n            userData.squad = squad;\n        }\n        if (formation) {\n            userData.formation = formation;\n        }\n\n        setUserData(req.user.id, userData);\n        res.json({ success: true, message: 'Squad updated successfully!' });\n    } catch (error) {\n        console.error('Error updating squad:', error);\n        res.status(500).json({ error: 'Failed to update squad' });\n    }\n});\n\napp.get('/api/all-players', isAuthenticated, (req, res) => {\n    const allPlayers = getAllPlayers();\n    res.json({ players: allPlayers });\n});\n\n// Packs API endpoint\napp.get('/api/packs', isAuthenticated, (req, res) => {\n    const PACKS = {\n        'iconic': {\n            name: 'Iconic Moment Pack',\n            cost: 500,\n            currency: 'eCoins',\n            description: 'A special pack containing players of all rarities, with a chance to get an Iconic Moment player!',\n            rarity_chances: {\n                'Iconic': 0.01,\n                'Legend': 0.03,\n                'Black': 0.10,\n                'Gold': 0.20,\n                'Silver': 0.30,\n                'Bronze': 0.26,\n                'White': 0.10\n            }\n        },\n        'legend': {\n            name: 'Legend Box Draw',\n            cost: 25000,\n            currency: 'GP',\n            description: 'A box draw with a chance to get a Legend player!',\n            rarity_chances: {\n                'Legend': 0.05,\n                'Black': 0.15,\n                'Gold': 0.25,\n                'Silver': 0.35,\n                'Bronze': 0.20,\n                'White': 0.00\n            }\n        },\n        'standard': {\n            name: 'Standard Pack',\n            cost: 10000,\n            currency: 'GP',\n            description: 'A standard pack containing players from Black to White rarity.',\n            rarity_chances: {\n                'Black': 0.05,\n                'Gold': 0.20,\n                'Silver': 0.40,\n                'Bronze': 0.25,\n                'White': 0.10\n            }\n        }\n    };\n    res.json({ packs: PACKS });\n});\n\n// Mail API endpoints\napp.get('/api/mail', isAuthenticated, (req, res) => {\n    const userData = getUserData(req.user.id);\n    if (!userData) {\n        return res.json({ mail: [] });\n    }\n    res.json({ mail: userData.mail || [] });\n});\n\napp.post('/api/mail/claim', isAuthenticated, (req, res) => {\n    const { mailId } = req.body;\n    const userData = getUserData(req.user.id);\n    \n    console.log('Claim request for mail ID:', mailId);\n    console.log('User has mail:', userData?.mail?.length || 0);\n    \n    if (!userData || !userData.mail) {\n        return res.json({ success: false, message: 'No mail found' });\n    }\n    \n    // Find mail with flexible ID comparison (string or number)\n    const mail = userData.mail.find(m => m.id == mailId || m.id === mailId);\n    if (!mail) {\n        console.log('Mail not found. Available IDs:', userData.mail.map(m => m.id));\n        return res.json({ success: false, message: 'Mail not found' });\n    }\n    \n    if (mail.claimed) {\n        return res.json({ success: false, message: 'Already claimed' });\n    }\n    \n    console.log('Claiming mail:', mail.title || mail.type);\n    \n    // Mark as claimed\n    mail.claimed = true;\n    \n    // Handle new format (rewards object)\n    if (mail.rewards) {\n        if (mail.rewards.gp) {\n            userData.gp = (userData.gp || 0) + mail.rewards.gp;\n        }\n        if (mail.rewards.eCoins) {\n            userData.eCoins = (userData.eCoins || 0) + mail.rewards.eCoins;\n        }\n        if (mail.rewards.players && mail.rewards.players.length > 0) {\n            userData.players = userData.players || [];\n            userData.players.push(...mail.rewards.players);\n        }\n        if (mail.rewards.packs && mail.rewards.packs.length > 0) {\n            userData.inventory = userData.inventory || {};\n            mail.rewards.packs.forEach(pack => {\n                const packKey = `${pack}Pack`;\n                userData.inventory[packKey] = (userData.inventory[packKey] || 0) + 1;\n            });\n        }\n    }\n    // Handle old format (type, amount, rarity fields)\n    else if (mail.type) {\n        if (mail.type === 'gp' && mail.amount) {\n            userData.gp = (userData.gp || 0) + mail.amount;\n        }\n        else if (mail.type === 'eCoins' && mail.amount) {\n            userData.eCoins = (userData.eCoins || 0) + mail.amount;\n        }\n        else if (mail.type === 'pack' && mail.rarity) {\n            userData.inventory = userData.inventory || {};\n            const packKey = `${mail.rarity}Pack`;\n            userData.inventory[packKey] = (userData.inventory[packKey] || 0) + 1;\n        }\n        else if (mail.type === 'trainer' && mail.trainerName) {\n            // Add trainer to inventory or handle as needed\n            userData.inventory = userData.inventory || {};\n            userData.inventory.trainers = userData.inventory.trainers || [];\n            userData.inventory.trainers.push(mail.trainerName);\n        }\n    }\n    \n    setUserData(req.user.id, userData);\n    \n    res.json({\n        success: true,\n        rewards: mail.rewards,\n        newBalance: {\n            gp: userData.gp,\n            eCoins: userData.eCoins\n        }\n    });\n});\n\napp.post('/api/mail/claim-all', isAuthenticated, (req, res) => {\n    const userData = getUserData(req.user.id);\n    \n    if (!userData || !userData.mail) {\n        return res.json({ success: false, message: 'No mail found' });\n    }\n    \n    let claimedCount = 0;\n    const totalRewards = {\n        gp: 0,\n        eCoins: 0,\n        players: 0,\n        packs: 0\n    };\n    \n    userData.mail.forEach(mail => {\n        if (!mail.claimed) {\n            mail.claimed = true;\n            claimedCount++;\n            \n            // Handle new format (rewards object)\n            if (mail.rewards) {\n                if (mail.rewards.gp) {\n                    userData.gp = (userData.gp || 0) + mail.rewards.gp;\n                    totalRewards.gp += mail.rewards.gp;\n                }\n                if (mail.rewards.eCoins) {\n                    userData.eCoins = (userData.eCoins || 0) + mail.rewards.eCoins;\n                    totalRewards.eCoins += mail.rewards.eCoins;\n                }\n                if (mail.rewards.players && mail.rewards.players.length > 0) {\n                    userData.players = userData.players || [];\n                    userData.players.push(...mail.rewards.players);\n                    totalRewards.players += mail.rewards.players.length;\n                }\n                if (mail.rewards.packs && mail.rewards.packs.length > 0) {\n                    userData.inventory = userData.inventory || {};\n                    mail.rewards.packs.forEach(pack => {\n                        const packKey = `${pack}Pack`;\n                        userData.inventory[packKey] = (userData.inventory[packKey] || 0) + 1;\n                    });\n                    totalRewards.packs += mail.rewards.packs.length;\n                }\n            }\n            // Handle old format (type, amount, rarity fields)\n            else if (mail.type) {\n                if (mail.type === 'gp' && mail.amount) {\n                    userData.gp = (userData.gp || 0) + mail.amount;\n                    totalRewards.gp += mail.amount;\n                }\n                else if (mail.type === 'eCoins' && mail.amount) {\n                    userData.eCoins = (userData.eCoins || 0) + mail.amount;\n                    totalRewards.eCoins += mail.amount;\n                }\n                else if (mail.type === 'pack' && mail.rarity) {\n                    userData.inventory = userData.inventory || {};\n                    const packKey = `${mail.rarity}Pack`;\n                    userData.inventory[packKey] = (userData.inventory[packKey] || 0) + 1;\n                    totalRewards.packs += 1;\n                }\n                else if (mail.type === 'trainer' && mail.trainerName) {\n                    userData.inventory = userData.inventory || {};\n                    userData.inventory.trainers = userData.inventory.trainers || [];\n                    userData.inventory.trainers.push(mail.trainerName);\n                }\n            }\n        }\n    });\n    \n    setUserData(req.user.id, userData);\n    \n    res.json({\n        success: true,\n        claimedCount,\n        totalRewards,\n        newBalance: {\n            gp: userData.gp,\n            eCoins: userData.eCoins\n        }\n    });\n});\n\n// News API endpoint\napp.get('/api/news', (req, res) => {\n    const newsFile = path.join(__dirname, 'news.json');\n    if (fs.existsSync(newsFile)) {\n        const newsData = JSON.parse(fs.readFileSync(newsFile, 'utf8'));\n        res.json({ news: newsData });\n    } else {\n        res.json({ news: [] });\n    }\n});\n\n// Bot status API\napp.get('/api/status', (req, res) => {\n    const uptime = botStatus.startTime \n        ? formatUptime(Date.now() - botStatus.startTime.getTime())\n        : 'Not started';\n    \n    res.json({\n        isRunning: botStatus.isRunning,\n        uptime: uptime,\n        restarts: botStatus.restarts,\n        lastError: botStatus.lastError,\n        serverTime: new Date().toISOString()\n    });\n});\n\napp.get('/health', (req, res) => {\n    res.status(200).json({ status: 'ok', bot: botStatus.isRunning });\n});\n\napp.get('/ping', (req, res) => {\n    res.send('pong');\n});\n\nfunction formatUptime(ms) {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) return `${days}d ${hours % 24}h`;\n    if (hours > 0) return `${hours}h ${minutes % 60}m`;\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n    return `${seconds}s`;\n}\n\n// Start server\napp.listen(PORT, () => {\n    console.log(`üåê Web server running on port ${PORT}`);\n    console.log(`üìä Dashboard: http://localhost:${PORT}`);\n    console.log(`üîê Login URL: http://localhost:${PORT}/auth/discord`);\n    \n    // Start the Discord bot\n    startBot();\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n    console.log('\\nüõë Shutting down gracefully...');\n    if (botProcess) {\n        botProcess.kill();\n    }\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    console.log('\\nüõë Shutting down gracefully...');\n    if (botProcess) {\n        botProcess.kill();\n    }\n    process.exit(0);\n});\n","size_bytes":16403},"commands/collection.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nconst RARITIES = ['Iconic', 'Legend', 'Black', 'Gold', 'Silver', 'Bronze', 'White'];\n\n// In-memory pagination state (token -> state)\nconst STATE = new Map();\nfunction token() { return Math.random().toString(36).slice(2, 10); }\n\nfunction getPositions() {\n  return ['GK','CB','LB','RB','DMF','CMF','AMF','LMF','RMF','LWF','RWF','SS','CF'];\n}\n\nfunction applyFiltersAndSort(allPlayers, { rarity, sort, position, playingStyle, club }) {\n  let players = Array.isArray(allPlayers) ? [...allPlayers] : [];\n  if (rarity) players = players.filter(p => p.rarity === rarity);\n  if (position) players = players.filter(p => p.position === position);\n  if (playingStyle) players = players.filter(p => (p.playingStyle || '').toLowerCase().includes(playingStyle.toLowerCase()));\n  if (club) players = players.filter(p => (p.club || '').toLowerCase().includes(club.toLowerCase()));\n\n  switch (sort) {\n    case 'ovr_asc': players.sort((a,b)=>(a.overall??0)-(b.overall??0)); break;\n    case 'name_asc': players.sort((a,b)=>(a.name||'').localeCompare(b.name||'')); break;\n    case 'name_desc': players.sort((a,b)=>(b.name||'').localeCompare(a.name||'')); break;\n    case 'ovr_desc': default: players.sort((a,b)=>(b.overall??0)-(a.overall??0)); break;\n  }\n  return players;\n}\n\nfunction pageEmbed(user, filteredPlayers, opts) {\n  const pageSize = 20;\n  const total = filteredPlayers.length;\n  const totalPages = Math.max(1, Math.ceil(total / pageSize));\n  const currentPage = Math.min(Math.max(1, opts.page || 1), totalPages);\n  const start = (currentPage - 1) * pageSize;\n  const slice = filteredPlayers.slice(start, start + pageSize);\n  const lines = slice.map(p => `‚Ä¢ ${p.name} ‚Äî ${p.position} ‚Äî ${p.rarity} ‚Äî OVR ${p.overall}`);\n  const desc = lines.length ? lines.join('\\n') : 'No players match your filter.';\n  const titleParts = [`${user.username}'s Collection`];\n  if (opts.rarity) titleParts.push(`(${opts.rarity})`);\n\n  const embed = new EmbedBuilder()\n    .setTitle(titleParts.join(' '))\n    .setColor('#00bcd4')\n    .setFooter({ text: `Page ${currentPage}/${totalPages} ‚Ä¢ Total: ${total}` })\n    .setDescription(desc);\n\n  return { embed, totalPages, currentPage };\n}\n\nfunction buildButtons(tok, page, totalPages) {\n  const prevId = `collection:${tok}:prev`;\n  const nextId = `collection:${tok}:next`;\n  const row = new ActionRowBuilder().addComponents(\n    new ButtonBuilder().setCustomId(prevId).setStyle(ButtonStyle.Secondary).setLabel('Prev').setDisabled(page <= 1),\n    new ButtonBuilder().setCustomId(nextId).setStyle(ButtonStyle.Secondary).setLabel('Next').setDisabled(page >= totalPages)\n  );\n  return [row];\n}\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('collection')\n    .setDescription('View your owned players, with optional filters and pagination')\n    .addStringOption(option =>\n      option.setName('rarity')\n        .setDescription('Filter by rarity')\n        .addChoices(\n          { name: 'Iconic', value: 'Iconic' },\n          { name: 'Legend', value: 'Legend' },\n          { name: 'Black', value: 'Black' },\n          { name: 'Gold', value: 'Gold' },\n          { name: 'Silver', value: 'Silver' },\n          { name: 'Bronze', value: 'Bronze' },\n          { name: 'White', value: 'White' },\n        ))\n    .addStringOption(option =>\n      option.setName('position')\n        .setDescription('Filter by position')\n        .addChoices(...getPositions().map(p => ({ name: p, value: p })))\n    )\n    .addStringOption(option =>\n      option.setName('playingstyle')\n        .setDescription('Filter by playing style (contains)')\n    )\n    .addStringOption(option =>\n      option.setName('club')\n        .setDescription('Filter by club (contains)')\n    )\n    .addStringOption(option =>\n      option.setName('sort')\n        .setDescription('Sort order')\n        .addChoices(\n          { name: 'Overall (High ‚Üí Low)', value: 'ovr_desc' },\n          { name: 'Overall (Low ‚Üí High)', value: 'ovr_asc' },\n          { name: 'Name (A ‚Üí Z)', value: 'name_asc' },\n          { name: 'Name (Z ‚Üí A)', value: 'name_desc' },\n        ))\n    .addIntegerOption(option =>\n      option.setName('page')\n        .setDescription('Page number')\n        .setMinValue(1)\n    ),\n\n  async execute(interaction) {\n    try {\n    const { client } = interaction;\n    const userData = client.getUserData(interaction.user.id);\n\n    const rarity = interaction.options.getString('rarity');\n    const position = interaction.options.getString('position');\n    const playingStyle = interaction.options.getString('playingstyle');\n    const club = interaction.options.getString('club');\n    const sort = interaction.options.getString('sort') || 'ovr_desc';\n    const page = interaction.options.getInteger('page') || 1;\n\n    const filtered = applyFiltersAndSort(userData.players, { rarity, sort, position, playingStyle, club });\n    const { embed, totalPages, currentPage } = pageEmbed(interaction.user, filtered, { rarity, page });\n\n    const tok = token();\n    STATE.set(tok, { u: interaction.user.id, r: rarity || '', s: sort, p: position || '', ps: playingStyle || '', c: club || '', pg: currentPage, totalPages });\n    const components = buildButtons(tok, currentPage, totalPages);\n\n    await interaction.reply({ embeds: [embed], components });\n    } catch (err) {\n      console.error('collection execute error:', err);\n      try { await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true }); } catch {}\n    }\n  }\n,\n  // Button handler for pagination\n  async handleButton(interaction) {\n    try {\n      if (!interaction.customId.startsWith('collection:')) return;\n      const parts = interaction.customId.split(':'); // [collection, token, action]\n      const tok = parts[1];\n      const action = parts[2];\n      const state = STATE.get(tok);\n      if (!state) return;\n      if (interaction.user.id !== state.u) {\n        return interaction.reply({ content: 'This pagination belongs to another user.', ephemeral: true });\n      }\n      state.pg = Math.max(1, Math.min(state.totalPages || 1, state.pg + (action === 'next' ? 1 : -1)));\n      const { client } = interaction;\n      const userData = client.getUserData(state.u);\n      const filtered = applyFiltersAndSort(userData.players, { rarity: state.r, sort: state.s, position: state.p, playingStyle: state.ps, club: state.c });\n      const pageData = pageEmbed(interaction.user, filtered, { rarity: state.r, page: state.pg });\n      state.totalPages = pageData.totalPages; // update if changed\n      const components = buildButtons(tok, pageData.currentPage, pageData.totalPages);\n      await interaction.update({ embeds: [pageData.embed], components });\n    } catch (err) {\n      console.error('collection button error:', err);\n      try { await interaction.reply({ content: 'There was an error updating the page.', ephemeral: true }); } catch {}\n    }\n  }\n};\n","size_bytes":6976},"commands/leaderboard.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction tryReadUser(filePath) {\n  try {\n    const raw = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(raw);\n  } catch (_) {\n    return null;\n  }\n}\n\nfunction computeStrength(user) {\n  // Prefer tracked strengths\n  const best = user?.stats?.bestStrength;\n  if (typeof best === 'number' && best > 0) return Math.round(best);\n  // Fallback: average of players' overall\n  const players = Array.isArray(user?.players) ? user.players : [];\n  if (!players.length) return 0;\n  const sum = players.reduce((a, p) => a + (p.overall || 0), 0);\n  return Math.round(sum / players.length);\n}\n\nasync function getServerUserIds(guild) {\n    try {\n      // Use cache instead of fetch to avoid timeout\n      const members = guild.members.cache;\n      return new Set(members.map(m => m.user.id));\n    } catch {\n      return new Set();\n    }\n  }\n\nfunction loadAllUsers(dataDir) {\n  const out = [];\n  const files = fs.existsSync(dataDir) ? fs.readdirSync(dataDir) : [];\n  for (const f of files) {\n    if (!f.endsWith('.json')) continue;\n    const u = tryReadUser(path.join(dataDir, f));\n    if (u && u.id) out.push(u);\n  }\n  return out;\n}\n\nfunction rankUsers(users, metric, guild = null) {\n    const arr = users.map(u => {\n      const gp = Number(u.gp || 0);\n      const wins = Number(u?.stats?.wins || 0);\n      const strength = computeStrength(u);\n      \n      // Try to get username from guild if available\n      let name = u.username || u.tag || u.id;\n      if (guild && guild.members.cache.has(u.id)) {\n        const member = guild.members.cache.get(u.id);\n        name = member.user.username || member.displayName || name;\n      }\n      \n      return { id: u.id, name, gp, wins, strength };\n    });\n    \n    switch (metric) {\n      case 'wins':\n        arr.sort((a, b) => b.wins - a.wins || b.gp - a.gp);\n        break;\n      case 'strength':\n        arr.sort((a, b) => b.strength - a.strength || b.gp - a.gp);\n        break;\n      case 'gp':\n      default:\n        arr.sort((a, b) => b.gp - a.gp || b.wins - a.wins);\n        break;\n    }\n    return arr;\n  }\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n    .setName('leaderboard')\n    .setDescription('Show leaderboards for GP, wins, or team strength')\n    .addStringOption(o => o\n      .setName('metric')\n      .setDescription('Ranking metric')\n      .setRequired(true)\n      .addChoices(\n        { name: 'GP', value: 'gp' },\n        { name: 'Wins', value: 'wins' },\n        { name: 'Strength', value: 'strength' },\n      ))\n    .addStringOption(o => o\n      .setName('scope')\n      .setDescription('Global or this server only')\n      .setRequired(true)\n      .addChoices(\n        { name: 'Global', value: 'global' },\n        { name: 'Server', value: 'server' },\n      )),\n\n  async execute(interaction) {\n    try {\n      const metric = interaction.options.getString('metric');\n      const scope = interaction.options.getString('scope');\n      const p = interaction.options.getInteger('page') || 1;\n      const { guild } = interaction;\n\n      const dataDir = path.join(__dirname, '..', 'data');\n      const users = loadAllUsers(dataDir);\n\n      let filtered = users;\n      if (scope === 'server' && guild) {\n        const serverIds = await getServerUserIds(guild);\n        filtered = users.filter(u => serverIds.has(u.id));\n      }\n\n      const ranked = rankUsers(filtered, metric, guild);\n      const pageSize = 10;\n      const totalPages = Math.max(1, Math.ceil(ranked.length / pageSize));\n      const validPage = Math.min(Math.max(1, p), totalPages);\n      const start = (validPage - 1) * pageSize;\n\n      const lines = ranked.slice(start, start + pageSize).map((r, i) => {\n        const pos = start + i + 1;\n        let val = '';\n        if (metric === 'gp') val = `${r.gp.toLocaleString()} GP`;\n        if (metric === 'wins') val = `${r.wins} wins`;\n        if (metric === 'strength') val = `${r.strength}`;\n        const name = r.name || r.id;\n        return `#${pos} ‚Äî **${name}** ‚Äî ${val}`;\n      });\n\n      const titleMetric = metric === 'gp' ? 'GP' : (metric === 'wins' ? 'Wins' : 'Strength');\n      const titleScope = scope === 'server' ? `Server: ${guild?.name || ''}` : 'Global';\n\n      const embed = new EmbedBuilder()\n        .setTitle(`üèÜ Leaderboard ‚Äî ${titleMetric} (${titleScope})`)\n        .setColor('#f39c12')\n        .setDescription(lines.length ? lines.join('\\n') : 'No data yet. Play some matches and earn GP!')\n        .setFooter({ text: `Page ${validPage}/${totalPages} ‚Ä¢ Use /leaderboard metric:<m> scope:<s> page:<n>` });\n\n      const row = new ActionRowBuilder().addComponents(\n        new ButtonBuilder()\n          .setCustomId(`leaderboard_${metric}_${scope}_${validPage - 1}`)\n          .setLabel('‚óÄÔ∏è Previous')\n          .setStyle(ButtonStyle.Secondary)\n          .setDisabled(validPage <= 1),\n        new ButtonBuilder()\n          .setCustomId(`leaderboard_${metric}_${scope}_${validPage + 1}`)\n          .setLabel('Next ‚ñ∂Ô∏è')\n          .setStyle(ButtonStyle.Secondary)\n          .setDisabled(validPage >= totalPages)\n      );\n\n      await interaction.reply({ embeds: [embed], components: totalPages > 1 ? [row] : [] });\n    } catch (error) {\n      console.error('Leaderboard execute error:', error);\n      try { await interaction.reply({ content: '‚ùå Error loading leaderboard. Please try again!', ephemeral: true }); } catch {}\n    }\n  },\n\n  async handleButton(interaction) {\n    try {\n      if (!interaction.customId || !interaction.customId.startsWith('leaderboard_')) return;\n      const [action, metric, scope, page] = interaction.customId.split('_');\n      if (action !== 'leaderboard') return;\n\n      const p = parseInt(page, 10) || 1;\n      const { guild } = interaction;\n\n      const dataDir = path.join(__dirname, '..', 'data');\n      const users = loadAllUsers(dataDir);\n\n      let filtered = users;\n      if (scope === 'server' && guild) {\n        const serverIds = await getServerUserIds(guild);\n        filtered = users.filter(u => serverIds.has(u.id));\n      }\n\n      const ranked = rankUsers(filtered, metric);\n      const pageSize = 10;\n      const totalPages = Math.max(1, Math.ceil(ranked.length / pageSize));\n      const validPage = Math.min(Math.max(1, p), totalPages);\n      const start = (validPage - 1) * pageSize;\n\n      const lines = ranked.slice(start, start + pageSize).map((r, i) => {\n        const pos = start + i + 1;\n        let val = '';\n        if (metric === 'gp') val = `${r.gp.toLocaleString()} GP`;\n        if (metric === 'wins') val = `${r.wins} wins`;\n        if (metric === 'strength') val = `${r.strength}`;\n        const name = r.name || r.id;\n        return `#${pos} ‚Äî **${name}** ‚Äî ${val}`;\n      });\n\n      const titleMetric = metric === 'gp' ? 'GP' : (metric === 'wins' ? 'Wins' : 'Strength');\n      const titleScope = scope === 'server' ? `Server: ${guild?.name || ''}` : 'Global';\n\n      const embed = new EmbedBuilder()\n        .setTitle(`üèÜ Leaderboard ‚Äî ${titleMetric} (${titleScope})`)\n        .setColor('#f39c12')\n        .setDescription(lines.length ? lines.join('\\n') : 'No data yet. Play some matches and earn GP!')\n        .setFooter({ text: `Page ${validPage}/${totalPages} ‚Ä¢ Use /leaderboard metric:<m> scope:<s>` });\n\n      const row = new ActionRowBuilder().addComponents(\n        new ButtonBuilder()\n          .setCustomId(`leaderboard_${metric}_${scope}_${validPage - 1}`)\n          .setLabel('‚óÄÔ∏è Previous')\n          .setStyle(ButtonStyle.Secondary)\n          .setDisabled(validPage <= 1),\n        new ButtonBuilder()\n          .setCustomId(`leaderboard_${metric}_${scope}_${validPage + 1}`)\n          .setLabel('Next ‚ñ∂Ô∏è')\n          .setStyle(ButtonStyle.Secondary)\n          .setDisabled(validPage >= totalPages)\n      );\n\n      await interaction.update({ embeds: [embed], components: totalPages > 1 ? [row] : [] });\n    } catch (error) {\n      console.error('Leaderboard button error:', error);\n      try { await interaction.reply({ content: '‚ùå Error updating leaderboard. Please try again!', ephemeral: true }); } catch {}\n    }\n  }\n};","size_bytes":8204},"QUICK_START_NEWS.md":{"content":"# Quick Start: News System\n\n## Setup\n\n1. **Deploy the new commands:**\n   ```bash\n   node deploy-commands.js\n   ```\n\n2. **Set admin permissions (optional):**\n   Add your Discord User ID to `.env`:\n   ```\n   ADMIN_IDS=YOUR_DISCORD_USER_ID\n   ```\n\n## Usage Examples\n\n### Creating Your First News Article\n\n```\n/managenews add type:announcement title:Welcome to eFOOTBALL WANNABE! content:Thank you for playing! Check out the new web dashboard at your server's URL.\n```\n\n### Creating Different Types of News\n\n**Game Update:**\n```\n/managenews add type:update title:Version 1.2 Released content:New features: Squad Builder, My Team page, and special Iconic/Legend card backgrounds!\n```\n\n**Special Event:**\n```\n/managenews add type:event title:Weekend GP Bonus content:Earn 2x GP from all matches this weekend! Event runs from Friday to Sunday.\n```\n\n**Maintenance Notice:**\n```\n/managenews add type:maintenance title:Scheduled Maintenance content:Server will be down for maintenance on Sunday 2AM-4AM UTC. Please save your progress.\n```\n\n**New Feature:**\n```\n/managenews add type:feature title:Contracts Page Added content:View all available players in each pack! Check the new Contracts page on the web dashboard.\n```\n\n**Bug Fix:**\n```\n/managenews add type:bugfix title:Squad Builder Fixed content:Fixed an issue where Iconic and Legend players weren't showing their special backgrounds.\n```\n\n### Managing News\n\n**View all news with IDs:**\n```\n/managenews list\n```\n\n**Remove a specific news:**\n```\n/managenews remove id:3\n```\n\n**Clear all news (careful!):**\n```\n/managenews clear\n```\n\n### Players Viewing News\n\n**View latest news:**\n```\n/news\n```\n\n**View page 2:**\n```\n/news page:2\n```\n\n## Sample News Feed\n\nHere's what players will see when they use `/news`:\n\n```\nüì∞ eFOOTBALL WANNABE - Latest News\nStay updated with the latest game updates, events, and announcements!\n\n‚ú® Contracts Page Added\nView all available players in each pack! Check the new Contracts page on the web dashboard.\nOct 24, 2025, 05:38 PM ‚Ä¢ by Admin#1234\n\nüîÑ Version 1.2 Released\nNew features: Squad Builder, My Team page, and special Iconic/Legend card backgrounds!\nOct 24, 2025, 03:15 PM ‚Ä¢ by Admin#1234\n\nüéâ Weekend GP Bonus\nEarn 2x GP from all matches this weekend! Event runs from Friday to Sunday.\nOct 23, 2025, 10:00 AM ‚Ä¢ by Admin#1234\n\nüì¢ Welcome to eFOOTBALL WANNABE!\nThank you for playing! Check out the new web dashboard at your server's URL.\nOct 22, 2025, 09:00 PM ‚Ä¢ by Admin#1234\n\nPage 1/1 ‚Ä¢ Total News: 4\n```\n\n## Tips\n\n1. **Keep news current** - Remove old events and outdated information\n2. **Use clear titles** - Make it easy to understand at a glance\n3. **Be concise** - Players appreciate brief, informative updates\n4. **Use appropriate types** - Helps players quickly identify important news\n5. **Regular updates** - Keep your community engaged with frequent news\n\n## Troubleshooting\n\n**Command not showing up?**\n- Run `node deploy-commands.js` to register the commands\n- Wait a few minutes for Discord to update\n\n**Permission denied?**\n- Make sure you have Administrator permission in Discord\n- OR add your User ID to `ADMIN_IDS` in `.env`\n\n**News not saving?**\n- Check that the `data/` folder exists\n- The system will create `news.json` automatically on first use\n","size_bytes":3267},"render.yaml":{"content":"services:\n  - type: web\n    name: efotball-bot\n    env: node\n    plan: free\n    buildCommand: npm install\n    startCommand: npm start\n    envVars:\n      - key: DISCORD_TOKEN\n        sync: false\n    healthCheckPath: /health\n","size_bytes":223},"commands/contract-info.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst players = require('../players.json');\n\n// Pack definitions (kept in sync with commands/contract.js)\nconst PACKS = {\n  'iconic': {\n    name: 'Iconic Moment Pack',\n    cost: 500,\n    currency: 'eCoins',\n    description: 'A special pack containing players of all rarities, with a chance to get an Iconic Moment player!',\n    rarity_chances: {\n      'Iconic': 0.01,\n      'Legend': 0.03,\n      'Black': 0.10,\n      'Gold': 0.20,\n      'Silver': 0.30,\n      'Bronze': 0.26,\n      'White': 0.10,\n    }\n  },\n  'legend': {\n    name: 'Legend Box Draw',\n    cost: 25000,\n    currency: 'GP',\n    description: 'A box draw with a chance to get a Legend player!',\n    rarity_chances: {\n      'Legend': 0.05,\n      'Black': 0.15,\n      'Gold': 0.25,\n      'Silver': 0.35,\n      'Bronze': 0.20,\n      'White': 0.00,\n    }\n  },\n  'standard': {\n    name: 'Standard Pack',\n    cost: 10000,\n    currency: 'GP',\n    description: 'A standard pack containing players from Black to White rarity.',\n    rarity_chances: {\n      'Black': 0.05,\n      'Gold': 0.20,\n      'Silver': 0.40,\n      'Bronze': 0.25,\n      'White': 0.10,\n    }\n  }\n};\n\nconst RARITY_EMOJIS = {\n  'Iconic': 'üíé',\n  'Legend': 'üåü',\n  'Black': '‚ö´',\n  'Gold': 'üü°',\n  'Silver': '‚ö™',\n  'Bronze': 'üü§',\n  'White': '‚¨ú',\n};\n\nfunction topPlayersForPack(packKey) {\n  const pack = PACKS[packKey];\n  if (!pack) return [];\n  const allowedRarities = Object.entries(pack.rarity_chances)\n    .filter(([, chance]) => Number(chance) > 0)\n    .map(([rarity]) => rarity);\n\n  const pool = players.filter(p => allowedRarities.includes(p.rarity));\n  // Sort by level 1 overall (base overall rating)\n  const sorted = pool\n    .map(p => ({\n      id: p.id,\n      name: p.name,\n      rarity: p.rarity,\n      position: p.position,\n      overall: p.overall, // Level 1 overall\n      maxOverall: typeof p.maxOverall === 'number' ? p.maxOverall : p.overall,\n    }))\n    .sort((a, b) => b.overall - a.overall)\n    .slice(0, 10);\n\n  return sorted;\n}\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('contract-info')\n    .setDescription('Show info about contract packs')\n    .addStringOption(option =>\n      option.setName('pack')\n        .setDescription('Specific pack to show info for')\n        .setRequired(false)\n        .addChoices(\n          { name: 'Iconic Moment Pack', value: 'iconic' },\n          { name: 'Legend Box Draw', value: 'legend' },\n          { name: 'Standard Pack', value: 'standard' }\n        )\n    ),\n\n  async execute(interaction) {\n    try {\n      const packChoice = interaction.options.getString('pack');\n      const embeds = [];\n\n      if (packChoice) {\n        // Show info for specific pack only\n        const pack = PACKS[packChoice];\n        if (!pack) {\n          return await interaction.reply({ content: 'Invalid pack selection.', ephemeral: true });\n        }\n\n        const top = topPlayersForPack(packChoice);\n        const chances = Object.entries(pack.rarity_chances)\n          .filter(([, v]) => v > 0)\n          .sort((a, b) => b[1] - a[1])\n          .map(([rarity, chance]) => `${RARITY_EMOJIS[rarity] || ''} ${rarity}: ${(chance * 100).toFixed(1)}%`)\n          .join('\\n');\n\n        const topLines = top.map((p, i) => {\n          const emoji = RARITY_EMOJIS[p.rarity] || '';\n          return `#${i + 1} ${emoji} **${p.name}** ‚Äî ${p.position} ‚Äî ${p.overall} OVR`;\n        });\n\n        const embed = new EmbedBuilder()\n          .setTitle(`${pack.name}`)\n          .setColor('#8e44ad')\n          .setDescription(pack.description)\n          .addFields(\n            { name: 'Cost', value: `${pack.cost.toLocaleString()} ${pack.currency}`, inline: true },\n            { name: 'Rarity Chances', value: chances || '‚Äî', inline: true },\n          );\n\n        embed.addFields({ name: 'Top 10 Players', value: topLines.join('\\n') || 'No players found.' });\n\n        embeds.push(embed);\n      } else {\n        // Show info for all packs (original behavior)\n        for (const [key, pack] of Object.entries(PACKS)) {\n          const top = topPlayersForPack(key);\n          const chances = Object.entries(pack.rarity_chances)\n            .filter(([, v]) => v > 0)\n            .sort((a, b) => b[1] - a[1])\n            .map(([rarity, chance]) => `${RARITY_EMOJIS[rarity] || ''} ${rarity}: ${(chance * 100).toFixed(1)}%`)\n            .join('\\n');\n\n          const topLines = top.map((p, i) => {\n            const emoji = RARITY_EMOJIS[p.rarity] || '';\n            return `#${i + 1} ${emoji} **${p.name}** ‚Äî ${p.position} ‚Äî ${p.overall} OVR`;\n          });\n\n          const embed = new EmbedBuilder()\n            .setTitle(`${pack.name}`)\n            .setColor('#8e44ad')\n            .setDescription(pack.description)\n            .addFields(\n              { name: 'Cost', value: `${pack.cost.toLocaleString()} ${pack.currency}`, inline: true },\n              { name: 'Rarity Chances', value: chances || '‚Äî', inline: true },\n            );\n\n          embed.addFields({ name: 'Top 10 Players', value: topLines.join('\\n') || 'No players found.' });\n\n          embeds.push(embed);\n        }\n      }\n      \n      // Send pack embed(s) in a single reply\n      await interaction.reply({ embeds });\n    } catch (err) {\n      console.error('contract-info error:', err);\n      try { await interaction.reply({ content: 'There was an error while generating the contract info.', ephemeral: true }); } catch {}\n    }\n  }\n};\n","size_bytes":5466},"deploy-commands.js":{"content":"require('dotenv').config();\nconst { REST, Routes } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst commands = [];\n\n// Auto-load all commands from commands/ directory\nconst commandsDir = path.join(__dirname, 'commands');\nconst files = fs.readdirSync(commandsDir).filter(f => f.endsWith('.js'));\nfor (const file of files) {\n  try {\n    const cmd = require(path.join(commandsDir, file));\n    if (cmd && cmd.data && typeof cmd.data.name === 'string' && typeof cmd.data.toJSON === 'function') {\n      commands.push(cmd.data.toJSON());\n    }\n  } catch (e) {\n    console.error('Failed to load command from', file, e?.message || e);\n  }\n}\n\n// Deploy commands\nconst rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);\n\n(async () => {\n    try {\n        console.log(`Started refreshing ${commands.length} application (/) commands.`);\n\n        // Get application ID from the bot token\n        const clientId = Buffer.from(process.env.DISCORD_TOKEN.split('.')[0], 'base64').toString();\n\n        // Deploy commands globally\n        const data = await rest.put(\n            Routes.applicationCommands(clientId),\n            { body: commands },\n        );\n\n        console.log(`Successfully reloaded ${data.length} application (/) commands.`);\n    } catch (error) {\n        console.error(error);\n    }\n})();\n","size_bytes":1352},"commands/reset.js":{"content":"const { SlashCommandBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('reset')\n        .setDescription('Reset all your data (cannot be undone)'),\n    async execute(interaction) {\n        const { client } = interaction;\n\n        const confirmButton = new ButtonBuilder()\n            .setCustomId('confirm_reset')\n            .setLabel('Yes, reset my data')\n            .setStyle(ButtonStyle.Danger);\n\n        const cancelButton = new ButtonBuilder()\n            .setCustomId('cancel_reset')\n            .setLabel('Cancel')\n            .setStyle(ButtonStyle.Secondary);\n\n        const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);\n\n        const warningMessage = await interaction.reply({\n            content: '‚ö†Ô∏è Are you sure you want to reset all your data? This action cannot be undone.',\n            components: [row],\n        });\n\n        const filter = (buttonInteraction) => buttonInteraction.user.id === interaction.user.id;\n        const collector = warningMessage.createMessageComponentCollector({ filter, time: 15000 });\n\n        collector.on('collect', async (buttonInteraction) => {\n            if (buttonInteraction.customId === 'confirm_reset') {\n                // Create a new user profile, effectively resetting the data\n                const newUser = {\n                    id: interaction.user.id,\n                    gp: 10000,\n                    eCoins: 100,\n                    players: [],\n                    squad: { main: [], bench: [] },\n                };\n                client.setUserData(interaction.user.id, newUser);\n\n                await buttonInteraction.update({ content: 'Your data has been reset.', components: [] });\n            } else if (buttonInteraction.customId === 'cancel_reset') {\n                await buttonInteraction.update({ content: 'Data reset has been cancelled.', components: [] });\n            }\n        });\n\n        collector.on('end', (collected) => {\n            if (collected.size === 0) {\n                interaction.editReply({ content: 'Reset confirmation timed out.', components: [] });\n            }\n        });\n    },\n};\n","size_bytes":2224},"public/dashboard.js":{"content":"// Global state\nlet userData = null;\nlet allPlayers = [];\nlet currentSquad = { main: [], bench: [] };\nlet currentFormation = '4-3-3';\nlet availablePlayersList = [];\nlet autoScrollInterval = null;\n\nconst FORMATIONS = {\n    '4-3-3': ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', 'LWF', 'CF', 'RWF'],\n    '4-4-2': ['GK', 'LB', 'CB', 'CB', 'RB', 'LMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n    '3-5-2': ['GK', 'CB', 'CB', 'CB', 'LMF', 'CMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n    '4-2-3-1': ['GK', 'LB', 'CB', 'CB', 'RB', 'DMF', 'DMF', 'AMF', 'AMF', 'AMF', 'CF']\n};\n\nconst RARITY_EMOJIS = {\n    'Iconic': 'üíé',\n    'Legend': 'üåü',\n    'Black': '‚ö´',\n    'Gold': 'üü°',\n    'Silver': '‚ö™',\n    'Bronze': 'üü§',\n    'White': '‚¨ú'\n};\n\n// Initialize dashboard\nasync function init() {\n    await loadUserData();\n    await loadPlayers();\n    await loadSquad(); // This now handles rendering internally\n    renderAllPlayers();\n}\n\n// Load user data\nasync function loadUserData() {\n    try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        userData = data;\n        \n        // Update UI\n        document.getElementById('username').textContent = data.discord.username;\n        document.getElementById('userAvatar').src = `https://cdn.discordapp.com/avatars/${data.discord.id}/${data.discord.avatar}.png`;\n        \n        if (data.gameData) {\n            document.getElementById('gpAmount').textContent = (data.gameData.gp || 0).toLocaleString();\n            document.getElementById('eCoinsAmount').textContent = data.gameData.eCoins || 0;\n            document.getElementById('playerCount').textContent = (data.gameData.players || []).length;\n            \n            // Update top bar currency\n            document.getElementById('topGP').textContent = (data.gameData.gp || 0).toLocaleString();\n            document.getElementById('topEcoins').textContent = data.gameData.eCoins || 0;\n        }\n    } catch (error) {\n        console.error('Error loading user data:', error);\n    }\n}\n\n// Load players\nasync function loadPlayers() {\n    try {\n        const response = await fetch('/api/players');\n        const data = await response.json();\n        allPlayers = data.players || [];\n        availablePlayersList = [...allPlayers];\n    } catch (error) {\n        console.error('Error loading players:', error);\n    }\n}\n\n// Load squad\nasync function loadSquad() {\n    try {\n        const response = await fetch('/api/squad');\n        const data = await response.json();\n        currentSquad = data.squad || { main: [], bench: [] };\n        \n        currentFormation = data.formation || '4-3-3';\n        document.getElementById('formationSelect').value = currentFormation;\n        \n        // CRITICAL: Remove duplicates from loaded squad\n        const hadDuplicates = cleanupDuplicates();\n        \n        // If duplicates were found and removed, auto-save the cleaned squad\n        if (hadDuplicates) {\n            console.log('Duplicates detected and removed. Auto-saving cleaned squad...');\n            await saveSquad(true); // Silent save\n        }\n        \n        // FORCE RE-RENDER after cleanup\n        renderSquadPitch();\n        renderAvailablePlayers();\n        calculateTeamRating();\n    } catch (error) {\n        console.error('Error loading squad:', error);\n    }\n}\n\n// Clean up duplicate players in squad\nfunction cleanupDuplicates() {\n    const seenIds = new Set();\n    const cleanMain = [];\n    let foundDuplicates = false;\n    \n    // Clean main squad - keep first occurrence, remove duplicates\n    for (let i = 0; i < currentSquad.main.length; i++) {\n        const playerId = currentSquad.main[i];\n        \n        if (playerId === null || playerId === undefined) {\n            cleanMain.push(null);\n        } else if (!seenIds.has(playerId)) {\n            seenIds.add(playerId);\n            cleanMain.push(playerId);\n        } else {\n            // Duplicate found - replace with null\n            console.warn(`Duplicate player ${playerId} found at position ${i}, removing...`);\n            cleanMain.push(null);\n            foundDuplicates = true;\n        }\n    }\n    \n    // Clean bench - remove duplicates and players already in main squad\n    const cleanBench = [];\n    for (const playerId of currentSquad.bench) {\n        if (playerId !== null && playerId !== undefined && !seenIds.has(playerId)) {\n            seenIds.add(playerId);\n            cleanBench.push(playerId);\n        } else if (playerId !== null && playerId !== undefined) {\n            console.warn(`Duplicate player ${playerId} found in bench, removing...`);\n            foundDuplicates = true;\n        }\n    }\n    \n    // Update squad with cleaned data\n    currentSquad.main = cleanMain;\n    currentSquad.bench = cleanBench.slice(0, 8); // Enforce 8 player limit\n    \n    if (foundDuplicates) {\n        console.log('Squad cleaned - duplicates removed:', {\n            main: cleanMain.filter(id => id !== null).length,\n            bench: cleanBench.length\n        });\n    }\n    \n    return foundDuplicates;\n}\n\n// Calculate team rating\nfunction calculateTeamRating() {\n    const mainPlayers = currentSquad.main.filter(id => id !== null);\n    if (mainPlayers.length === 0) {\n        document.getElementById('teamRating').textContent = '0';\n        return;\n    }\n    \n    let totalRating = 0;\n    let count = 0;\n    \n    mainPlayers.forEach(playerId => {\n        const player = allPlayers.find(p => p.id === playerId);\n        if (player) {\n            totalRating += player.overall;\n            count++;\n        }\n    });\n    \n    const avgRating = count > 0 ? Math.round(totalRating / count) : 0;\n    document.getElementById('teamRating').textContent = avgRating;\n}\n\n// Render squad pitch\nfunction renderSquadPitch() {\n    const pitch = document.getElementById('squadPitch');\n    const positions = FORMATIONS[currentFormation];\n    \n    // Group positions by rows\n    const rows = {\n        'GK': [positions[0]],\n        'DEF': positions.slice(1, 5).filter(p => p.includes('B')),\n        'MID': positions.filter(p => p.includes('MF')),\n        'ATT': positions.filter(p => p.includes('WF') || p === 'CF')\n    };\n    \n    pitch.innerHTML = '';\n    \n    // Render from attack to defense\n    ['ATT', 'MID', 'DEF', 'GK'].forEach(line => {\n        if (rows[line] && rows[line].length > 0) {\n            const row = document.createElement('div');\n            row.className = 'squad-row';\n            \n            // Track which indices we've already used to avoid duplicates\n            const usedIndices = new Set();\n            \n            rows[line].forEach((position, idx) => {\n                // Find the NEXT occurrence of this position that we haven't used yet\n                let posIndex = -1;\n                for (let i = 0; i < positions.length; i++) {\n                    if (positions[i] === position && !usedIndices.has(i)) {\n                        posIndex = i;\n                        usedIndices.add(i);\n                        break;\n                    }\n                }\n                \n                if (posIndex === -1) return; // Skip if not found\n                \n                const playerId = currentSquad.main[posIndex];\n                const player = playerId ? allPlayers.find(p => p.id === playerId) : null;\n                \n                const slot = document.createElement('div');\n                slot.className = player ? 'player-slot filled' : 'player-slot';\n                slot.dataset.position = posIndex;\n                \n                // Add drag and drop events\n                slot.draggable = player ? true : false;\n                if (player) {\n                    slot.dataset.playerId = player.id;\n                    slot.dataset.rarity = player.rarity;\n                    slot.addEventListener('dragstart', handleDragStart);\n                    slot.addEventListener('dragend', handleDragEnd);\n                    \n                    // Get player image from local assets - try multiple formats\n                    // Sanitize player name: lowercase, replace non-alphanumeric with _, collapse multiple _, trim trailing _\n                    const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n                    const playerImagePng = `/assets/faces/${playerImageName}.png`;\n                    const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n                    \n                    slot.innerHTML = `\n                        <div class=\"pitch-card\">\n                            <div class=\"pitch-card-rating\">${player.overall}</div>\n                            <div class=\"pitch-card-position\">${position}</div>\n                            <div class=\"pitch-card-image\">\n                                <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                                     onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n                            </div>\n                            <div class=\"pitch-card-name\">${player.name}</div>\n                            <div class=\"pitch-card-stats\">\n                                <span class=\"stat-badge\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</span>\n                            </div>\n                        </div>\n                    `;\n                } else {\n                    slot.onclick = () => openPlayerSelector(posIndex);\n                    slot.innerHTML = `\n                        <div class=\"pitch-card-empty\">\n                            <div class=\"empty-position\">${position}</div>\n                            <div class=\"empty-text\">Click to add</div>\n                        </div>\n                    `;\n                }\n                \n                slot.addEventListener('dragover', handleDragOver);\n                slot.addEventListener('drop', handleDrop);\n                slot.addEventListener('dragleave', handleDragLeave);\n                \n                row.appendChild(slot);\n            });\n            \n            pitch.appendChild(row);\n        }\n    });\n    \n    renderBench();\n}\n\n// Render bench\nfunction renderBench() {\n    const benchContainer = document.getElementById('benchPlayers');\n    benchContainer.innerHTML = '';\n    \n    if (!currentSquad.bench || currentSquad.bench.length === 0) {\n        benchContainer.innerHTML = '<p style=\"color: #999;\">No bench players</p>';\n        return;\n    }\n    \n    currentSquad.bench.forEach((playerId, idx) => {\n        const player = allPlayers.find(p => p.id === playerId);\n        if (player) {\n            const benchPlayer = document.createElement('div');\n            benchPlayer.className = 'bench-player';\n            benchPlayer.draggable = true;\n            benchPlayer.dataset.playerId = player.id;\n            benchPlayer.dataset.rarity = player.rarity;\n            benchPlayer.dataset.benchIndex = idx;\n            benchPlayer.dataset.source = 'bench';\n            \n            // Add drag events for bench players\n            benchPlayer.addEventListener('dragstart', handleBenchDragStart);\n            benchPlayer.addEventListener('dragend', handleDragEnd);\n            benchPlayer.addEventListener('dragover', handleDragOver);\n            benchPlayer.addEventListener('drop', handleBenchDrop);\n            benchPlayer.addEventListener('dragleave', handleDragLeave);\n            \n            benchPlayer.onclick = () => showPlayerDetails(player);\n            \n            // Sanitize player name: lowercase, replace non-alphanumeric with _, collapse multiple _, trim trailing _\n            const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n            const playerImagePng = `/assets/faces/${playerImageName}.png`;\n            const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n            \n            benchPlayer.innerHTML = `\n                <div class=\"bench-card-rating\">${player.overall}</div>\n                <div class=\"bench-card-position\">${player.position}</div>\n                <div class=\"bench-card-image\">\n                    <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                         onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n                </div>\n                <div class=\"bench-card-name\">${player.name}</div>\n            `;\n            benchContainer.appendChild(benchPlayer);\n        }\n    });\n}\n\nfunction renderAvailablePlayers() {\n    const container = document.getElementById('availablePlayers');\n    container.innerHTML = '';\n    \n    // Filter out players already in squad or bench\n    const usedPlayerIds = [\n        ...currentSquad.main.filter(id => id !== null),\n        ...currentSquad.bench.filter(id => id !== null)\n    ];\n    const available = availablePlayersList.filter(p => !usedPlayerIds.includes(p.id));\n    \n    if (available.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No available players</p>';\n        return;\n    }\n    \n    available.forEach(player => {\n        const card = document.createElement('div');\n        card.className = 'available-player-card';\n        card.draggable = true;\n        card.dataset.playerId = player.id;\n        card.dataset.rarity = player.rarity;\n        \n        // Add drag events\n        card.addEventListener('dragstart', (e) => {\n            draggedPlayerId = player.id;\n            draggedFromPosition = null;\n            draggedFromBench = false;\n            card.classList.add('dragging');\n            e.dataTransfer.effectAllowed = 'move';\n            startAutoScroll(e);\n        });\n        \n        card.addEventListener('dragend', (e) => {\n            card.classList.remove('dragging');\n            stopAutoScroll();\n        });\n        \n        card.onclick = () => showPlayerDetails(player);\n        \n        // Sanitize player name: lowercase, replace non-alphanumeric with _, collapse multiple _, trim trailing _\n        const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n        const playerImagePng = `/assets/faces/${playerImageName}.png`;\n        const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n        \n        card.innerHTML = `\n            <div class=\"available-card-rating\">${player.overall}</div>\n            <div class=\"available-card-position\">${player.position}</div>\n            <div class=\"available-card-rarity\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</div>\n            <div class=\"available-card-image\">\n                <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                     onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n            </div>\n            <div class=\"available-card-name\">${player.name}</div>\n        `;\n        \n        container.appendChild(card);\n    });\n}\n\n// Render all players\nfunction renderAllPlayers() {\n    const container = document.getElementById('allPlayersGrid');\n    container.innerHTML = '';\n    \n    if (allPlayers.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No players in collection</p>';\n        return;\n    }\n    \n    allPlayers.forEach(player => {\n        const card = createPlayerCard(player, () => showPlayerDetails(player));\n        container.appendChild(card);\n    });\n}\n\n// Show player details modal\nfunction showPlayerDetails(player) {\n    const modal = document.getElementById('playerModal');\n    const content = document.getElementById('playerModalContent');\n    \n    const stats = player.stats || {};\n    \n    content.innerHTML = `\n        <h2>${RARITY_EMOJIS[player.rarity] || '‚öΩ'} ${player.name}</h2>\n        <div style=\"margin: 20px 0;\">\n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;\">\n                <div><strong>Overall:</strong> ${player.overall}</div>\n                <div><strong>Position:</strong> ${player.position}</div>\n                <div><strong>Rarity:</strong> ${player.rarity}</div>\n                <div><strong>Style:</strong> ${player.playingStyle || 'N/A'}</div>\n            </div>\n            \n            <h3 style=\"color: var(--primary); margin: 20px 0 10px 0;\">Stats</h3>\n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 10px;\">\n                <div>‚öîÔ∏è Attacking: ${stats.attacking || 0}</div>\n                <div>üéØ Dribbling: ${stats.dribbling || 0}</div>\n                <div>üéØ Passing: ${stats.passing || 0}</div>\n                <div>üõ°Ô∏è Defending: ${stats.defending || 0}</div>\n                <div>üí™ Physicality: ${stats.physicality || 0}</div>\n                <div>üß§ Goalkeeping: ${stats.goalkeeping || 0}</div>\n            </div>\n            \n            ${player.skills && player.skills.length > 0 ? `\n                <h3 style=\"color: var(--primary); margin: 20px 0 10px 0;\">Skills</h3>\n                <div style=\"color: #666;\">${player.skills.slice(0, 5).join(', ')}</div>\n            ` : ''}\n        </div>\n    `;\n    \n    modal.classList.add('active');\n    modal.style.display = 'flex';\n}\n\n// Close modal\nfunction closeModal() {\n    const modal = document.getElementById('playerModal');\n    modal.classList.remove('active');\n    modal.style.display = 'none';\n}\n\n// Open player selector for position\nlet selectedPosition = null;\n\nfunction openPlayerSelector(positionIndex) {\n    selectedPosition = positionIndex;\n    \n    // Show available players filtered by position\n    const requiredPos = FORMATIONS[currentFormation][positionIndex];\n    \n    // Get all used player IDs (filter out null and undefined)\n    const usedPlayerIds = [\n        ...currentSquad.main.filter(id => id !== null && id !== undefined),\n        ...currentSquad.bench.filter(id => id !== null && id !== undefined)\n    ];\n    \n    // Filter players by compatible positions\n    const compatible = allPlayers.filter(p => {\n        // Exclude players already in squad or bench\n        if (usedPlayerIds.includes(p.id)) return false;\n        \n        // Position compatibility\n        if (requiredPos === 'GK') return p.position === 'GK';\n        if (requiredPos.includes('B')) return ['CB', 'LB', 'RB'].includes(p.position);\n        if (requiredPos.includes('MF')) return ['DMF', 'CMF', 'AMF', 'LMF', 'RMF'].includes(p.position);\n        if (requiredPos.includes('WF') || requiredPos === 'CF') return ['LWF', 'RWF', 'CF'].includes(p.position);\n        return p.position === requiredPos;\n    });\n    \n    const container = document.getElementById('availablePlayers');\n    container.innerHTML = '';\n    \n    if (compatible.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No compatible players available</p>';\n        return;\n    }\n    \n    compatible.forEach(player => {\n        const card = createPlayerCard(player, () => {\n            assignPlayerToPosition(player.id, selectedPosition);\n        });\n        container.appendChild(card);\n    });\n    \n    // Switch to squad tab\n    showTab('squad');\n}\n\n// Assign player to position\nfunction assignPlayerToPosition(playerId, positionIndex) {\n    // CRITICAL: Check if player already exists ANYWHERE in squad or bench\n    const inSquad = currentSquad.main.filter(id => id !== null).indexOf(playerId);\n    const inBench = currentSquad.bench.filter(id => id !== null).indexOf(playerId);\n    \n    if (inSquad !== -1 && inSquad !== positionIndex) {\n        alert('‚ö†Ô∏è This player is already in your squad at another position!');\n        return;\n    }\n    \n    if (inBench !== -1) {\n        alert('‚ö†Ô∏è This player is already on your bench!');\n        return;\n    }\n    \n    // If position is already occupied, move that player to bench\n    const currentPlayerAtPosition = currentSquad.main[positionIndex];\n    if (currentPlayerAtPosition && currentPlayerAtPosition !== playerId) {\n        // Check bench limit (max 8 players)\n        if (currentSquad.bench.length >= 8) {\n            alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed on bench.');\n            return;\n        }\n        currentSquad.bench.push(currentPlayerAtPosition);\n    }\n    \n    // Assign player to position\n    currentSquad.main[positionIndex] = playerId;\n    \n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n}\n\n// Change formation\nfunction changeFormation() {\n    const newFormation = document.getElementById('formationSelect').value;\n    \n    if (confirm(`Change formation to ${newFormation}? Your current squad will be cleared.`)) {\n        currentFormation = newFormation;\n        currentSquad.main = new Array(11).fill(null);\n        renderSquadPitch();\n        renderAvailablePlayers();\n        calculateTeamRating();\n    } else {\n        document.getElementById('formationSelect').value = currentFormation;\n    }\n}\n\n// Save squad\nasync function saveSquad(silent = false) {\n    try {\n        const response = await fetch('/api/squad/update', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                squad: currentSquad,\n                formation: currentFormation\n            })\n        });\n        \n        const result = await response.json();\n        \n        if (result.success) {\n            if (!silent) {\n                alert('‚úÖ Squad saved successfully!');\n            } else {\n                console.log('‚úÖ Squad auto-saved after cleanup');\n            }\n        } else {\n            if (!silent) {\n                alert('‚ùå Failed to save squad: ' + (result.error || 'Unknown error'));\n            }\n        }\n    } catch (error) {\n        console.error('Error saving squad:', error);\n        if (!silent) {\n            alert('‚ùå Failed to save squad. Please try again.');\n        }\n    }\n}\n\n// Filter players\nfunction filterPlayers() {\n    const searchTerm = document.getElementById('playerSearch').value.toLowerCase();\n    const positionFilter = document.getElementById('positionFilter').value;\n    const ratingSort = document.getElementById('availableRatingSort').value;\n    \n    availablePlayersList = allPlayers.filter(player => {\n        const matchesSearch = player.name.toLowerCase().includes(searchTerm);\n        let matchesPosition = true;\n        \n        if (positionFilter) {\n            if (positionFilter === 'DEF') {\n                matchesPosition = ['CB', 'LB', 'RB'].includes(player.position);\n            } else if (positionFilter === 'MID') {\n                matchesPosition = ['DMF', 'CMF', 'AMF', 'LMF', 'RMF'].includes(player.position);\n            } else if (positionFilter === 'ATT') {\n                matchesPosition = ['LWF', 'RWF', 'CF'].includes(player.position);\n            } else {\n                matchesPosition = player.position === positionFilter;\n            }\n        }\n        \n        return matchesSearch && matchesPosition;\n    });\n    \n    // Sort by rating if selected\n    if (ratingSort === 'high-low') {\n        availablePlayersList.sort((a, b) => b.overall - a.overall);\n    } else if (ratingSort === 'low-high') {\n        availablePlayersList.sort((a, b) => a.overall - b.overall);\n    }\n    \n    renderAvailablePlayers();\n}\n\n// Filter all players\nfunction filterAllPlayers() {\n    const searchTerm = document.getElementById('allPlayersSearch').value.toLowerCase();\n    const rarityFilter = document.getElementById('rarityFilter').value;\n    const ratingSort = document.getElementById('ratingSort').value;\n    \n    let filtered = allPlayers.filter(player => {\n        const matchesSearch = player.name.toLowerCase().includes(searchTerm);\n        const matchesRarity = !rarityFilter || player.rarity === rarityFilter;\n        return matchesSearch && matchesRarity;\n    });\n    \n    // Sort by rating if selected\n    if (ratingSort === 'high-low') {\n        filtered.sort((a, b) => b.overall - a.overall);\n    } else if (ratingSort === 'low-high') {\n        filtered.sort((a, b) => a.overall - b.overall);\n    }\n    \n    const container = document.getElementById('allPlayersGrid');\n    container.innerHTML = '';\n    \n    if (filtered.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px;\">No players found</p>';\n        return;\n    }\n    \n    filtered.forEach(player => {\n        const card = createPlayerCard(player, () => showPlayerDetails(player));\n        container.appendChild(card);\n    });\n}\n\n// Show tab\nfunction showTab(tabName) {\n    // Hide all tabs\n    document.querySelectorAll('.tab-content').forEach(tab => {\n        tab.classList.remove('active');\n    });\n    \n    // Show selected tab\n    document.getElementById(`${tabName}-tab`).classList.add('active');\n    \n    // Update nav links\n    document.querySelectorAll('.nav-link').forEach(link => {\n        link.classList.remove('active');\n    });\n}\n\n// Close modal on outside click\nwindow.onclick = function(event) {\n    const modal = document.getElementById('playerModal');\n    if (event.target === modal) {\n        closeModal();\n    }\n}\n\n// Drag and Drop Handlers\nlet draggedElement = null;\nlet draggedPlayerId = null;\nlet draggedFromPosition = null;\nlet draggedFromBench = false;\nlet draggedBenchIndex = null;\n\nfunction handleDragStart(e) {\n    draggedElement = e.target;\n    draggedPlayerId = e.target.dataset.playerId;\n    draggedFromPosition = parseInt(e.target.dataset.position);\n    draggedFromBench = false;\n    draggedBenchIndex = null;\n    \n    e.target.classList.add('dragging');\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/html', e.target.innerHTML);\n    \n    // Start auto-scroll\n    startAutoScroll(e);\n}\n\nfunction handleBenchDragStart(e) {\n    draggedElement = e.target;\n    draggedPlayerId = e.target.dataset.playerId;\n    draggedFromPosition = null;\n    draggedFromBench = true;\n    draggedBenchIndex = parseInt(e.target.dataset.benchIndex);\n    \n    e.target.classList.add('dragging');\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/html', e.target.innerHTML);\n    \n    // Start auto-scroll\n    startAutoScroll(e);\n}\n\nfunction handleDragEnd(e) {\n    e.target.classList.remove('dragging');\n    \n    // Stop auto-scroll\n    stopAutoScroll();\n    \n    // Remove drag-over class from all slots\n    document.querySelectorAll('.player-slot').forEach(slot => {\n        slot.classList.remove('drag-over');\n    });\n}\n\nfunction handleDragOver(e) {\n    if (e.preventDefault) {\n        e.preventDefault();\n    }\n    \n    e.dataTransfer.dropEffect = 'move';\n    e.target.closest('.player-slot')?.classList.add('drag-over');\n    \n    return false;\n}\n\nfunction handleDragLeave(e) {\n    e.target.closest('.player-slot')?.classList.remove('drag-over');\n}\n\nfunction handleDrop(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n    \n    e.preventDefault();\n    \n    const dropSlot = e.target.closest('.player-slot');\n    if (!dropSlot) return;\n    \n    const dropPosition = parseInt(dropSlot.dataset.position);\n    const dropPlayerId = dropSlot.dataset.playerId;\n    \n    // Don't drop on the same position\n    if (!draggedFromBench && draggedFromPosition === dropPosition) {\n        dropSlot.classList.remove('drag-over');\n        return false;\n    }\n    \n    // If dragging from bench\n    if (draggedFromBench) {\n        // Remove from bench\n        currentSquad.bench.splice(draggedBenchIndex, 1);\n        \n        // If dropping on occupied slot, move that player to bench\n        if (dropPlayerId) {\n            // Check bench limit before adding\n            if (currentSquad.bench.length >= 8) {\n                alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n                currentSquad.bench.splice(draggedBenchIndex, 0, draggedPlayerId); // Put back\n                dropSlot.classList.remove('drag-over');\n                return false;\n            }\n            currentSquad.bench.push(dropPlayerId);\n        }\n        \n        // Add to squad position\n        currentSquad.main[dropPosition] = draggedPlayerId;\n    }\n    // If dragging from available players (not from pitch or bench)\n    else if (draggedFromPosition === null && !draggedFromBench) {\n        // Check if player already exists in squad (strict check)\n        const inSquad = currentSquad.main.filter(id => id !== null).indexOf(draggedPlayerId);\n        if (inSquad !== -1) {\n            alert('‚ö†Ô∏è This player is already in your squad!');\n            dropSlot.classList.remove('drag-over');\n            return false;\n        }\n        \n        // Check if player is in bench (strict check)\n        const inBench = currentSquad.bench.filter(id => id !== null).indexOf(draggedPlayerId);\n        if (inBench !== -1) {\n            alert('‚ö†Ô∏è This player is already on your bench!');\n            dropSlot.classList.remove('drag-over');\n            return false;\n        }\n        \n        // If dropping on occupied slot, move that player to bench\n        if (dropPlayerId) {\n            // Check bench limit before adding\n            if (currentSquad.bench.length >= 8) {\n                alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n                dropSlot.classList.remove('drag-over');\n                return false;\n            }\n            currentSquad.bench.push(dropPlayerId);\n        }\n        \n        // Add to position\n        currentSquad.main[dropPosition] = draggedPlayerId;\n    } else {\n        // Swap players from pitch\n        if (dropPlayerId) {\n            // Swap the two players\n            currentSquad.main[draggedFromPosition] = dropPlayerId;\n            currentSquad.main[dropPosition] = draggedPlayerId;\n        } else {\n            // Move to empty slot\n            currentSquad.main[dropPosition] = draggedPlayerId;\n            currentSquad.main[draggedFromPosition] = null;\n        }\n    }\n    \n    // Re-render the pitch\n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n    \n    return false;\n}\n\n// Handle drop on bench\nfunction handleBenchDrop(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n    \n    e.preventDefault();\n    \n    const dropTarget = e.target.closest('.bench-player');\n    \n    // If dragging from squad to bench\n    if (draggedFromPosition !== null && !draggedFromBench) {\n        // Check bench limit\n        if (currentSquad.bench.length >= 8) {\n            alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n            return false;\n        }\n        \n        // Remove from squad\n        currentSquad.main[draggedFromPosition] = null;\n        \n        // Add to bench if not already there\n        if (!currentSquad.bench.includes(draggedPlayerId)) {\n            currentSquad.bench.push(draggedPlayerId);\n        }\n    }\n    // If dragging from available players to bench\n    else if (draggedFromPosition === null && !draggedFromBench) {\n        // Check bench limit\n        if (currentSquad.bench.length >= 8) {\n            alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n            return false;\n        }\n        \n        // Check if already in squad or bench (strict check)\n        const inSquad = currentSquad.main.filter(id => id !== null).includes(draggedPlayerId);\n        const inBench = currentSquad.bench.filter(id => id !== null).includes(draggedPlayerId);\n        \n        if (inSquad) {\n            alert('‚ö†Ô∏è This player is already in your squad!');\n            return false;\n        }\n        if (inBench) {\n            alert('‚ö†Ô∏è This player is already on your bench!');\n            return false;\n        }\n        \n        // Add to bench\n        currentSquad.bench.push(draggedPlayerId);\n    }\n    // If swapping bench players\n    else if (draggedFromBench && dropTarget) {\n        const dropBenchIndex = parseInt(dropTarget.dataset.benchIndex);\n        if (draggedBenchIndex !== dropBenchIndex) {\n            // Swap bench positions\n            const temp = currentSquad.bench[draggedBenchIndex];\n            currentSquad.bench[draggedBenchIndex] = currentSquad.bench[dropBenchIndex];\n            currentSquad.bench[dropBenchIndex] = temp;\n        }\n    }\n    \n    // Re-render\n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n    \n    return false;\n}\n\n// Make player cards draggable too\nfunction createPlayerCard(player, onClick) {\n    const card = document.createElement('div');\n    card.className = 'player-card';\n    card.draggable = true;\n    card.dataset.playerId = player.id;\n    card.dataset.rarity = player.rarity;\n    \n    // Drag events for player cards\n    card.addEventListener('dragstart', (e) => {\n        draggedPlayerId = player.id;\n        draggedFromPosition = null; // Coming from available players\n        e.target.classList.add('dragging');\n        e.dataTransfer.effectAllowed = 'copy';\n    });\n    \n    card.addEventListener('dragend', (e) => {\n        e.target.classList.remove('dragging');\n    });\n    \n    card.onclick = onClick;\n    \n    // Sanitize player name for image\n    const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n    const playerImagePng = `/assets/faces/${playerImageName}.png`;\n    const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n    \n    card.innerHTML = `\n        <div class=\"player-image-container\">\n            <div class=\"player-overall\">${player.overall}</div>\n            <div class=\"player-position\">${player.position}</div>\n            <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                 onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n        </div>\n        <div class=\"rarity\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</div>\n        <div class=\"name\">${player.name}</div>\n    `;\n    \n    return card;\n}\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    init();\n    \n    // Make bench section a drop zone\n    const benchSection = document.getElementById('benchSection');\n    if (benchSection) {\n        benchSection.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            benchSection.classList.add('drag-over');\n        });\n        \n        benchSection.addEventListener('dragleave', (e) => {\n            if (e.target === benchSection) {\n                benchSection.classList.remove('drag-over');\n            }\n        });\n        \n        benchSection.addEventListener('drop', (e) => {\n            e.preventDefault();\n            benchSection.classList.remove('drag-over');\n            \n            // Check bench limit first\n            if (currentSquad.bench.length >= 8 && !draggedFromBench) {\n                alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n                return;\n            }\n            \n            // If dragging from squad to bench\n            if (draggedFromPosition !== null && !draggedFromBench) {\n                currentSquad.main[draggedFromPosition] = null;\n                if (!currentSquad.bench.includes(draggedPlayerId)) {\n                    currentSquad.bench.push(draggedPlayerId);\n                }\n            }\n            // If dragging from available players to bench\n            else if (draggedFromPosition === null && !draggedFromBench) {\n                // Strict duplicate check\n                const inSquad = currentSquad.main.filter(id => id !== null).includes(draggedPlayerId);\n                const inBench = currentSquad.bench.filter(id => id !== null).includes(draggedPlayerId);\n                \n                if (!inSquad && !inBench) {\n                    currentSquad.bench.push(draggedPlayerId);\n                } else {\n                    alert('‚ö†Ô∏è This player is already in your squad or bench!');\n                    return;\n                }\n            }\n            \n            renderSquadPitch();\n            renderAvailablePlayers();\n            calculateTeamRating();\n        });\n    }\n});\n\n// Auto-scroll functionality\nfunction startAutoScroll(e) {\n    // Store initial mouse position\n    document.addEventListener('dragover', handleAutoScroll);\n}\n\nfunction handleAutoScroll(e) {\n    const scrollZone = 100; // pixels from edge to trigger scroll\n    const scrollSpeed = 10; // pixels per frame\n    \n    const viewportHeight = window.innerHeight;\n    const mouseY = e.clientY;\n    \n    // Scroll up if near top\n    if (mouseY < scrollZone) {\n        window.scrollBy(0, -scrollSpeed);\n    }\n    // Scroll down if near bottom\n    else if (mouseY > viewportHeight - scrollZone) {\n        window.scrollBy(0, scrollSpeed);\n    }\n}\n\nfunction stopAutoScroll() {\n    document.removeEventListener('dragover', handleAutoScroll);\n}\n\n","size_bytes":36815},"public/styles.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    --primary: #0014DC;\n    --secondary: #FFED00;\n    --accent-blue: #4169E1;\n    --accent-pink: #FF006B;\n    --success: #27ae60;\n    --danger: #e74c3c;\n    --warning: #f39c12;\n    --dark: #000033;\n    --light: #ecf0f1;\n    --pitch-green: #1a8f3c;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(180deg, #0014DC 0%, #000033 100%);\n    min-height: 100vh;\n    color: #fff;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 20px;\n}\n\n/* Header */\n.header {\n    text-align: center;\n    color: white;\n    padding: 40px 20px;\n}\n\n.header h1 {\n    font-size: 3em;\n    margin-bottom: 10px;\n    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);\n}\n\n.header p {\n    font-size: 1.2em;\n    opacity: 0.9;\n}\n\n/* Hero Section */\n.hero {\n    background: rgba(0, 20, 220, 0.4);\n    border-radius: 20px;\n    padding: 60px 40px;\n    margin: 40px 0;\n    box-shadow: 0 20px 60px rgba(0,0,0,0.5);\n    text-align: center;\n    border: 3px solid var(--secondary);\n}\n\n.hero h2 {\n    font-size: 2.5em;\n    color: var(--secondary);\n    margin-bottom: 20px;\n    font-weight: 900;\n    text-transform: uppercase;\n    letter-spacing: 2px;\n}\n\n.hero p {\n    font-size: 1.2em;\n    color: #fff;\n    margin-bottom: 30px;\n    line-height: 1.6;\n}\n\n/* Buttons */\n.btn {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n    padding: 15px 30px;\n    border-radius: 10px;\n    text-decoration: none;\n    font-weight: bold;\n    font-size: 1.1em;\n    transition: all 0.3s;\n    border: none;\n    cursor: pointer;\n}\n\n.btn-primary {\n    background: var(--secondary);\n    color: #000;\n    font-weight: 900;\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    box-shadow: 0 4px 15px rgba(255, 237, 0, 0.4);\n}\n\n.btn-primary:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 10px 30px rgba(255, 237, 0, 0.6);\n    background: #FFF500;\n}\n\n.btn-secondary {\n    background: transparent;\n    color: var(--secondary);\n    border: 3px solid var(--secondary);\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.btn-secondary:hover {\n    background: var(--secondary);\n    color: #000;\n}\n\n.btn-large {\n    padding: 20px 40px;\n    font-size: 1.3em;\n}\n\n.cta-buttons {\n    display: flex;\n    gap: 20px;\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n/* Features */\n.features-section {\n    background: rgba(0, 20, 220, 0.3);\n    border-radius: 20px;\n    padding: 60px 40px;\n    margin: 40px 0;\n    box-shadow: 0 20px 60px rgba(0,0,0,0.5);\n    border: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.features-section h2 {\n    text-align: center;\n    font-size: 2.5em;\n    color: var(--secondary);\n    margin-bottom: 40px;\n    font-weight: 900;\n    text-transform: uppercase;\n    letter-spacing: 2px;\n}\n\n.features-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n    gap: 30px;\n}\n\n.feature-card {\n    background: rgba(0, 0, 51, 0.8);\n    padding: 30px;\n    border-radius: 15px;\n    text-align: center;\n    transition: transform 0.3s;\n    border: 2px solid rgba(255, 237, 0, 0.2);\n}\n\n.feature-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 10px 30px rgba(255, 237, 0, 0.3);\n    border-color: var(--secondary);\n}\n\n.feature-icon {\n    font-size: 3em;\n    margin-bottom: 15px;\n}\n\n.feature-card h3 {\n    color: var(--secondary);\n    margin-bottom: 10px;\n    font-weight: 900;\n}\n\n.feature-card p {\n    color: #ccc;\n    line-height: 1.6;\n}\n\n/* CTA Section */\n.cta-section {\n    background: rgba(255, 0, 107, 0.2);\n    border-radius: 20px;\n    padding: 60px 40px;\n    margin: 40px 0;\n    text-align: center;\n    box-shadow: 0 20px 60px rgba(0,0,0,0.5);\n    border: 3px solid var(--accent-pink);\n}\n\n.cta-section h2 {\n    font-size: 2.5em;\n    color: var(--secondary);\n    margin-bottom: 20px;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.cta-section p {\n    font-size: 1.2em;\n    color: #fff;\n    margin-bottom: 30px;\n}\n\n/* Footer */\n.footer {\n    text-align: center;\n    color: white;\n    padding: 40px 20px;\n    opacity: 0.8;\n}\n\n.footer a {\n    color: white;\n    text-decoration: underline;\n}\n\n/* Top Bar Right Section */\n.top-bar-right {\n    display: flex;\n    align-items: center;\n    gap: 20px;\n    margin-left: auto;\n}\n\n.currency-display {\n    display: flex;\n    gap: 15px;\n    background: rgba(0, 0, 0, 0.3);\n    padding: 8px 15px;\n    border-radius: 20px;\n}\n\n.currency-item {\n    font-weight: bold;\n    color: #fff;\n    font-size: 1em;\n}\n\n.top-icons {\n    display: flex;\n    gap: 10px;\n}\n\n.icon-btn {\n    background: rgba(255, 255, 255, 0.1);\n    border: none;\n    color: #fff;\n    font-size: 1.5em;\n    width: 45px;\n    height: 45px;\n    border-radius: 50%;\n    cursor: pointer;\n    transition: all 0.3s;\n    position: relative;\n}\n\n.icon-btn:hover {\n    background: rgba(255, 237, 0, 0.3);\n    transform: scale(1.1);\n}\n\n.notification-badge {\n    position: absolute;\n    top: -5px;\n    right: -5px;\n    background: #e74c3c;\n    color: white;\n    font-size: 0.6em;\n    padding: 2px 6px;\n    border-radius: 10px;\n    font-weight: bold;\n}\n\n/* Home Tabs */\n.home-tabs {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 30px;\n    background: rgba(0, 0, 0, 0.3);\n    padding: 10px;\n    border-radius: 30px;\n    justify-content: center;\n}\n\n.home-tab {\n    background: transparent;\n    border: none;\n    color: #fff;\n    padding: 12px 30px;\n    font-size: 1.1em;\n    font-weight: bold;\n    cursor: pointer;\n    transition: all 0.3s;\n    border-radius: 20px;\n}\n\n.home-tab:hover {\n    background: rgba(255, 255, 255, 0.1);\n}\n\n.home-tab.active {\n    background: rgba(255, 255, 255, 0.9);\n    color: #000;\n}\n\n.home-tab-content {\n    display: none;\n}\n\n.home-tab-content.active {\n    display: block;\n}\n\n/* Featured Banner */\n.featured-banner {\n    background: linear-gradient(135deg, rgba(0, 100, 0, 0.8), rgba(0, 50, 0, 0.9));\n    border-radius: 20px;\n    padding: 30px;\n    margin-bottom: 30px;\n    position: relative;\n    overflow: hidden;\n    min-height: 250px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.coming-soon-banner {\n    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 20, 0.95));\n    border: 2px solid rgba(255, 237, 0, 0.3);\n    justify-content: center;\n    text-align: center;\n    min-height: 200px;\n}\n\n.banner-content {\n    flex: 1;\n    z-index: 2;\n}\n\n.banner-badge {\n    display: inline-block;\n    background: rgba(138, 43, 226, 0.9);\n    color: white;\n    padding: 5px 15px;\n    border-radius: 15px;\n    font-weight: bold;\n    margin-bottom: 10px;\n}\n\n.banner-title {\n    font-size: 2em;\n    color: #fff;\n    margin: 10px 0;\n}\n\n.banner-timer {\n    color: #FFED00;\n    font-weight: bold;\n    margin: 10px 0;\n}\n\n.banner-description {\n    color: #fff;\n    margin: 10px 0;\n    font-size: 1.1em;\n}\n\n.banner-note {\n    color: rgba(255, 255, 255, 0.7);\n    font-size: 0.9em;\n    font-style: italic;\n    margin-top: 10px;\n}\n\n.banner-image {\n    flex: 1;\n    display: flex;\n    justify-content: flex-end;\n    align-items: center;\n    z-index: 1;\n}\n\n.banner-image img {\n    max-width: 100%;\n    max-height: 250px;\n    object-fit: contain;\n}\n\n.banner-settings {\n    position: absolute;\n    bottom: 15px;\n    right: 15px;\n    background: rgba(0, 0, 0, 0.5);\n    border: none;\n    color: white;\n    font-size: 1.5em;\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    cursor: pointer;\n    transition: all 0.3s;\n}\n\n.banner-settings:hover {\n    background: rgba(0, 0, 0, 0.8);\n    transform: rotate(90deg);\n}\n\n/* Game Mode Buttons */\n.game-modes {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 20px;\n    margin-top: 30px;\n    max-width: 600px;\n    margin-left: auto;\n    margin-right: auto;\n}\n\n.game-mode-btn {\n    background: linear-gradient(135deg, rgba(0, 150, 200, 0.9), rgba(0, 100, 150, 0.9));\n    border: 3px solid rgba(255, 255, 255, 0.3);\n    border-radius: 20px;\n    padding: 30px 20px;\n    cursor: pointer;\n    transition: all 0.3s;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: 10px;\n    color: white;\n}\n\n.game-mode-btn:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);\n    border-color: rgba(255, 255, 255, 0.6);\n}\n\n.mode-icon {\n    font-size: 3em;\n}\n\n.mode-label {\n    font-size: 1.2em;\n    font-weight: bold;\n}\n\n/* Mode Colors */\n.mode-cyan {\n    background: linear-gradient(135deg, rgba(0, 200, 255, 0.9), rgba(0, 150, 200, 0.9));\n}\n\n.mode-red {\n    background: linear-gradient(135deg, rgba(220, 50, 50, 0.9), rgba(180, 30, 30, 0.9));\n}\n\n.mode-purple {\n    background: linear-gradient(135deg, rgba(200, 50, 200, 0.9), rgba(150, 30, 150, 0.9));\n}\n\n.mode-green {\n    background: linear-gradient(135deg, rgba(100, 200, 50, 0.9), rgba(70, 150, 30, 0.9));\n}\n\n.mode-orange {\n    background: linear-gradient(135deg, rgba(255, 150, 0, 0.9), rgba(200, 100, 0, 0.9));\n}\n\n/* Coming Soon */\n.coming-soon {\n    text-align: center;\n    padding: 100px 20px;\n    color: #fff;\n}\n\n.coming-soon h2 {\n    font-size: 3em;\n    margin-bottom: 20px;\n}\n\n.coming-soon p {\n    font-size: 1.5em;\n    color: rgba(255, 255, 255, 0.7);\n}\n\n/* Inbox Page */\n.inbox-container {\n    max-width: 1000px;\n    margin: 0 auto;\n    padding: 20px;\n}\n\n.inbox-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 30px;\n    padding-bottom: 20px;\n    border-bottom: 3px solid rgba(255, 237, 0, 0.3);\n}\n\n.inbox-title {\n    color: #FFED00;\n    font-size: 3em;\n    margin: 0;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.btn-claim-all {\n    background: linear-gradient(135deg, #FFED00, #FFC107);\n    border: none;\n    color: #000;\n    padding: 15px 35px;\n    border-radius: 10px;\n    font-weight: bold;\n    font-size: 1.1em;\n    cursor: pointer;\n    transition: all 0.3s;\n    text-transform: uppercase;\n}\n\n.btn-claim-all:hover:not(:disabled) {\n    background: linear-gradient(135deg, #FFC107, #FF9800);\n    transform: translateY(-2px);\n    box-shadow: 0 5px 20px rgba(255, 237, 0, 0.5);\n}\n\n.btn-claim-all:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.inbox-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0;\n}\n\n.inbox-item {\n    background: linear-gradient(135deg, rgba(20, 20, 20, 0.95), rgba(40, 40, 40, 0.95));\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    padding: 20px;\n    display: flex;\n    gap: 20px;\n    align-items: center;\n    transition: all 0.3s;\n}\n\n.inbox-icon {\n    width: 80px;\n    height: 80px;\n    border-radius: 15px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 2.5em;\n    flex-shrink: 0;\n}\n\n.inbox-content {\n    flex: 1;\n}\n\n.inbox-title {\n    font-size: 1.4em;\n    font-weight: bold;\n    color: #fff;\n    margin-bottom: 8px;\n}\n\n.inbox-description {\n    color: rgba(255, 255, 255, 0.7);\n    font-size: 1em;\n    line-height: 1.5;\n}\n\n.inbox-meta {\n    text-align: right;\n    min-width: 150px;\n}\n\n.inbox-date {\n    color: rgba(255, 255, 255, 0.5);\n    font-size: 0.95em;\n    margin-bottom: 5px;\n}\n\n.inbox-expiry {\n    color: #ff4444;\n    font-size: 0.9em;\n    font-weight: bold;\n}\n\n.empty-inbox {\n    text-align: center;\n    padding: 100px 20px;\n    color: rgba(255, 255, 255, 0.7);\n}\n\n.empty-icon {\n    font-size: 5em;\n    margin-bottom: 20px;\n}\n\n.empty-inbox h2 {\n    color: #fff;\n    font-size: 2em;\n    margin-bottom: 10px;\n}\n\n.empty-inbox p {\n    font-size: 1.2em;\n}\n\n/* News Page */\n.news-container {\n    max-width: 1000px;\n    margin: 0 auto;\n    padding: 20px;\n}\n\n.news-header {\n    margin-bottom: 30px;\n    padding-bottom: 20px;\n    border-bottom: 3px solid rgba(255, 237, 0, 0.3);\n}\n\n.news-title {\n    color: #FFED00;\n    font-size: 3em;\n    margin: 0;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.news-list {\n    display: flex;\n    flex-direction: column;\n    gap: 0;\n}\n\n.news-item {\n    background: linear-gradient(135deg, rgba(30, 30, 30, 0.95), rgba(50, 50, 50, 0.95));\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    padding: 20px;\n    display: flex;\n    gap: 20px;\n    align-items: center;\n    transition: all 0.3s;\n    cursor: pointer;\n}\n\n.news-item:hover {\n    background: linear-gradient(135deg, rgba(50, 50, 50, 0.95), rgba(70, 70, 70, 0.95));\n    border-left: 4px solid #FFED00;\n}\n\n.news-icon {\n    width: 80px;\n    height: 80px;\n    border-radius: 15px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    font-size: 2em;\n    flex-shrink: 0;\n    position: relative;\n}\n\n.news-category {\n    font-size: 0.4em;\n    font-weight: bold;\n    color: white;\n    margin-top: 5px;\n    text-transform: capitalize;\n}\n\n.news-content {\n    flex: 1;\n}\n\n.news-item-title {\n    font-size: 1.3em;\n    font-weight: bold;\n    color: #fff;\n    margin-bottom: 8px;\n}\n\n.news-preview {\n    color: rgba(255, 255, 255, 0.6);\n    font-size: 0.95em;\n    line-height: 1.5;\n}\n\n.news-date {\n    color: rgba(255, 255, 255, 0.5);\n    font-size: 0.95em;\n    min-width: 100px;\n    text-align: right;\n}\n\n.empty-news {\n    text-align: center;\n    padding: 100px 20px;\n    color: rgba(255, 255, 255, 0.7);\n}\n\n.empty-news h2 {\n    color: #fff;\n    font-size: 2em;\n    margin-bottom: 10px;\n}\n\n.empty-news p {\n    font-size: 1.2em;\n}\n\n/* News Modal */\n.news-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 10000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 0.3s;\n}\n\n.news-modal.active {\n    opacity: 1;\n}\n\n.news-modal-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.8);\n}\n\n.news-modal-content {\n    position: relative;\n    background: linear-gradient(135deg, rgba(240, 240, 240, 0.98), rgba(255, 255, 255, 0.98));\n    border-radius: 15px;\n    max-width: 700px;\n    width: 90%;\n    max-height: 80vh;\n    overflow-y: auto;\n    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);\n    transform: scale(0.9);\n    transition: transform 0.3s;\n}\n\n.news-modal.active .news-modal-content {\n    transform: scale(1);\n}\n\n.news-modal-close {\n    position: absolute;\n    top: 15px;\n    right: 15px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50%;\n    background: white;\n    border: none;\n    font-size: 1.5em;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 10;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n    transition: all 0.3s;\n}\n\n.news-modal-close:hover {\n    background: #f0f0f0;\n    transform: scale(1.1);\n}\n\n.news-modal-icon {\n    margin-bottom: 20px;\n}\n\n.news-modal-title {\n    font-size: 2em;\n    font-weight: bold;\n    color: #000;\n    margin: 0 30px 20px 30px;\n}\n\n.news-modal-body {\n    padding: 0 30px 30px 30px;\n    color: #333;\n    font-size: 1.1em;\n}\n\n.icon-btn.active {\n    background: rgba(255, 237, 0, 0.3);\n    border: 2px solid var(--secondary);\n}\n\n/* Notification animations */\n@keyframes slideIn {\n    from {\n        transform: translateX(400px);\n        opacity: 0;\n    }\n    to {\n        transform: translateX(0);\n        opacity: 1;\n    }\n}\n\n@keyframes slideOut {\n    from {\n        transform: translateX(0);\n        opacity: 1;\n    }\n    to {\n        transform: translateX(400px);\n        opacity: 0;\n    }\n}\n\n/* Navbar */\n.navbar {\n    background: rgba(0, 20, 220, 0.98);\n    box-shadow: 0 2px 10px rgba(0,0,0,0.5);\n    padding: 10px 30px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    position: sticky;\n    top: 0;\n    z-index: 1000;\n    border-bottom: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.nav-brand {\n    font-size: 1.5em;\n    font-weight: 900;\n    color: var(--secondary);\n    text-transform: uppercase;\n    letter-spacing: 2px;\n}\n\n.nav-menu {\n    display: flex;\n    gap: 5px;\n    align-items: center;\n}\n\n.nav-link {\n    color: #fff;\n    text-decoration: none;\n    font-weight: 700;\n    transition: all 0.3s;\n    text-transform: capitalize;\n    font-size: 0.95em;\n    padding: 12px 20px;\n    border-radius: 25px;\n}\n\n.nav-link:hover {\n    color: var(--secondary);\n    background: rgba(255, 237, 0, 0.1);\n}\n\n.nav-link.active {\n    background: var(--secondary);\n    color: #000;\n    font-weight: 900;\n}\n\n.nav-btn {\n    background: var(--secondary);\n    color: #000;\n    font-weight: 900;\n    text-transform: uppercase;\n    padding: 12px 35px;\n    border-radius: 30px;\n    box-shadow: 0 3px 10px rgba(255, 237, 0, 0.4);\n}\n\n.nav-btn:hover {\n    background: #FFF500;\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(255, 237, 0, 0.6);\n}\n\n.nav-btn-pink {\n    background: var(--accent-pink);\n    color: #fff;\n    font-weight: 900;\n    text-transform: uppercase;\n    padding: 12px 35px;\n    border-radius: 30px;\n    box-shadow: 0 3px 10px rgba(255, 0, 107, 0.4);\n}\n\n.nav-btn-pink:hover {\n    background: #FF1A7A;\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(255, 0, 107, 0.6);\n}\n\n.user-info {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.user-avatar {\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    border: 3px solid var(--secondary);\n}\n\n/* Dashboard */\n.dashboard-container {\n    max-width: 1400px;\n    margin: 30px auto;\n    padding: 0 20px;\n}\n\n.tab-content {\n    display: none;\n    animation: fadeIn 0.3s;\n}\n\n.tab-content.active {\n    display: block;\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; transform: translateY(10px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n/* Stats Grid */\n.stats-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 30px;\n}\n\n.stat-card {\n    background: rgba(0, 20, 220, 0.5);\n    border-radius: 15px;\n    padding: 25px;\n    display: flex;\n    align-items: center;\n    gap: 20px;\n    box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n    border: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.stat-icon {\n    font-size: 3em;\n}\n\n.stat-label {\n    color: #ccc;\n    font-size: 0.9em;\n    margin-bottom: 5px;\n    text-transform: uppercase;\n    font-weight: 700;\n}\n\n.stat-value {\n    font-size: 2em;\n    font-weight: 900;\n    color: var(--secondary);\n}\n\n/* Quick Actions */\n.quick-actions {\n    background: rgba(0, 20, 220, 0.5);\n    border-radius: 15px;\n    padding: 30px;\n    box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n    border: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.quick-actions h2 {\n    color: var(--secondary);\n    margin-bottom: 20px;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.action-buttons {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 15px;\n}\n\n.action-btn {\n    background: var(--secondary);\n    color: #000;\n    border: none;\n    border-radius: 10px;\n    padding: 20px;\n    font-size: 1.1em;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    transition: transform 0.3s;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.action-btn:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 10px 30px rgba(255, 237, 0, 0.6);\n    background: #FFF500;\n}\n\n.action-icon {\n    font-size: 1.5em;\n}\n\n/* Squad Builder */\n.squad-builder {\n    background: rgba(0, 20, 220, 0.5);\n    border-radius: 15px;\n    padding: 30px;\n    margin-bottom: 20px;\n    box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n    border: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.squad-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 30px;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.formation-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.formation-selector select {\n    padding: 10px 15px;\n    border-radius: 8px;\n    border: 2px solid var(--secondary);\n    background: rgba(0, 0, 51, 0.8);\n    color: var(--secondary);\n    font-size: 1em;\n    cursor: pointer;\n    font-weight: 700;\n}\n\n/* Squad Pitch */\n.squad-pitch {\n    background: linear-gradient(180deg, #1a8f3c 0%, #2ecc71 100%);\n    border-radius: 15px;\n    padding: 40px 20px;\n    min-height: 600px;\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    justify-content: space-around;\n    box-shadow: inset 0 0 50px rgba(0,0,0,0.2);\n}\n\n.squad-row {\n    display: flex;\n    justify-content: space-around;\n    align-items: center;\n    margin: 10px 0;\n}\n\n.player-slot {\n    background: rgba(0, 0, 51, 0.7);\n    border: 3px dashed rgba(255, 237, 0, 0.5);\n    border-radius: 10px;\n    padding: 10px;\n    min-width: 110px;\n    text-align: center;\n    cursor: pointer;\n    transition: all 0.3s;\n}\n\n.player-slot.filled {\n    background: linear-gradient(135deg, rgba(0, 20, 220, 0.95), rgba(0, 0, 80, 0.95));\n    border: 3px solid var(--secondary);\n    cursor: grab;\n    padding: 8px;\n}\n\n.player-slot.filled[data-rarity=\"Iconic\"] {\n    background: linear-gradient(135deg, \n        rgba(219, 10, 91, 0.95) 0%, \n        rgba(255, 20, 147, 0.9) 25%, \n        rgba(199, 21, 133, 0.95) 50%, \n        rgba(139, 0, 139, 1) 100%);\n    border: 3px solid rgba(255, 20, 147, 0.9);\n    box-shadow: 0 0 20px rgba(255, 20, 147, 0.5);\n}\n\n.player-slot.filled[data-rarity=\"Legend\"] {\n    background: linear-gradient(135deg, \n        rgba(218, 165, 32, 0.95) 0%, \n        rgba(255, 215, 0, 0.9) 25%, \n        rgba(184, 134, 11, 0.95) 50%, \n        rgba(139, 101, 8, 1) 100%);\n    border: 3px solid rgba(255, 215, 0, 0.9);\n    box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);\n}\n\n.player-slot.filled:hover {\n    transform: translateY(-5px) scale(1.05);\n    box-shadow: 0 10px 30px rgba(255, 237, 0, 0.6);\n    border-color: #FFF500;\n}\n\n.player-slot.filled[data-rarity=\"Iconic\"]:hover {\n    box-shadow: 0 10px 30px rgba(255, 20, 147, 0.8);\n    border-color: rgba(255, 20, 147, 1);\n}\n\n.player-slot.filled[data-rarity=\"Legend\"]:hover {\n    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.8);\n    border-color: rgba(255, 215, 0, 1);\n}\n\n.player-slot.drag-over {\n    background: rgba(255, 237, 0, 0.3);\n    border-color: var(--secondary);\n    border-style: solid;\n    transform: scale(1.05);\n}\n\n/* Pitch Card (FIFA Style) */\n.pitch-card {\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: 3px;\n}\n\n.pitch-card-rating {\n    position: absolute;\n    top: -5px;\n    left: 5px;\n    background: var(--secondary);\n    color: #000;\n    font-weight: 900;\n    font-size: 1.1em;\n    padding: 3px 8px;\n    border-radius: 5px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.3);\n    z-index: 2;\n}\n\n.pitch-card-position {\n    position: absolute;\n    top: -5px;\n    right: 5px;\n    background: rgba(0, 0, 0, 0.7);\n    color: var(--secondary);\n    font-weight: 700;\n    font-size: 0.75em;\n    padding: 3px 6px;\n    border-radius: 3px;\n    z-index: 2;\n}\n\n.pitch-card-image {\n    width: 80px;\n    height: 80px;\n    margin: 15px 0 5px 0;\n    border-radius: 50%;\n    overflow: hidden;\n    border: 3px solid var(--secondary);\n    background: linear-gradient(135deg, #0014DC, #000033);\n    box-shadow: 0 4px 10px rgba(255, 237, 0, 0.3);\n}\n\n.pitch-card-image img {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n\n.pitch-card-name {\n    font-weight: 700;\n    font-size: 0.85em;\n    color: #fff;\n    text-shadow: 0 2px 4px rgba(0,0,0,0.5);\n    max-width: 100px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.pitch-card-stats {\n    display: flex;\n    gap: 5px;\n    margin-top: 2px;\n}\n\n.stat-badge {\n    font-size: 1.2em;\n}\n\n/* Empty Pitch Card */\n.pitch-card-empty {\n    padding: 20px 10px;\n    color: #999;\n}\n\n.empty-position {\n    font-size: 0.9em;\n    color: var(--secondary);\n    font-weight: 700;\n    margin-bottom: 5px;\n}\n\n.empty-text {\n    font-size: 0.75em;\n    color: #666;\n}\n\n/* Bench */\n.bench-section {\n    margin-top: 20px;\n    background: rgba(0, 0, 51, 0.3);\n    padding: 20px;\n    border-radius: 10px;\n    border: 2px dashed rgba(255, 237, 0, 0.3);\n    min-height: 100px;\n}\n\n.bench-section h3 {\n    color: var(--secondary);\n    margin-bottom: 15px;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.bench-players {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n    min-height: 60px;\n}\n\n.bench-section.drag-over {\n    background: rgba(255, 237, 0, 0.2);\n    border-color: var(--secondary);\n    border-style: solid;\n}\n\n/* Reserves */\n.reserves-section {\n    margin-top: 20px;\n    background: rgba(0, 0, 51, 0.3);\n    padding: 20px;\n    border-radius: 10px;\n    border: 2px dashed rgba(65, 105, 225, 0.5);\n    min-height: 100px;\n}\n\n.reserves-section h3 {\n    color: var(--accent-blue);\n    margin-bottom: 15px;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n.reserves-players {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n    min-height: 60px;\n}\n\n.reserves-section.drag-over {\n    background: rgba(65, 105, 225, 0.2);\n    border-color: var(--accent-blue);\n    border-style: solid;\n}\n\n.reserve-player {\n    position: relative;\n    background: linear-gradient(135deg, rgba(65, 105, 225, 0.7), rgba(0, 0, 51, 0.7));\n    border: 2px solid rgba(65, 105, 225, 0.5);\n    border-radius: 10px;\n    padding: 8px;\n    min-width: 90px;\n    text-align: center;\n    cursor: grab;\n    transition: all 0.3s;\n    color: #fff;\n    user-select: none;\n}\n\n.reserve-player:hover {\n    border-color: var(--accent-blue);\n    transform: translateY(-3px) scale(1.05);\n    box-shadow: 0 5px 20px rgba(65, 105, 225, 0.6);\n}\n\n.reserve-player.dragging {\n    opacity: 0.5;\n    cursor: grabbing;\n}\n\n.reserve-player.drag-over {\n    background: rgba(65, 105, 225, 0.3);\n    border-color: var(--accent-blue);\n    border-style: solid;\n}\n\n/* Reserve Card Style */\n.reserve-card-rating {\n    position: absolute;\n    top: 5px;\n    left: 5px;\n    background: var(--accent-blue);\n    color: #fff;\n    font-weight: 900;\n    font-size: 0.9em;\n    padding: 2px 6px;\n    border-radius: 4px;\n    z-index: 2;\n}\n\n.reserve-card-position {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    background: rgba(0, 0, 0, 0.7);\n    color: var(--accent-blue);\n    font-weight: 700;\n    font-size: 0.7em;\n    padding: 2px 5px;\n    border-radius: 3px;\n    z-index: 2;\n}\n\n.reserve-card-image {\n    width: 60px;\n    height: 60px;\n    margin: 20px auto 5px auto;\n    border-radius: 50%;\n    overflow: hidden;\n    border: 2px solid var(--accent-blue);\n    background: linear-gradient(135deg, #4169E1, #000033);\n}\n\n.reserve-card-image img {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n\n.reserve-card-name {\n    font-weight: 700;\n    font-size: 0.75em;\n    color: #fff;\n    margin-top: 3px;\n    max-width: 85px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.bench-player {\n    position: relative;\n    background: linear-gradient(135deg, rgba(0, 20, 220, 0.8), rgba(0, 0, 51, 0.8));\n    border: 2px solid rgba(255, 237, 0, 0.4);\n    border-radius: 10px;\n    padding: 8px;\n    min-width: 90px;\n    text-align: center;\n    cursor: grab;\n    transition: all 0.3s;\n    color: #fff;\n    user-select: none;\n}\n\n.bench-player[data-rarity=\"Iconic\"] {\n    background: linear-gradient(135deg, \n        rgba(219, 10, 91, 0.9) 0%, \n        rgba(255, 20, 147, 0.8) 25%, \n        rgba(199, 21, 133, 0.9) 50%, \n        rgba(139, 0, 139, 0.95) 100%);\n    border: 2px solid rgba(255, 20, 147, 0.8);\n    box-shadow: 0 0 20px rgba(255, 20, 147, 0.4);\n}\n\n.bench-player[data-rarity=\"Legend\"] {\n    background: linear-gradient(135deg, \n        rgba(218, 165, 32, 0.9) 0%, \n        rgba(255, 215, 0, 0.8) 25%, \n        rgba(184, 134, 11, 0.9) 50%, \n        rgba(139, 101, 8, 0.95) 100%);\n    border: 2px solid rgba(255, 215, 0, 0.8);\n    box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);\n}\n\n.bench-player:hover {\n    border-color: var(--secondary);\n    transform: translateY(-3px) scale(1.05);\n    box-shadow: 0 5px 20px rgba(255, 237, 0, 0.5);\n}\n\n.bench-player[data-rarity=\"Iconic\"]:hover {\n    box-shadow: 0 5px 25px rgba(255, 20, 147, 0.7);\n    border-color: rgba(255, 20, 147, 1);\n}\n\n.bench-player[data-rarity=\"Legend\"]:hover {\n    box-shadow: 0 5px 25px rgba(255, 215, 0, 0.7);\n    border-color: rgba(255, 215, 0, 1);\n}\n\n.bench-player.dragging {\n    opacity: 0.5;\n    cursor: grabbing;\n}\n\n.bench-player.drag-over {\n    background: rgba(255, 237, 0, 0.3);\n    border-color: var(--secondary);\n    border-style: solid;\n}\n\n/* Bench Card Style */\n.bench-card-rating {\n    position: absolute;\n    top: 5px;\n    left: 5px;\n    background: var(--secondary);\n    color: #000;\n    font-weight: 900;\n    font-size: 0.9em;\n    padding: 2px 6px;\n    border-radius: 4px;\n    z-index: 2;\n}\n\n.bench-card-position {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    background: rgba(0, 0, 0, 0.7);\n    color: var(--secondary);\n    font-weight: 700;\n    font-size: 0.7em;\n    padding: 2px 5px;\n    border-radius: 3px;\n    z-index: 2;\n}\n\n.bench-card-image {\n    width: 60px;\n    height: 60px;\n    margin: 20px auto 5px auto;\n    border-radius: 50%;\n    overflow: hidden;\n    border: 2px solid var(--secondary);\n    background: linear-gradient(135deg, #0014DC, #000033);\n}\n\n.bench-card-image img {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n\n.bench-card-name {\n    font-weight: 700;\n    font-size: 0.75em;\n    color: #fff;\n    margin-top: 3px;\n    max-width: 85px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n/* Available Player Cards (FIFA Style) */\n.available-player-card {\n    position: relative;\n    background: linear-gradient(135deg, rgba(0, 20, 220, 0.9), rgba(0, 0, 80, 0.9));\n    border: 2px solid rgba(255, 237, 0, 0.4);\n    border-radius: 10px;\n    padding: 8px;\n    width: 110px;\n    text-align: center;\n    cursor: grab;\n    transition: all 0.3s;\n    color: #fff;\n    user-select: none;\n}\n\n.available-player-card[data-rarity=\"Iconic\"] {\n    background: linear-gradient(135deg, \n        rgba(219, 10, 91, 0.9) 0%, \n        rgba(255, 20, 147, 0.8) 25%, \n        rgba(199, 21, 133, 0.9) 50%, \n        rgba(139, 0, 139, 0.95) 100%);\n    border: 2px solid rgba(255, 20, 147, 0.8);\n    box-shadow: 0 0 20px rgba(255, 20, 147, 0.4);\n}\n\n.available-player-card[data-rarity=\"Legend\"] {\n    background: linear-gradient(135deg, \n        rgba(218, 165, 32, 0.9) 0%, \n        rgba(255, 215, 0, 0.8) 25%, \n        rgba(184, 134, 11, 0.9) 50%, \n        rgba(139, 101, 8, 0.95) 100%);\n    border: 2px solid rgba(255, 215, 0, 0.8);\n    box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);\n}\n\n.available-player-card:hover {\n    border-color: var(--secondary);\n    transform: translateY(-5px) scale(1.05);\n    box-shadow: 0 10px 30px rgba(255, 237, 0, 0.6);\n}\n\n.available-player-card[data-rarity=\"Iconic\"]:hover {\n    box-shadow: 0 10px 30px rgba(255, 20, 147, 0.7);\n    border-color: rgba(255, 20, 147, 1);\n}\n\n.available-player-card[data-rarity=\"Legend\"]:hover {\n    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.7);\n    border-color: rgba(255, 215, 0, 1);\n}\n\n.available-player-card.dragging {\n    opacity: 0.5;\n    cursor: grabbing;\n}\n\n.available-card-rating {\n    position: absolute;\n    top: 5px;\n    left: 5px;\n    background: var(--secondary);\n    color: #000;\n    font-weight: 900;\n    font-size: 1em;\n    padding: 3px 7px;\n    border-radius: 4px;\n    z-index: 2;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.3);\n}\n\n.available-card-position {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    background: rgba(0, 0, 0, 0.7);\n    color: var(--secondary);\n    font-weight: 700;\n    font-size: 0.75em;\n    padding: 3px 6px;\n    border-radius: 3px;\n    z-index: 2;\n}\n\n.available-card-rarity {\n    position: absolute;\n    top: 30px;\n    right: 5px;\n    font-size: 1.2em;\n    z-index: 2;\n    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));\n}\n\n.available-card-image {\n    width: 70px;\n    height: 70px;\n    margin: 25px auto 8px auto;\n    border-radius: 50%;\n    overflow: hidden;\n    border: 3px solid var(--secondary);\n    background: linear-gradient(135deg, #0014DC, #000033);\n    box-shadow: 0 4px 10px rgba(255, 237, 0, 0.3);\n}\n\n.available-card-image img {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n\n.available-card-name {\n    font-weight: 700;\n    font-size: 0.8em;\n    color: #fff;\n    text-shadow: 0 2px 4px rgba(0,0,0,0.5);\n    max-width: 100px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    margin-top: 3px;\n}\n\n/* Player Selector */\n.player-selector {\n    background: rgba(0, 20, 220, 0.5);\n    border-radius: 15px;\n    padding: 30px;\n    box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n    border: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.player-filters {\n    display: flex;\n    gap: 15px;\n    margin-bottom: 20px;\n    flex-wrap: wrap;\n}\n\n.player-filters input,\n.player-filters select {\n    flex: 1;\n    min-width: 200px;\n    padding: 12px 15px;\n    border: 2px solid var(--secondary);\n    background: rgba(0, 0, 51, 0.8);\n    color: #fff;\n    border-radius: 8px;\n    font-size: 1em;\n    font-weight: 600;\n}\n\n.player-filters select option {\n    background: rgba(0, 0, 51, 0.95);\n    color: #fff;\n    padding: 10px;\n}\n\n.player-filters input:focus,\n.player-filters select:focus {\n    outline: none;\n    border-color: var(--secondary);\n    box-shadow: 0 0 10px rgba(255, 237, 0, 0.3);\n}\n\n.available-players,\n.players-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, 140px);\n    gap: 15px;\n    margin-top: 20px;\n    justify-content: center;\n}\n\n.player-card {\n    background: linear-gradient(135deg, rgba(0, 20, 220, 0.6), rgba(0, 0, 51, 0.9));\n    border: 2px solid rgba(255, 237, 0, 0.4);\n    border-radius: 12px;\n    padding: 12px;\n    text-align: center;\n    cursor: grab;\n    transition: all 0.3s;\n    color: #fff;\n    user-select: none;\n    position: relative;\n    overflow: hidden;\n    width: 140px;\n}\n\n.player-card[data-rarity=\"Iconic\"] {\n    background: linear-gradient(135deg, \n        rgba(219, 10, 91, 0.9) 0%, \n        rgba(255, 20, 147, 0.8) 25%, \n        rgba(199, 21, 133, 0.9) 50%, \n        rgba(139, 0, 139, 0.95) 100%);\n    border: 2px solid rgba(255, 20, 147, 0.8);\n    box-shadow: 0 0 20px rgba(255, 20, 147, 0.4);\n}\n\n.player-card[data-rarity=\"Legend\"] {\n    background: linear-gradient(135deg, \n        rgba(218, 165, 32, 0.9) 0%, \n        rgba(255, 215, 0, 0.8) 25%, \n        rgba(184, 134, 11, 0.9) 50%, \n        rgba(139, 101, 8, 0.95) 100%);\n    border: 2px solid rgba(255, 215, 0, 0.8);\n    box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);\n}\n\n.player-card.dragging {\n    opacity: 0.5;\n    cursor: grabbing;\n    transform: rotate(5deg);\n}\n\n.player-card:hover {\n    border-color: var(--secondary);\n    transform: translateY(-5px);\n    box-shadow: 0 8px 20px rgba(255, 237, 0, 0.3);\n}\n\n.player-card[data-rarity=\"Iconic\"]:hover {\n    box-shadow: 0 8px 30px rgba(255, 20, 147, 0.6);\n    border-color: rgba(255, 20, 147, 1);\n}\n\n.player-card[data-rarity=\"Legend\"]:hover {\n    box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6);\n    border-color: rgba(255, 215, 0, 1);\n}\n\n.player-card .player-image-container {\n    width: 100%;\n    height: 120px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-bottom: 8px;\n    position: relative;\n}\n\n.player-card .player-image-container img {\n    max-width: 100%;\n    max-height: 100%;\n    object-fit: contain;\n}\n\n.player-card .player-overall {\n    position: absolute;\n    top: 5px;\n    left: 5px;\n    background: rgba(0, 0, 0, 0.8);\n    color: var(--secondary);\n    padding: 5px 10px;\n    border-radius: 5px;\n    font-weight: bold;\n    font-size: 1.1em;\n}\n\n.player-card .player-position {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    background: rgba(0, 0, 0, 0.8);\n    color: #fff;\n    padding: 5px 8px;\n    border-radius: 5px;\n    font-size: 0.85em;\n    font-weight: bold;\n}\n\n.player-card .rarity {\n    font-size: 1.2em;\n    margin-bottom: 3px;\n}\n\n.player-card .name {\n    font-weight: bold;\n    margin-bottom: 5px;\n    font-size: 0.95em;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.player-card .overall {\n    font-size: 1.5em;\n    font-weight: 900;\n    color: var(--secondary);\n    margin: 5px 0;\n}\n\n.player-card .position {\n    color: #aaa;\n    font-size: 0.9em;\n    font-weight: 700;\n    text-transform: uppercase;\n}\n\n/* Team Tabs */\n.team-tabs {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 30px;\n    border-bottom: 2px solid rgba(255, 237, 0, 0.3);\n    padding-bottom: 10px;\n}\n\n.team-tab {\n    background: transparent;\n    border: none;\n    color: #fff;\n    padding: 12px 25px;\n    font-size: 1.1em;\n    font-weight: bold;\n    cursor: pointer;\n    transition: all 0.3s;\n    border-radius: 8px 8px 0 0;\n    position: relative;\n}\n\n.team-tab:hover {\n    background: rgba(255, 237, 0, 0.1);\n    color: var(--secondary);\n}\n\n.team-tab.active {\n    background: rgba(0, 20, 220, 0.4);\n    color: var(--secondary);\n    border-bottom: 3px solid var(--secondary);\n}\n\n.team-tab-content {\n    display: none;\n}\n\n.team-tab-content.active {\n    display: block;\n}\n\n/* Modal */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 2000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0,0,0,0.7);\n    animation: fadeIn 0.3s;\n}\n\n.modal.active {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.modal-content {\n    background: #000033;\n    border-radius: 15px;\n    padding: 30px;\n    max-width: 500px;\n    width: 90%;\n    max-height: 80vh;\n    overflow-y: auto;\n    position: relative;\n}\n\n.close {\n    position: absolute;\n    right: 20px;\n    top: 15px;\n    font-size: 2em;\n    cursor: pointer;\n    color: #999;\n}\n\n.close:hover {\n    color: #333;\n}\n\n/* Players Header */\n.players-header {\n    background: rgba(0, 20, 220, 0.5);\n    border-radius: 15px;\n    padding: 30px;\n    margin-bottom: 20px;\n    box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n    border: 2px solid rgba(255, 237, 0, 0.3);\n}\n\n.players-header h2 {\n    color: var(--secondary);\n    margin-bottom: 20px;\n    font-weight: 900;\n    text-transform: uppercase;\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n    .top-bar-right {\n        flex-wrap: wrap;\n        gap: 10px;\n    }\n    \n    .currency-display {\n        order: 3;\n        width: 100%;\n        justify-content: center;\n    }\n    \n    .game-modes {\n        grid-template-columns: 1fr;\n        max-width: 300px;\n    }\n    \n    .mode-icon {\n        font-size: 2.5em;\n    }\n    \n    .mode-label {\n        font-size: 1em;\n    }\n    \n    .banner-title {\n        font-size: 1.5em;\n    }\n    \n    .banner-description {\n        font-size: 0.95em;\n    }\n    \n    /* Inbox page responsive */\n    .inbox-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n    \n    .inbox-title {\n        font-size: 2em;\n        text-align: center;\n    }\n    \n    .btn-claim-all {\n        width: 100%;\n    }\n    \n    .inbox-item {\n        flex-direction: row;\n        gap: 15px;\n        padding: 15px;\n    }\n    \n    .inbox-icon {\n        width: 60px;\n        height: 60px;\n        font-size: 2em;\n    }\n    \n    .inbox-meta {\n        min-width: auto;\n        text-align: left;\n        width: 100%;\n    }\n    \n    .inbox-item {\n        flex-wrap: wrap;\n    }\n    \n    .inbox-content {\n        flex: 1 1 100%;\n    }\n    \n    /* News page responsive */\n    .news-title {\n        font-size: 2em;\n    }\n    \n    .news-item {\n        flex-wrap: wrap;\n        padding: 15px;\n    }\n    \n    .news-icon {\n        width: 60px;\n        height: 60px;\n        font-size: 1.5em;\n    }\n    \n    .news-date {\n        width: 100%;\n        text-align: left;\n        margin-top: 10px;\n        font-size: 0.85em;\n    }\n    \n    .news-modal-content {\n        width: 95%;\n        max-height: 90vh;\n    }\n    \n    .news-modal-title {\n        font-size: 1.5em;\n        margin: 0 20px 15px 20px;\n    }\n    \n    .news-modal-body {\n        padding: 0 20px 20px 20px;\n        font-size: 1em;\n    }\n    \n    .news-modal-close {\n        width: 40px;\n        height: 40px;\n        font-size: 1.2em;\n    }\n}\n\n@media (max-width: 768px) {\n    .nav-menu {\n        display: none;\n    }\n    \n    .stats-grid {\n        grid-template-columns: 1fr 1fr;\n    }\n    \n    .squad-pitch {\n        padding: 20px 10px;\n    }\n    \n    .player-slot {\n        min-width: 80px;\n        padding: 10px;\n        font-size: 0.85em;\n    }\n}\n","size_bytes":40090},"commands/admin.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('admin')\n        .setDescription('Admin commands (Server Owner only)')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('givecurrency')\n                .setDescription('Give currency to a user')\n                .addStringOption(option =>\n                    option.setName('currency')\n                        .setDescription('Currency type')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'GP', value: 'gp' },\n                            { name: 'eCoins', value: 'ecoins' }\n                        ))\n                .addIntegerOption(option =>\n                    option.setName('amount')\n                        .setDescription('Amount to give')\n                        .setRequired(true)\n                        .setMinValue(1))\n                .addUserOption(option =>\n                    option.setName('user')\n                        .setDescription('User to give currency to (optional)')))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('giftpenaltypack')\n                .setDescription('Gift a free penalty minigame pack to a user')\n                .addUserOption(option =>\n                    option.setName('user')\n                        .setDescription('User to gift the pack to (optional)')))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('giftsplustrainer')\n                .setDescription('Gift an S+ Trainer (+1,000,000 EXP) to a user via Mail')\n                .addUserOption(option =>\n                    option.setName('user')\n                        .setDescription('User to gift the trainer to (optional)'))),\n    async execute(interaction) {\n        const { client } = interaction;\n        // Only allow the BOT OWNER to use admin commands\n        const botOwnerId = client.botOwnerId || process.env.BOT_OWNER_ID || null;\n        if (!botOwnerId || interaction.user.id !== botOwnerId) {\n            return await interaction.reply({ content: \"‚õî You don't have access to this command.\", ephemeral: true });\n        }\n\n        const subcommand = interaction.options.getSubcommand();\n\n        if (subcommand === 'givecurrency') {\n            await giveCurrency(interaction);\n        } else if (subcommand === 'giftpenaltypack') {\n            await giftPenaltyPack(interaction);\n        } else if (subcommand === 'giftsplustrainer') {\n            await giftSpluTrainer(interaction);\n        }\n    },\n};\n\nasync function giveCurrency(interaction) {\n    const { client } = interaction;\n    const currencyType = interaction.options.getString('currency');\n    const amount = interaction.options.getInteger('amount');\n    const targetUser = interaction.options.getUser('user') || interaction.user;\n\n    const userData = client.getUserData(targetUser.id);\n\n    if (currencyType === 'gp') {\n        userData.gp += amount;\n        await interaction.reply({ content: `Gave ${amount.toLocaleString()} GP to ${targetUser.username}.` });\n    } else if (currencyType === 'ecoins') {\n        userData.eCoins += amount;\n        await interaction.reply({ content: `Gave ${amount.toLocaleString()} eCoins to ${targetUser.username}.` });\n    }\n\n    client.setUserData(targetUser.id, userData);\n}\n\nfunction todayKey() {\n    const d = new Date();\n    return d.toISOString().slice(0, 10);\n}\n\nasync function giftPenaltyPack(interaction) {\n    const { client } = interaction;\n    const targetUser = interaction.options.getUser('user') || interaction.user;\n\n    const userData = client.getUserData(targetUser.id);\n    if (!userData.mail) userData.mail = [];\n\n    const rarities = ['Iconic', 'Legend', 'Black'];\n    const rarity = rarities[Math.floor(Math.random() * rarities.length)];\n\n    userData.mail.push({\n        id: Math.random().toString(36).slice(2, 10),\n        type: 'pack',\n        rarity,\n        qty: 1,\n        date: todayKey(),\n    });\n\n    client.setUserData(targetUser.id, userData);\n\n    await interaction.reply({ content: `üéÅ Gifted a free **${rarity} Pack** to ${targetUser.username}'s mail.` });\n}\n\nasync function giftSpluTrainer(interaction) {\n    const { client } = interaction;\n    const targetUser = interaction.options.getUser('user') || interaction.user;\n\n    const userData = client.getUserData(targetUser.id);\n    if (!Array.isArray(userData.mail)) userData.mail = [];\n\n    userData.mail.push({\n        id: Math.random().toString(36).slice(2, 10),\n        type: 'trainer',\n        trainerName: 'S+ Trainer',\n        exp: 1000000,\n        date: todayKey(),\n    });\n\n    client.setUserData(targetUser.id, userData);\n\n    await interaction.reply({ content: `üßë‚Äçüè´ Gifted **S+ Trainer** (+1,000,000 EXP) to ${targetUser.username}'s mail.` });\n}\n","size_bytes":4884},"public/contracts.js":{"content":"// Global state\nlet userData = null;\nlet allPlayers = [];\nlet ownedPlayerIds = [];\nlet currentPack = null;\nlet filteredPlayers = [];\n\nconst PACK_EMOJIS = {\n    'iconic': 'üíé',\n    'legend': 'üèÜ',\n    'standard': 'üì¶'\n};\n\nconst RARITY_EMOJIS = {\n    'Iconic': 'üíé',\n    'Legend': 'üåü',\n    'Black': '‚ö´',\n    'Gold': 'üü°',\n    'Silver': '‚ö™',\n    'Bronze': 'üü§',\n    'White': '‚¨ú'\n};\n\n// Initialize\nasync function init() {\n    await loadUserData();\n    await loadAllPlayers();\n    await loadPacks();\n    renderPackSelector();\n    document.getElementById('loading').style.display = 'none';\n}\n\n// Load user data\nasync function loadUserData() {\n    try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        userData = data;\n        \n        // Update UI\n        document.getElementById('username').textContent = data.discord.username;\n        document.getElementById('userAvatar').src = `https://cdn.discordapp.com/avatars/${data.discord.id}/${data.discord.avatar}.png`;\n        \n        // Get owned player IDs\n        if (data.gameData && data.gameData.players) {\n            ownedPlayerIds = data.gameData.players.map(p => p.id);\n        }\n    } catch (error) {\n        console.error('Error loading user data:', error);\n    }\n}\n\n// Load all players\nasync function loadAllPlayers() {\n    try {\n        const response = await fetch('/api/all-players');\n        const data = await response.json();\n        allPlayers = data.players || [];\n    } catch (error) {\n        console.error('Error loading all players:', error);\n    }\n}\n\n// Load pack data\nasync function loadPacks() {\n    try {\n        const response = await fetch('/api/packs');\n        const data = await response.json();\n        window.packsData = data.packs || {};\n    } catch (error) {\n        console.error('Error loading packs:', error);\n        // Fallback to hardcoded packs if API fails\n        window.packsData = {\n            'iconic': {\n                name: 'Iconic Moment Pack',\n                cost: 500,\n                currency: 'eCoins',\n                description: 'A special pack containing players of all rarities, with a chance to get an Iconic Moment player!',\n                rarity_chances: {\n                    'Iconic': 0.01,\n                    'Legend': 0.03,\n                    'Black': 0.10,\n                    'Gold': 0.20,\n                    'Silver': 0.30,\n                    'Bronze': 0.26,\n                    'White': 0.10\n                }\n            },\n            'legend': {\n                name: 'Legend Box Draw',\n                cost: 25000,\n                currency: 'GP',\n                description: 'A box draw with a chance to get a Legend player!',\n                rarity_chances: {\n                    'Legend': 0.05,\n                    'Black': 0.15,\n                    'Gold': 0.25,\n                    'Silver': 0.35,\n                    'Bronze': 0.20,\n                    'White': 0.00\n                }\n            },\n            'standard': {\n                name: 'Standard Pack',\n                cost: 10000,\n                currency: 'GP',\n                description: 'A standard pack containing players from Black to White rarity.',\n                rarity_chances: {\n                    'Black': 0.05,\n                    'Gold': 0.20,\n                    'Silver': 0.40,\n                    'Bronze': 0.25,\n                    'White': 0.10\n                }\n            }\n        };\n    }\n}\n\n// Render pack selector\nfunction renderPackSelector() {\n    const container = document.getElementById('packSelector');\n    container.innerHTML = '';\n    \n    for (const [packKey, pack] of Object.entries(window.packsData)) {\n        const packCard = document.createElement('div');\n        packCard.className = 'pack-card';\n        packCard.onclick = () => selectPack(packKey);\n        \n        const emoji = PACK_EMOJIS[packKey] || 'üì¶';\n        \n        packCard.innerHTML = `\n            <div class=\"pack-icon\">${emoji}</div>\n            <div class=\"pack-name\">${pack.name}</div>\n            <div class=\"pack-cost\">${pack.cost.toLocaleString()} ${pack.currency}</div>\n            <div class=\"pack-description\">${pack.description}</div>\n        `;\n        \n        container.appendChild(packCard);\n    }\n}\n\n// Select a pack\nfunction selectPack(packKey) {\n    currentPack = packKey;\n    \n    // Update active state\n    document.querySelectorAll('.pack-card').forEach((card, index) => {\n        const keys = Object.keys(window.packsData);\n        if (keys[index] === packKey) {\n            card.classList.add('active');\n        } else {\n            card.classList.remove('active');\n        }\n    });\n    \n    // Show pack details\n    renderPackDetails(packKey);\n    \n    // Filter and show players\n    filterAndRenderPlayers();\n    \n    document.getElementById('packDetailsContainer').style.display = 'block';\n}\n\n// Render pack details\nfunction renderPackDetails(packKey) {\n    const pack = window.packsData[packKey];\n    const container = document.getElementById('packDetails');\n    \n    let rarityHTML = '';\n    for (const [rarity, chance] of Object.entries(pack.rarity_chances)) {\n        if (chance > 0) {\n            const emoji = RARITY_EMOJIS[rarity] || '';\n            const percentage = (chance * 100).toFixed(1);\n            rarityHTML += `\n                <div class=\"rarity-item\">\n                    <div class=\"rarity-name\">${emoji} ${rarity}</div>\n                    <div class=\"rarity-chance\">${percentage}%</div>\n                </div>\n            `;\n        }\n    }\n    \n    container.innerHTML = `\n        <h3>${PACK_EMOJIS[packKey]} ${pack.name}</h3>\n        <p style=\"color: #ccc; margin-bottom: 15px;\">${pack.description}</p>\n        <p style=\"color: var(--secondary); font-size: 1.2em; font-weight: bold;\">Cost: ${pack.cost.toLocaleString()} ${pack.currency}</p>\n        <h4 style=\"color: #fff; margin-top: 20px; margin-bottom: 10px;\">Drop Rates:</h4>\n        <div class=\"rarity-chances\">\n            ${rarityHTML}\n        </div>\n    `;\n}\n\n// Filter and render players\nfunction filterAndRenderPlayers() {\n    if (!currentPack) return;\n    \n    const pack = window.packsData[currentPack];\n    const searchTerm = document.getElementById('playerSearch').value.toLowerCase();\n    const rarityFilter = document.getElementById('rarityFilter').value;\n    const ownedFilter = document.getElementById('ownedFilter').value;\n    \n    // Get available rarities in this pack\n    const availableRarities = Object.keys(pack.rarity_chances).filter(r => pack.rarity_chances[r] > 0);\n    \n    // Filter players\n    filteredPlayers = allPlayers.filter(player => {\n        // Must be in pack's available rarities\n        if (!availableRarities.includes(player.rarity)) return false;\n        \n        // Search filter\n        if (searchTerm && !player.name.toLowerCase().includes(searchTerm)) return false;\n        \n        // Rarity filter\n        if (rarityFilter && player.rarity !== rarityFilter) return false;\n        \n        // Owned filter\n        const isOwned = ownedPlayerIds.includes(player.id);\n        if (ownedFilter === 'owned' && !isOwned) return false;\n        if (ownedFilter === 'not-owned' && isOwned) return false;\n        \n        return true;\n    });\n    \n    // Update stats\n    updateStats();\n    \n    // Render players\n    renderPlayers();\n}\n\n// Update statistics\nfunction updateStats() {\n    const pack = window.packsData[currentPack];\n    const availableRarities = Object.keys(pack.rarity_chances).filter(r => pack.rarity_chances[r] > 0);\n    \n    const totalInPack = allPlayers.filter(p => availableRarities.includes(p.rarity)).length;\n    const ownedInPack = allPlayers.filter(p => availableRarities.includes(p.rarity) && ownedPlayerIds.includes(p.id)).length;\n    const notOwnedInPack = totalInPack - ownedInPack;\n    const collectionPercent = totalInPack > 0 ? ((ownedInPack / totalInPack) * 100).toFixed(1) : 0;\n    \n    document.getElementById('playerCount').textContent = filteredPlayers.length;\n    document.getElementById('totalPlayers').textContent = totalInPack;\n    document.getElementById('ownedPlayers').textContent = ownedInPack;\n    document.getElementById('notOwnedPlayers').textContent = notOwnedInPack;\n    document.getElementById('collectionPercent').textContent = collectionPercent + '%';\n}\n\n// Render players\nfunction renderPlayers() {\n    const container = document.getElementById('playersGrid');\n    container.innerHTML = '';\n    \n    if (filteredPlayers.length === 0) {\n        container.innerHTML = '<p style=\"color: #999; padding: 20px; grid-column: 1/-1; text-align: center;\">No players found</p>';\n        return;\n    }\n    \n    filteredPlayers.forEach(player => {\n        const isOwned = ownedPlayerIds.includes(player.id);\n        const card = document.createElement('div');\n        card.className = `contract-player-card ${isOwned ? 'owned' : ''}`;\n        card.dataset.rarity = player.rarity;\n        card.onclick = () => showPlayerDetails(player);\n        card.style.cursor = 'pointer';\n        \n        // Sanitize player name for image\n        const playerImageName = player.name.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase().replace(/_+/g, '_').replace(/_+$/g, '');\n        const playerImagePng = `/assets/faces/${playerImageName}.png`;\n        const playerImageJpg = `/assets/faces/${playerImageName}.jpg`;\n        \n        card.innerHTML = `\n            <div class=\"player-image-container\">\n                <div class=\"player-overall\">${player.overall}</div>\n                <div class=\"player-position\">${player.position}</div>\n                <img src=\"${playerImagePng}\" alt=\"${player.name}\" \n                     onerror=\"this.onerror=null; this.src='${playerImageJpg}'; this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n            </div>\n            <div class=\"player-rarity\">${RARITY_EMOJIS[player.rarity] || '‚öΩ'}</div>\n            <div class=\"player-name\" title=\"${player.name}\">${player.name}</div>\n        `;\n        \n        container.appendChild(card);\n    });\n}\n\n// Show player details modal\nfunction showPlayerDetails(player) {\n    const modal = document.getElementById('playerModal');\n    const content = document.getElementById('playerModalContent');\n    \n    const stats = player.stats || {};\n    const isOwned = ownedPlayerIds.includes(player.id);\n    \n    content.innerHTML = `\n        <h2>${RARITY_EMOJIS[player.rarity] || '‚öΩ'} ${player.name}</h2>\n        ${isOwned ? '<p style=\"color: #27ae60; font-weight: bold;\">‚úì You own this player</p>' : '<p style=\"color: #999;\">You don\\'t own this player yet</p>'}\n        <div style=\"margin: 20px 0;\">\n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;\">\n                <div><strong>Overall:</strong> ${player.overall}</div>\n                <div><strong>Position:</strong> ${player.position}</div>\n                <div><strong>Rarity:</strong> ${player.rarity}</div>\n                <div><strong>Style:</strong> ${player.playingStyle || 'N/A'}</div>\n            </div>\n            \n            <h3 style=\"color: var(--primary); margin: 20px 0 10px 0;\">Stats</h3>\n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 10px;\">\n                <div>‚öîÔ∏è Attacking: ${stats.attacking || 0}</div>\n                <div>üéØ Dribbling: ${stats.dribbling || 0}</div>\n                <div>üéØ Passing: ${stats.passing || 0}</div>\n                <div>üõ°Ô∏è Defending: ${stats.defending || 0}</div>\n                <div>üí™ Physicality: ${stats.physicality || 0}</div>\n                <div>üß§ Goalkeeping: ${stats.goalkeeping || 0}</div>\n            </div>\n            \n            ${player.skills && player.skills.length > 0 ? `\n                <h3 style=\"color: var(--primary); margin: 20px 0 10px 0;\">Skills</h3>\n                <div style=\"color: #666;\">${player.skills.slice(0, 5).join(', ')}</div>\n            ` : ''}\n        </div>\n    `;\n    \n    modal.classList.add('active');\n    modal.style.display = 'flex';\n}\n\n// Close modal\nfunction closeModal() {\n    const modal = document.getElementById('playerModal');\n    modal.classList.remove('active');\n    modal.style.display = 'none';\n}\n\n// Event listeners\ndocument.getElementById('playerSearch').addEventListener('input', filterAndRenderPlayers);\ndocument.getElementById('rarityFilter').addEventListener('change', filterAndRenderPlayers);\ndocument.getElementById('ownedFilter').addEventListener('change', filterAndRenderPlayers);\n\n// Close modal on outside click\nwindow.onclick = function(event) {\n    const modal = document.getElementById('playerModal');\n    if (event.target === modal) {\n        closeModal();\n    }\n}\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', init);\n","size_bytes":12784},"FINAL_DUPLICATE_FIX.md":{"content":"# üîß FINAL Duplicate Bug Fix - Complete Solution\n\n## üêõ **The Problem:**\n\n### **Symptoms:**\n- Brenna Renner appears **3 times** in CMF positions\n- Troy Gorczany-Moscicki appears **3 times** in CMF positions\n- Casandra Prosacco appears **2 times** in CB positions\n\n### **Root Causes:**\n\n1. **Existing Data Had Duplicates**\n   - The saved squad JSON file already contained duplicate player IDs\n   - Loading the squad just displayed what was saved\n\n2. **Weak Duplicate Detection**\n   - Checking arrays with `null` values caused false matches\n   - `.indexOf()` on arrays with nulls returned incorrect results\n\n3. **No Cleanup on Load**\n   - System never cleaned up existing duplicates\n   - Just displayed whatever was in the file\n\n---\n\n## ‚úÖ **Complete Fix Applied:**\n\n### **1. Auto-Cleanup on Load**\n\nWhen the squad is loaded from the server, it now automatically removes duplicates:\n\n```javascript\nasync function loadSquad() {\n    // Load squad from server\n    const response = await fetch('/api/squad');\n    currentSquad = data.squad;\n    \n    // CRITICAL: Clean up duplicates\n    const hadDuplicates = cleanupDuplicates();\n    \n    // If duplicates found, auto-save cleaned data\n    if (hadDuplicates) {\n        await saveSquad(true); // Silent save\n    }\n}\n```\n\n### **2. Smart Cleanup Function**\n\n```javascript\nfunction cleanupDuplicates() {\n    const seenIds = new Set();\n    const cleanMain = [];\n    let foundDuplicates = false;\n    \n    // For each position in main squad\n    for (let i = 0; i < currentSquad.main.length; i++) {\n        const playerId = currentSquad.main[i];\n        \n        if (playerId === null) {\n            cleanMain.push(null); // Keep empty slots\n        } else if (!seenIds.has(playerId)) {\n            seenIds.add(playerId);\n            cleanMain.push(playerId); // First occurrence - keep it\n        } else {\n            cleanMain.push(null); // Duplicate - remove it\n            foundDuplicates = true;\n        }\n    }\n    \n    // Clean bench too\n    const cleanBench = [];\n    for (const playerId of currentSquad.bench) {\n        if (playerId && !seenIds.has(playerId)) {\n            seenIds.add(playerId);\n            cleanBench.push(playerId);\n        } else if (playerId) {\n            foundDuplicates = true; // Duplicate in bench\n        }\n    }\n    \n    // Update with cleaned data\n    currentSquad.main = cleanMain;\n    currentSquad.bench = cleanBench.slice(0, 8);\n    \n    return foundDuplicates;\n}\n```\n\n### **3. Silent Auto-Save**\n\nAfter cleaning, the system automatically saves without bothering the user:\n\n```javascript\nasync function saveSquad(silent = false) {\n    // Save to server\n    const response = await fetch('/api/squad/update', {\n        method: 'POST',\n        body: JSON.stringify({ squad: currentSquad })\n    });\n    \n    if (result.success) {\n        if (!silent) {\n            alert('‚úÖ Squad saved successfully!');\n        } else {\n            console.log('‚úÖ Squad auto-saved after cleanup');\n        }\n    }\n}\n```\n\n### **4. Strict Duplicate Prevention**\n\nAll add/drag functions now use strict checking:\n\n```javascript\n// Filter out nulls BEFORE checking\nconst inSquad = currentSquad.main.filter(id => id !== null).indexOf(playerId);\nconst inBench = currentSquad.bench.filter(id => id !== null).indexOf(playerId);\n\nif (inSquad !== -1) {\n    alert('‚ö†Ô∏è This player is already in your squad!');\n    return; // BLOCK\n}\n```\n\n### **5. 8-Player Bench Limit**\n\n```javascript\nif (currentSquad.bench.length >= 8) {\n    alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n    return; // BLOCK\n}\n```\n\n---\n\n## üéØ **How It Works:**\n\n### **Step 1: Page Load**\n```\n1. User opens dashboard\n2. System loads squad from server\n3. cleanupDuplicates() runs automatically\n4. Finds: Brenna x3, Troy x3, Casandra x2\n5. Keeps first occurrence of each\n6. Removes duplicates (replaces with null)\n7. Auto-saves cleaned squad\n8. Displays clean squad\n```\n\n### **Step 2: User Interaction**\n```\nUser tries to add duplicate:\n‚Üí Strict check catches it\n‚Üí Alert shown\n‚Üí Action blocked\n‚Üí No duplicate created\n```\n\n### **Step 3: Ongoing Protection**\n```\nEvery action checks:\n- Is player in squad? (excluding nulls)\n- Is player on bench? (excluding nulls)\n- Is bench full? (max 8)\n‚Üí Blocks if any condition fails\n```\n\n---\n\n## üîÑ **What Happens Now:**\n\n### **Scenario 1: First Load After Fix**\n```\n1. Page loads\n2. Sees Brenna x3 in squad data\n3. Console: \"Duplicate player found at position 5, removing...\"\n4. Console: \"Duplicate player found at position 6, removing...\"\n5. Console: \"Squad cleaned - duplicates removed\"\n6. Console: \"Squad auto-saved after cleanup\"\n7. Displays: Brenna x1 only\n8. Other positions: Empty (null)\n```\n\n### **Scenario 2: Try to Add Duplicate**\n```\n1. User clicks CMF position\n2. Tries to add \"Brenna Renner\"\n3. System checks: Brenna already at CMF position 4\n4. Alert: \"‚ö†Ô∏è This player is already in your squad at another position!\"\n5. Action blocked\n6. No duplicate created\n```\n\n### **Scenario 3: Move Player**\n```\n1. User drags Brenna from CMF-4 to CMF-5\n2. System removes from position 4 (null)\n3. System adds to position 5\n4. Result: Brenna x1 at position 5\n5. No duplicate\n```\n\n---\n\n## üß™ **Testing Steps:**\n\n### **Test 1: Load Page**\n1. Open browser console (F12)\n2. Refresh dashboard page\n3. Look for console messages:\n   - \"Duplicate player found...\" (if duplicates exist)\n   - \"Squad cleaned - duplicates removed\"\n   - \"Squad auto-saved after cleanup\"\n4. Check pitch - each player should appear once only\n\n### **Test 2: Try Adding Duplicate**\n1. Note which players are in squad\n2. Try to add same player to different position\n3. Should see alert: \"This player is already in your squad!\"\n4. Action should be blocked\n\n### **Test 3: Fill Bench**\n1. Add 8 players to bench\n2. Try to add 9th player\n3. Should see alert: \"Bench is full! Maximum 8 players allowed.\"\n4. Action should be blocked\n\n### **Test 4: Save & Reload**\n1. Make changes to squad\n2. Click \"Save Squad\"\n3. Refresh page\n4. Squad should load exactly as saved\n5. No duplicates should appear\n\n---\n\n## üìä **Before vs After:**\n\n### **Before (Broken):**\n```json\n{\n  \"main\": [\n    \"player123\",  // Brenna\n    \"player456\",  // Troy\n    \"player123\",  // Brenna (DUPLICATE!)\n    \"player456\",  // Troy (DUPLICATE!)\n    \"player123\",  // Brenna (DUPLICATE!)\n    \"player456\"   // Troy (DUPLICATE!)\n  ]\n}\n```\n\n### **After (Fixed):**\n```json\n{\n  \"main\": [\n    \"player123\",  // Brenna (kept)\n    \"player456\",  // Troy (kept)\n    null,         // Duplicate removed\n    null,         // Duplicate removed\n    null,         // Duplicate removed\n    null          // Duplicate removed\n  ]\n}\n```\n\n---\n\n## ‚úÖ **What's Protected:**\n\n1. ‚úÖ **Load from server** - Auto-cleans duplicates\n2. ‚úÖ **Click to add** - Blocks duplicates\n3. ‚úÖ **Drag from available** - Blocks duplicates\n4. ‚úÖ **Drag between positions** - Moves (not duplicates)\n5. ‚úÖ **Drag to bench** - Checks duplicates\n6. ‚úÖ **Drag from bench** - Checks duplicates\n7. ‚úÖ **Replace player** - Checks bench limit\n8. ‚úÖ **Auto-save** - Persists clean data\n\n---\n\n## üéâ **Result:**\n\n### **Immediate:**\n- Refresh page ‚Üí Duplicates automatically removed\n- Console shows cleanup process\n- Clean squad displayed\n- Auto-saved to server\n\n### **Ongoing:**\n- Cannot add duplicates (blocked with alert)\n- Cannot exceed 8 bench players\n- All drag/drop protected\n- Data stays clean\n\n---\n\n## üöÄ **Action Required:**\n\n1. **Refresh your browser** (Ctrl+F5 or Cmd+Shift+R)\n2. **Open console** (F12) to see cleanup messages\n3. **Check squad** - duplicates should be gone\n4. **Try to add duplicate** - should be blocked\n5. **Save squad** - clean data persists\n\n---\n\n**The duplicate bug is now COMPLETELY FIXED with automatic cleanup!** üéâ‚öΩ\n\n**Just refresh your browser and the duplicates will disappear!**\n","size_bytes":7801},"commands/contract2.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\nconst players = require('../players.json');\nconst config = require('../config.json');\n\n// --- Contract Configuration ---\nconst PACKS = {\n  'iconic': {\n    name: 'Iconic Moment Pack',\n    cost: 500,\n    currency: 'eCoins',\n    description: 'A special pack containing players of all rarities, with a chance to get an Iconic Moment player!',\n    rarity_chances: {\n      'Iconic': 0.01,\n      'Legend': 0.03,\n      'Black': 0.10,\n      'Gold': 0.20,\n      'Silver': 0.30,\n      'Bronze': 0.26,\n      'White': 0.10,\n    }\n  },\n  'legend': {\n    name: 'Legend Box Draw',\n    cost: 25000,\n    currency: 'GP',\n    description: 'A box draw with a chance to get a Legend player!',\n    rarity_chances: {\n      'Legend': 0.05,\n      'Black': 0.15,\n      'Gold': 0.25,\n      'Silver': 0.35,\n      'Bronze': 0.20,\n      'White': 0.00,\n    }\n  },\n  'standard': {\n    name: 'Standard Pack',\n    cost: 10000,\n    currency: 'GP',\n    description: 'A standard pack containing players from Black to White rarity.',\n    rarity_chances: {\n      'Black': 0.05,\n      'Gold': 0.20,\n      'Silver': 0.40,\n      'Bronze': 0.25,\n      'White': 0.10,\n    }\n  }\n};\n\nconst RARITY_SELL_VALUE = {\n  'Iconic': 50000,\n  'Legend': 25000,\n  'Black': 10000,\n  'Gold': 5000,\n  'Silver': 2500,\n  'Bronze': 1000,\n  'White': 500,\n};\n\nconst RARITY_COLORS = {\n  'Iconic': '#FF00FF',\n  'Legend': '#FFD700',\n  'Black': '#000000',\n  'Gold': '#FFC300',\n  'Silver': '#C0C0C0',\n  'Bronze': '#CD7F32',\n  'White': '#FFFFFF',\n};\n\nconst RARITY_EMOJIS = {\n  'Iconic': 'üíé',\n  'Legend': 'üåü',\n  'Black': '‚ö´',\n  'Gold': 'üü°',\n  'Silver': '‚ö™',\n  'Bronze': 'üü§',\n  'White': '‚¨ú',\n};\n\nconst PACK_EMOJIS = {\n  'iconic': 'üíé',\n  'legend': 'üèÜ',\n  'standard': 'üì¶',\n};\n\n// Animation messages for pack opening\nconst PACK_OPENING_MESSAGES = [\n  \"üéÅ Opening pack...\",\n];\n\nfunction selectRarity(chances) {\n  const rand = Math.random();\n  let cumulative = 0;\n  for (const rarity in chances) {\n    cumulative += chances[rarity];\n    if (rand < cumulative) return rarity;\n  }\n  return Object.keys(chances)[Object.keys(chances).length - 1];\n}\n\nfunction pullPlayer(rarity) {\n  const filteredPlayers = players.filter(p => p.rarity === rarity);\n  if (filteredPlayers.length === 0) return null;\n  return filteredPlayers[Math.floor(Math.random() * filteredPlayers.length)];\n}\n\nfunction getRarityGif(rarity) {\n  const lower = String(rarity || '').toLowerCase();\n  const filename = `${lower}.gif`;\n  const filePath = path.join(__dirname, '..', 'assets', 'gifs', filename);\n  if (fs.existsSync(filePath)) {\n    return { type: 'attachment', filename, filePath };\n  }\n  const url = config?.contractGifs?.[rarity] || config?.gachaGifs?.[rarity];\n  if (url) return { type: 'url', url };\n  return null;\n}\n\nfunction getPackOpeningGif(packName) {\n  const filename = `pack_${packName}.gif`;\n  const filePath = path.join(__dirname, '..', 'assets', 'gifs', filename);\n  if (fs.existsSync(filePath)) {\n    return { type: 'attachment', filename, filePath };\n  }\n  // Fallback to generic pack opening gif\n  const genericPath = path.join(__dirname, '..', 'assets', 'gifs', 'pack_opening.gif');\n  if (fs.existsSync(genericPath)) {\n    return { type: 'attachment', filename: 'pack_opening.gif', filePath: genericPath };\n  }\n  return null;\n}\n\nfunction getHighestRarity(pullResults) {\n  const rarityPriority = { 'Iconic': 7, 'Legend': 6, 'Black': 5, 'Gold': 4, 'Silver': 3, 'Bronze': 2, 'White': 1 };\n  let highest = 'White';\n  let highestPriority = 0;\n  \n  pullResults.forEach(result => {\n    const priority = rarityPriority[result.player.rarity] || 0;\n    if (priority > highestPriority) {\n      highestPriority = priority;\n      highest = result.player.rarity;\n    }\n  });\n  \n  return highest;\n}\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('contract2')\n    .setDescription('Pull up to 10 players at once with animated pack opening')\n    .addStringOption(option =>\n      option.setName('pack')\n        .setDescription('Choose a contract pack')\n        .setRequired(true)\n        .addChoices(\n          { name: 'Iconic Moment Pack (500 eCoins)', value: 'iconic' },\n          { name: 'Legend Box Draw (25,000 GP)', value: 'legend' },\n          { name: 'Standard Pack (10,000 GP)', value: 'standard' }\n        ))\n    .addIntegerOption(option =>\n      option.setName('count')\n        .setDescription('Number of pulls (1-10)')\n        .setRequired(true)\n        .setMinValue(1)\n        .setMaxValue(10)\n    ),\n\n  async execute(interaction) {\n    try {\n      const { client } = interaction;\n      const userData = client.getUserData(interaction.user.id);\n\n      // Initialize missing properties\n      if (!userData.players) userData.players = [];\n      if (typeof userData.gp !== 'number') userData.gp = 0;\n      if (typeof userData.eCoins !== 'number') userData.eCoins = 0;\n\n      const packName = interaction.options.getString('pack');\n      const count = interaction.options.getInteger('count');\n      const pack = PACKS[packName];\n\n      if (!pack) {\n        return await interaction.reply({ content: 'That pack does not exist.', ephemeral: true });\n      }\n\n      const totalCost = pack.cost * count;\n\n      // Check currency\n      if (pack.currency === 'GP') {\n        if (userData.gp < totalCost) {\n          return await interaction.reply({ \n            content: `Not enough GP. You need ${totalCost.toLocaleString()} GP for ${count} pull(s).`, \n            ephemeral: true \n          });\n        }\n      } else {\n        if (userData.eCoins < totalCost) {\n          return await interaction.reply({ \n            content: `Not enough eCoins. You need ${totalCost.toLocaleString()} eCoins for ${count} pull(s).`, \n            ephemeral: true \n          });\n        }\n      }\n\n      // Start pack opening animation\n      await interaction.reply({ content: \"üéÅ Preparing to open pack...\" });\n\n      // Process all pulls first (behind the scenes)\n      const pullResults = [];\n      let totalSellBack = 0;\n\n      for (let i = 0; i < count; i++) {\n        const targetRarity = selectRarity(pack.rarity_chances);\n        const newPlayer = pullPlayer(targetRarity);\n\n        if (!newPlayer) continue;\n\n        // Ensure player has unique ID\n        if (!newPlayer.id) {\n          newPlayer.id = `${newPlayer.name}_${Date.now()}_${Math.random().toString(36).slice(2)}`;\n        }\n\n        const isDuplicate = userData.players.some(p => p.id === newPlayer.id);\n        let footerText = '';\n\n        if (isDuplicate) {\n          const sellValue = RARITY_SELL_VALUE[newPlayer.rarity] || 500;\n          totalSellBack += sellValue;\n          footerText = `Duplicate sold for ${sellValue.toLocaleString()} GP.`;\n        } else {\n          footerText = 'New player added to your collection!';\n        }\n\n        pullResults.push({ player: newPlayer, footerText, isDuplicate });\n      }\n\n      // Get highest rarity pulled\n      const highestRarity = getHighestRarity(pullResults);\n      \n      // Show pack opening animation with highest rarity gif\n      const packOpeningGif = getPackOpeningGif(packName);\n      const highestRarityGif = getRarityGif(highestRarity);\n      \n      let animationFiles = [];\n      let animationEmbed = new EmbedBuilder()\n        .setTitle(`${PACK_EMOJIS[packName]} Opening ${pack.name}`)\n        .setDescription(`Opening ${count} pack(s)...`)\n        .setColor(RARITY_COLORS[highestRarity]);\n\n      // Use highest rarity gif for animation\n      if (highestRarityGif) {\n        if (highestRarityGif.type === 'attachment') {\n          animationEmbed.setImage(`attachment://${highestRarityGif.filename}`);\n          animationFiles.push({\n            attachment: highestRarityGif.filePath,\n            name: highestRarityGif.filename\n          });\n        } else if (highestRarityGif.type === 'url') {\n          animationEmbed.setImage(highestRarityGif.url);\n        }\n      }\n\n      // Show animation for different durations\n      await interaction.editReply({ \n        content: PACK_OPENING_MESSAGES[0], \n        embeds: [animationEmbed], \n        files: animationFiles \n      });\n\n      // Animation sequence\n      // Animation sequence - shorter delays to prevent timeout\n      for (let i = 1; i < PACK_OPENING_MESSAGES.length; i++) {\n        await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second intervals\n        animationEmbed.setDescription(`${PACK_OPENING_MESSAGES[i]}\\nHighest rarity: ${RARITY_EMOJIS[highestRarity]} ${highestRarity}`);\n        try {\n          await interaction.editReply({ \n            content: PACK_OPENING_MESSAGES[i], \n      embeds: [animationEmbed], \n      files: animationFiles \n    });\n  } catch (error) {\n    console.log('Edit reply error:', error);\n    break; // Exit animation loop if edit fails\n  }\n}\n\n// Final delay - shorter\nawait new Promise(resolve => setTimeout(resolve, 10000));\n\n      // Now deduct currency and process duplicates\n      if (pack.currency === 'GP') {\n        userData.gp -= totalCost;\n      } else {\n        userData.eCoins -= totalCost;\n      }\n\n      // Add new players and process duplicates\n      pullResults.forEach(result => {\n        if (!result.isDuplicate) {\n          userData.players.push(result.player);\n        } else {\n          const sellValue = RARITY_SELL_VALUE[result.player.rarity] || 500;\n          userData.gp += sellValue;\n        }\n      });\n\n      // Sort results by rarity priority\n      const rarityPriority = { 'Iconic': 7, 'Legend': 6, 'Black': 5, 'Gold': 4, 'Silver': 3, 'Bronze': 2, 'White': 1 };\n      pullResults.sort((a, b) => {\n        const priorityA = rarityPriority[a.player.rarity] || 0;\n        const priorityB = rarityPriority[b.player.rarity] || 0;\n        return priorityB - priorityA;\n      });\n\n      // Create result embeds\n      const embeds = [];\n      const filesMap = new Map();\n\n      pullResults.forEach((result, index) => {\n        const { player: newPlayer, footerText } = result;\n        const s = newPlayer.stats || {};\n        const skills = (newPlayer.skills || []).slice(0, 5).join(', ') || 'None';\n\n        const rarityEmoji = RARITY_EMOJIS[newPlayer.rarity] || '';\n        const embed = new EmbedBuilder()\n          .setTitle(`${rarityEmoji} Contract Result #${index + 1}`)\n          .setDescription(`You pulled **${newPlayer.name}**`)\n          .setColor(RARITY_COLORS[newPlayer.rarity] || '#0099ff')\n          .addFields(\n            { name: 'Rarity', value: `${rarityEmoji} ${newPlayer.rarity}`, inline: true },\n            { name: 'Overall', value: `üìä ${String(newPlayer.overall)}`, inline: true },\n            { name: 'Position', value: `üéØ ${newPlayer.position}`, inline: true },\n            { name: 'Playing Style', value: newPlayer.playingStyle || '‚Äî', inline: true },\n            { name: 'Skills', value: skills, inline: false },\n            { name: 'Stats', value: `Att ${s.attacking || 0} | Drib ${s.dribbling || 0} | Pass ${s.passing || 0} | Def ${s.defending || 0} | Phys ${s.physicality || 0} | GK ${s.goalkeeping || 0}`, inline: false }\n          )\n          .setFooter({ text: footerText });\n\n        // Don't attach the same gif again for results\n        embeds.push(embed);\n      });\n\n      client.setUserData(interaction.user.id, userData);\n\n      const packEmoji = PACK_EMOJIS[packName] || '';\n      const summary = `${packEmoji} **PACK OPENING COMPLETE!**\\nPack: ${pack.name} ‚Ä¢ Pulls: ${count} ‚Ä¢ Cost: ${totalCost.toLocaleString()} ${pack.currency}` + \n                     (totalSellBack > 0 ? ` ‚Ä¢ Duplicate GP earned: ${totalSellBack.toLocaleString()}` : '');\n\n      await interaction.editReply({ \n        content: summary, \n        embeds: embeds, \n        files: [] // Clear animation files\n      });\n\n    } catch (err) {\n      console.error('contract2 execute error:', err);\n      try {\n        if (interaction.deferred || interaction.replied) {\n          await interaction.editReply({ content: 'There was an error while executing this command!' });\n        } else {\n          await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });\n        }\n      } catch (e) {\n        console.error('Failed to send error message:', e);\n      }\n    }\n  }\n};\n","size_bytes":12259},"commands/help.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('help')\n        .setDescription('Displays a list of all available commands.'),\n    async execute(interaction) {\n        const helpEmbed = new EmbedBuilder()\n            .setTitle('eFotbal wannabe ‚Äî Commands')\n            .setDescription('Quick reference for available commands:')\n            .setColor('#0099ff')\n            .addFields(\n                { name: 'Core', value: [\n                    '`/profile` ‚Äî View your profile and balances',\n                    '`/collection` ‚Äî Browse your players with filters and pages',\n                    '`/leaderboard` ‚Äî View rankings',\n                    '`/news [page:<n>]` ‚Äî View latest game updates and news',\n                    '`/help` ‚Äî Show this help message'\n                ].join('\\n') },\n                { name: 'Contract', value: [\n                    '`/contract-info` ‚Äî View pack rates and info',\n                    '`/contract pack:<iconic|legend|standard>` ‚Äî Pull 1 player',\n                    '`/contract2 pack:<iconic|legend|standard> count:<1-10>` ‚Äî Multi-pull up to 10 players'\n                ].join('\\n') },\n                { name: 'Squad Management', value: [\n                    '`/squad view` ‚Äî View your current squad',\n                    '`/squad autoset` ‚Äî Auto-pick the best XI and bench',\n                    '`/squad set position:<1-11> player:<name>` ‚Äî Set a player in your XI',\n                    '`/squad remove position:<1-11>` ‚Äî Remove player from XI',\n                    '`/squad formation formation:<4-3-3|4-4-2|3-5-2|4-2-3-1>` ‚Äî Change formation',\n                    '`/squad bench action:<add|remove> player:<name>` ‚Äî Manage bench'\n                ].join('\\n') },\n                { name: 'Matches', value: [\n                    '`/match` ‚Äî Play a match vs AI for rewards',\n                    '`/pvp` ‚Äî Search for opponent (falls back to AI if no players found)'\n                ].join('\\n') },\n                { name: 'Training', value: [\n                    '`/training player player:<name> trainer:<type> amount:<n>` ‚Äî Train a player',\n                    '`/training convert player:<name>` ‚Äî Convert player to Training EXP item',\n                    '`/training info [player:<name>]` ‚Äî Show training info or center',\n                    '`/training shop` ‚Äî View training shop'\n                ].join('\\n') },\n                { name: 'Daily & Rewards', value: [\n                    '`/penalty status` ‚Äî View daily penalty progress',\n                    '`/penalty shoot` ‚Äî Take your daily penalty shot',\n                    '`/mail` ‚Äî View rewards and Claim All',\n                    '`/use pack:<Iconic|Legend|Black>` ‚Äî Open a free pack from inventory'\n                ].join('\\n') },\n                { name: 'Account', value: [\n                    '`/reset` ‚Äî Reset your account (confirmation required)'\n                ].join('\\n') }\n            )\n            .setFooter({ text: 'eFotbal wannabe | Have fun!' });\n\n        await interaction.reply({ embeds: [helpEmbed] });\n    },\n};\n","size_bytes":3175},"TEST_FIX.md":{"content":"# üß™ Test the Duplicate Fix\n\n## üîç **The Problem You Showed:**\n\n### **Website:**\n- Kenny Abshire: **3 times** ‚ùå\n- Lafayette Wolff: **2 times** ‚ùå\n\n### **Discord Bot:**\n- Kenny Abshire: **1 time** ‚úÖ\n- Lafayette Wolff: **1 time** ‚úÖ\n\n---\n\n## ‚úÖ **What I Fixed:**\n\n### **Issue:**\nThe cleanup function was running but **not re-rendering** the display. The data was cleaned in memory, but the old duplicates were still showing on screen.\n\n### **Solution:**\n```javascript\nasync function loadSquad() {\n    // 1. Load squad from server\n    currentSquad = data.squad;\n    \n    // 2. Clean up duplicates\n    const hadDuplicates = cleanupDuplicates();\n    \n    // 3. Auto-save if cleaned\n    if (hadDuplicates) {\n        await saveSquad(true);\n    }\n    \n    // 4. FORCE RE-RENDER (NEW!)\n    renderSquadPitch();\n    renderAvailablePlayers();\n    calculateTeamRating();\n}\n```\n\n---\n\n## üöÄ **How to Test:**\n\n### **Step 1: Hard Refresh**\n```\nWindows: Ctrl + Shift + R\nMac: Cmd + Shift + R\n```\n\n### **Step 2: Open Console**\n```\nPress F12\nGo to Console tab\n```\n\n### **Step 3: Check Messages**\nYou should see:\n```\nDuplicate player found at position X, removing...\nSquad cleaned - duplicates removed\nSquad auto-saved after cleanup\n```\n\n### **Step 4: Check Display**\n- Kenny Abshire should appear **1 time** only\n- Lafayette Wolff should appear **1 time** only\n- Other positions should be empty (\"Click to add\")\n\n### **Step 5: Verify Discord**\n```\nUse /squad view command\nShould match website exactly\n```\n\n---\n\n## ‚úÖ **Expected Result:**\n\n### **Website After Fix:**\n```\nCMF: Kenny Abshire (88) ‚úÖ\nCMF: Click to add (empty)\nCMF: Click to add (empty)\n\nCB: Lafayette Wolff (88) ‚úÖ\nCB: Click to add (empty)\n```\n\n### **Discord Bot:**\n```\nCMF: Kenny Abshire (88) ‚úÖ\nCMF: Empty\nCMF: Empty\n\nCB: Lafayette Wolff (88) ‚úÖ\nCB: Empty\n```\n\n**BOTH SHOULD MATCH!** ‚úÖ\n\n---\n\n## üêõ **If Still Not Working:**\n\n### **Check 1: Console Errors**\n```\nF12 ‚Üí Console\nLook for red errors\nShare screenshot if any\n```\n\n### **Check 2: Network Tab**\n```\nF12 ‚Üí Network\nRefresh page\nCheck if /api/squad/update shows 200 OK\n```\n\n### **Check 3: Clear Cache**\n```\n1. Ctrl + Shift + Delete\n2. Clear cached images and files\n3. Refresh page\n```\n\n### **Check 4: Force Save**\n```\n1. Click \"Save Squad\" button\n2. Refresh page\n3. Check if duplicates gone\n```\n\n---\n\n## üìä **What Changed:**\n\n### **Before:**\n```\nLoad squad ‚Üí Clean data ‚Üí (no render) ‚Üí Show old duplicates ‚ùå\n```\n\n### **After:**\n```\nLoad squad ‚Üí Clean data ‚Üí RE-RENDER ‚Üí Show clean squad ‚úÖ\n```\n\n---\n\n## üéØ **Quick Test Checklist:**\n\n- [ ] Hard refresh browser (Ctrl+Shift+R)\n- [ ] Open console (F12)\n- [ ] See cleanup messages\n- [ ] Kenny Abshire appears 1 time only\n- [ ] Lafayette Wolff appears 1 time only\n- [ ] Empty positions show \"Click to add\"\n- [ ] Discord /squad matches website\n- [ ] Save squad works\n- [ ] Reload page keeps clean data\n\n---\n\n**If all checkboxes pass, the bug is FIXED!** üéâ‚öΩ\n","size_bytes":2951},"NEWS_SYSTEM.md":{"content":"# News System Documentation\n\n## Overview\nThe news system allows admins to create and manage game updates, announcements, and news that players can view using the `/news` command.\n\n## Commands\n\n### For Players: `/news`\nView the latest game updates and news.\n\n**Usage:**\n- `/news` - View the first page of news\n- `/news page:2` - View page 2 of news\n\n**Features:**\n- Shows 5 news articles per page\n- Sorted by date (newest first)\n- Color-coded by news type\n- Shows author and timestamp\n\n### For Admins: `/managenews`\nManage game news articles (Admin only).\n\n**Subcommands:**\n\n#### 1. Add News\n`/managenews add type:<type> title:<title> content:<content>`\n\n**News Types:**\n- üîÑ **Update** - Game updates and patches\n- üéâ **Event** - Special events\n- üîß **Maintenance** - Maintenance notices\n- üì¢ **Announcement** - General announcements\n- ‚ú® **Feature** - New features\n- üêõ **Bug Fix** - Bug fixes\n\n**Example:**\n```\n/managenews add type:update title:New Squad Builder content:We've added a new drag-and-drop squad builder to the web dashboard!\n```\n\n#### 2. Remove News\n`/managenews remove id:<id>`\n\nRemove a news article by its ID.\n\n**Example:**\n```\n/managenews remove id:3\n```\n\n#### 3. List All News\n`/managenews list`\n\nView all news articles with their IDs (admin view only).\n\n#### 4. Clear All News\n`/managenews clear`\n\nRemove all news articles. Use with caution!\n\n## Data Storage\n\nNews is stored in `data/news.json` with the following structure:\n\n```json\n{\n  \"news\": [\n    {\n      \"id\": 1,\n      \"type\": \"update\",\n      \"title\": \"New Feature Released\",\n      \"content\": \"We've added a new training system!\",\n      \"date\": \"2025-10-24T09:38:00.000Z\",\n      \"author\": \"Admin#1234\"\n    }\n  ]\n}\n```\n\n## Admin Setup\n\nTo use the `/managenews` command, you need either:\n1. Discord Administrator permissions in the server, OR\n2. Your Discord User ID added to the `ADMIN_IDS` environment variable in `.env`\n\n**Example `.env` entry:**\n```\nADMIN_IDS=123456789012345678,987654321098765432\n```\n\n## Example News Flow\n\n1. **Admin creates news:**\n   ```\n   /managenews add type:event title:Double GP Weekend! content:Earn 2x GP from all matches this weekend! Don't miss out!\n   ```\n\n2. **Players view news:**\n   ```\n   /news\n   ```\n   \n   They'll see:\n   ```\n   üì∞ eFOOTBALL WANNABE - Latest News\n   \n   üéâ Double GP Weekend!\n   Earn 2x GP from all matches this weekend! Don't miss out!\n   \n   Oct 24, 2025, 05:38 PM ‚Ä¢ by Admin#1234\n   ```\n\n3. **Admin removes old news:**\n   ```\n   /managenews list  (to see IDs)\n   /managenews remove id:5\n   ```\n\n## Best Practices\n\n1. **Keep titles concise** (max 100 characters)\n2. **Content should be clear** (max 1000 characters)\n3. **Use appropriate news types** for easy filtering\n4. **Remove outdated news** regularly to keep the feed relevant\n5. **Add important updates** like maintenance schedules, events, and new features\n\n## News Types Guide\n\n- **Update** üîÑ - Version updates, balance changes, system improvements\n- **Event** üéâ - Limited-time events, special promotions, celebrations\n- **Maintenance** üîß - Scheduled maintenance, downtime notices\n- **Announcement** üì¢ - General announcements, community updates\n- **Feature** ‚ú® - New features, new content additions\n- **Bug Fix** üêõ - Bug fixes, issue resolutions\n","size_bytes":3276},"server.js":{"content":"require('dotenv').config();\nconst express = require('express');\nconst path = require('path');\nconst { spawn } = require('child_process');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Bot process\nlet botProcess = null;\nlet botStatus = {\n    isRunning: false,\n    startTime: null,\n    restarts: 0,\n    lastError: null\n};\n\n// Start the Discord bot\nfunction startBot() {\n    console.log('üöÄ Starting Discord bot...');\n    \n    botProcess = spawn('node', ['index.js'], {\n        cwd: __dirname,\n        stdio: 'inherit'\n    });\n\n    botStatus.isRunning = true;\n    botStatus.startTime = new Date();\n\n    botProcess.on('error', (error) => {\n        console.error('‚ùå Bot process error:', error);\n        botStatus.lastError = error.message;\n        botStatus.isRunning = false;\n    });\n\n    botProcess.on('exit', (code, signal) => {\n        console.log(`‚ö†Ô∏è Bot process exited with code ${code} and signal ${signal}`);\n        botStatus.isRunning = false;\n        \n        // Auto-restart if crashed\n        if (code !== 0) {\n            botStatus.restarts++;\n            console.log(`üîÑ Restarting bot... (Restart #${botStatus.restarts})`);\n            setTimeout(startBot, 5000); // Restart after 5 seconds\n        }\n    });\n}\n\n// Middleware\napp.use(express.static(path.join(__dirname, 'public')));\napp.use('/assets', express.static(path.join(__dirname, 'assets')));\napp.use(express.json());\n\n// Routes\napp.get('/', (req, res) => {\n    res.send(`\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>eFotball Discord Bot - Status</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            padding: 20px;\n        }\n        \n        .container {\n            background: white;\n            border-radius: 20px;\n            box-shadow: 0 20px 60px rgba(0,0,0,0.3);\n            max-width: 600px;\n            width: 100%;\n            padding: 40px;\n            animation: fadeIn 0.5s ease-in;\n        }\n        \n        @keyframes fadeIn {\n            from { opacity: 0; transform: translateY(-20px); }\n            to { opacity: 1; transform: translateY(0); }\n        }\n        \n        .header {\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        \n        .header h1 {\n            color: #667eea;\n            font-size: 2.5em;\n            margin-bottom: 10px;\n        }\n        \n        .header p {\n            color: #666;\n            font-size: 1.1em;\n        }\n        \n        .status-card {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            color: white;\n            padding: 30px;\n            border-radius: 15px;\n            margin-bottom: 20px;\n            text-align: center;\n        }\n        \n        .status-indicator {\n            font-size: 3em;\n            margin-bottom: 10px;\n        }\n        \n        .status-text {\n            font-size: 1.5em;\n            font-weight: bold;\n            margin-bottom: 5px;\n        }\n        \n        .status-detail {\n            opacity: 0.9;\n            font-size: 0.9em;\n        }\n        \n        .info-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n            gap: 15px;\n            margin-bottom: 20px;\n        }\n        \n        .info-item {\n            background: #f8f9fa;\n            padding: 20px;\n            border-radius: 10px;\n            text-align: center;\n        }\n        \n        .info-label {\n            color: #666;\n            font-size: 0.9em;\n            margin-bottom: 5px;\n        }\n        \n        .info-value {\n            color: #333;\n            font-size: 1.3em;\n            font-weight: bold;\n        }\n        \n        .features {\n            background: #f8f9fa;\n            padding: 20px;\n            border-radius: 10px;\n            margin-bottom: 20px;\n        }\n        \n        .features h3 {\n            color: #667eea;\n            margin-bottom: 15px;\n        }\n        \n        .features ul {\n            list-style: none;\n        }\n        \n        .features li {\n            padding: 8px 0;\n            color: #555;\n        }\n        \n        .features li:before {\n            content: \"‚öΩ \";\n            color: #667eea;\n            font-weight: bold;\n        }\n        \n        .invite-button {\n            display: block;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            color: white;\n            text-align: center;\n            padding: 15px 30px;\n            border-radius: 10px;\n            text-decoration: none;\n            font-weight: bold;\n            font-size: 1.1em;\n            transition: transform 0.2s, box-shadow 0.2s;\n        }\n        \n        .invite-button:hover {\n            transform: translateY(-2px);\n            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);\n        }\n        \n        .footer {\n            text-align: center;\n            margin-top: 20px;\n            color: #999;\n            font-size: 0.9em;\n        }\n        \n        .pulse {\n            animation: pulse 2s infinite;\n        }\n        \n        @keyframes pulse {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0.5; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>‚öΩ eFotball Bot</h1>\n            <p>Discord Football Manager Bot</p>\n        </div>\n        \n        <div class=\"status-card\">\n            <div class=\"status-indicator pulse\">üü¢</div>\n            <div class=\"status-text\">Bot is Online!</div>\n            <div class=\"status-detail\">Running 24/7</div>\n        </div>\n        \n        <div class=\"info-grid\">\n            <div class=\"info-item\">\n                <div class=\"info-label\">Uptime</div>\n                <div class=\"info-value\" id=\"uptime\">Loading...</div>\n            </div>\n            <div class=\"info-item\">\n                <div class=\"info-label\">Restarts</div>\n                <div class=\"info-value\" id=\"restarts\">0</div>\n            </div>\n            <div class=\"info-item\">\n                <div class=\"info-label\">Status</div>\n                <div class=\"info-value\" id=\"status\">Active</div>\n            </div>\n        </div>\n        \n        <div class=\"features\">\n            <h3>üéÆ Features</h3>\n            <ul>\n                <li>Contract System - Pull legendary players</li>\n                <li>Squad Management - Build your dream team</li>\n                <li>Match Simulation - Battle AI teams</li>\n                <li>PvP Battles - Challenge real players</li>\n                <li>Training System - Level up your players</li>\n                <li>Daily Rewards - Login bonuses</li>\n                <li>Leaderboards - Compete globally</li>\n            </ul>\n        </div>\n        \n        <a href=\"#\" class=\"invite-button\" onclick=\"alert('Add your Discord bot invite link here!'); return false;\">\n            üéØ Invite Bot to Your Server\n        </a>\n        \n        <div class=\"footer\">\n            <p>eFotball Discord Bot ¬© 2025</p>\n            <p>Keeping your bot online 24/7</p>\n        </div>\n    </div>\n    \n    <script>\n        // Update status every 5 seconds\n        setInterval(async () => {\n            try {\n                const response = await fetch('/api/status');\n                const data = await response.json();\n                \n                document.getElementById('uptime').textContent = data.uptime;\n                document.getElementById('restarts').textContent = data.restarts;\n                document.getElementById('status').textContent = data.isRunning ? 'Active' : 'Offline';\n            } catch (error) {\n                console.error('Failed to fetch status:', error);\n            }\n        }, 5000);\n        \n        // Initial load\n        fetch('/api/status')\n            .then(res => res.json())\n            .then(data => {\n                document.getElementById('uptime').textContent = data.uptime;\n                document.getElementById('restarts').textContent = data.restarts;\n                document.getElementById('status').textContent = data.isRunning ? 'Active' : 'Offline';\n            });\n    </script>\n</body>\n</html>\n    `);\n});\n\n// API endpoint for bot status\napp.get('/api/status', (req, res) => {\n    const uptime = botStatus.startTime \n        ? formatUptime(Date.now() - botStatus.startTime.getTime())\n        : 'Not started';\n    \n    res.json({\n        isRunning: botStatus.isRunning,\n        uptime: uptime,\n        restarts: botStatus.restarts,\n        lastError: botStatus.lastError,\n        serverTime: new Date().toISOString()\n    });\n});\n\n// Health check endpoint (for hosting services)\napp.get('/health', (req, res) => {\n    res.status(200).json({ status: 'ok', bot: botStatus.isRunning });\n});\n\n// Ping endpoint (keeps server alive)\napp.get('/ping', (req, res) => {\n    res.send('pong');\n});\n\n// Format uptime\nfunction formatUptime(ms) {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) return `${days}d ${hours % 24}h`;\n    if (hours > 0) return `${hours}h ${minutes % 60}m`;\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n    return `${seconds}s`;\n}\n\n// Start web server\napp.listen(PORT, () => {\n    console.log(`üåê Web server running on port ${PORT}`);\n    console.log(`üìä Dashboard: http://localhost:${PORT}`);\n    \n    // Start the Discord bot\n    startBot();\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n    console.log('\\nüõë Shutting down gracefully...');\n    if (botProcess) {\n        botProcess.kill();\n    }\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    console.log('\\nüõë Shutting down gracefully...');\n    if (botProcess) {\n        botProcess.kill();\n    }\n    process.exit(0);\n});\n","size_bytes":10261},"IMPROVED_DRAG_DROP.md":{"content":"# üéÆ Improved Drag & Drop System\n\n## ‚úÖ Fixed Issues:\n\n### **1. Duplicate Player Bug** \n- ‚úÖ Players can no longer appear multiple times in squad\n- ‚úÖ Alert shows if trying to add duplicate\n- ‚úÖ Moving player removes from old position first\n\n### **2. Enhanced Drag & Drop**\n- ‚úÖ **Squad ‚Üî Bench** - Drag between main squad and bench\n- ‚úÖ **Available ‚Üí Squad** - Drag from player list to pitch\n- ‚úÖ **Available ‚Üí Bench** - Drag directly to bench\n- ‚úÖ **Bench ‚Üí Squad** - Drag from bench to pitch position\n- ‚úÖ **Squad ‚Üí Bench** - Drag from pitch to bench\n- ‚úÖ **Swap on Pitch** - Drag between positions\n- ‚úÖ **Swap on Bench** - Reorder bench players\n\n---\n\n## üéØ All Drag & Drop Actions:\n\n### **1. Available Players ‚Üí Squad**\n```\nDrag player from \"Available Players\" list\nDrop on any position on the pitch\n‚Üí Player added to squad\n‚Üí If position occupied, that player moves to bench\n```\n\n### **2. Available Players ‚Üí Bench**\n```\nDrag player from \"Available Players\" list\nDrop on bench area (yellow dashed box)\n‚Üí Player added to bench\n```\n\n### **3. Squad ‚Üí Squad (Swap)**\n```\nDrag player from one position\nDrop on another position\n‚Üí Players swap positions\n```\n\n### **4. Squad ‚Üí Bench**\n```\nDrag player from pitch\nDrop on bench area\n‚Üí Player removed from squad\n‚Üí Player added to bench\n‚Üí Position becomes empty\n```\n\n### **5. Bench ‚Üí Squad**\n```\nDrag player from bench\nDrop on pitch position\n‚Üí Player removed from bench\n‚Üí Player added to squad\n‚Üí If position occupied, that player goes to bench\n```\n\n### **6. Bench ‚Üí Bench (Reorder)**\n```\nDrag bench player\nDrop on another bench player\n‚Üí They swap positions on bench\n```\n\n---\n\n## üö´ Duplicate Prevention:\n\n### **Alerts You'll See:**\n- ‚ö†Ô∏è **\"This player is already in your squad!\"**\n  - Trying to add player who's already on pitch\n  \n- ‚ö†Ô∏è **\"This player is already on your bench!\"**\n  - Trying to add player who's already on bench\n\n### **Auto-Remove:**\n- Moving player from one position to another automatically removes from old position\n- No more duplicates appearing!\n\n---\n\n## üé® Visual Feedback:\n\n### **Grab Cursor** üñêÔ∏è\n- Hover over any draggable player\n- Shows you can grab it\n\n### **Grabbing Cursor** ‚úä\n- While dragging\n- Shows you're moving something\n\n### **Yellow Highlight** üü°\n- Drop zones light up yellow\n- Shows where you can drop\n\n### **Opacity Effect** üëª\n- Dragged item becomes semi-transparent\n- Easy to see what you're moving\n\n### **Bench Drop Zone** üì¶\n- Dashed yellow border\n- Lights up when dragging over it\n- Clear indication it's a drop target\n\n---\n\n## üìã Step-by-Step Examples:\n\n### **Example 1: Build Squad from Scratch**\n1. **Drag GK** from Available ‚Üí Drop on GK position\n2. **Drag CB** from Available ‚Üí Drop on CB position\n3. **Drag CF** from Available ‚Üí Drop on CF position\n4. Continue until squad is full\n5. **Drag extra players** ‚Üí Drop on Bench\n6. Click **\"üíæ Save Squad\"**\n\n### **Example 2: Swap Two Players**\n1. **Drag Messi** (LWF position)\n2. **Drop on Ronaldo** (RWF position)\n3. They swap! Messi now RWF, Ronaldo now LWF\n\n### **Example 3: Move Player to Bench**\n1. **Drag player** from pitch (e.g., CMF position)\n2. **Drop on Bench area** (yellow dashed box)\n3. Player moves to bench, position becomes empty\n\n### **Example 4: Promote from Bench**\n1. **Drag player** from bench\n2. **Drop on empty position** on pitch\n3. Player moves to squad, removed from bench\n\n### **Example 5: Replace Player**\n1. **Drag new player** from Available\n2. **Drop on occupied position**\n3. Old player automatically moves to bench\n4. New player takes the position\n\n---\n\n## üí° Pro Tips:\n\n1. **Quick Swap** - Drag directly between positions for instant swap\n2. **Bench Management** - Use bench for rotation and subs\n3. **Visual Check** - Yellow highlight shows valid drops\n4. **Save Often** - Click save after making changes\n5. **Undo Mistake** - Just drag player back to original position\n\n---\n\n## üêõ No More Bugs:\n\n### **Before (Buggy):**\n- ‚ùå Troy appears 3 times in CMF\n- ‚ùå Casandra appears 2 times in CB\n- ‚ùå Dragging creates duplicates\n\n### **After (Fixed):**\n- ‚úÖ Each player appears only once\n- ‚úÖ Moving removes from old position\n- ‚úÖ Alerts prevent duplicates\n- ‚úÖ Clean squad management\n\n---\n\n## üéÆ Keyboard & Mouse:\n\n- **Click** - Select player (alternative method)\n- **Drag** - Move/swap players (main method)\n- **Drop** - Place player in position\n- **Escape** - Close modals\n\n---\n\n## üì± Mobile Support:\n\n- **Touch & Hold** - Grab player\n- **Drag** - Move to position\n- **Release** - Drop player\n- **Tap** - Alternative click method\n\n---\n\n## üîÑ Sync with Discord:\n\n1. Make changes on website\n2. Click **\"üíæ Save Squad\"**\n3. Squad syncs to JSON file\n4. Discord bot reads same file\n5. **Everything stays in sync!** üéâ\n\n---\n\n## üéØ Summary:\n\n‚úÖ **No more duplicates**\n‚úÖ **Drag anywhere to anywhere**\n‚úÖ **Squad ‚Üî Bench ‚Üî Available**\n‚úÖ **Visual feedback**\n‚úÖ **Auto-swap when needed**\n‚úÖ **Clean, intuitive interface**\n\n**Your squad builder is now fully functional!** üéâ‚öΩ\n","size_bytes":5069},"DUPLICATE_BUG_FIX.md":{"content":"# üêõ Duplicate Player Bug - FIXED\n\n## üìä **Bug Description:**\n\n### **The Problem:**\nPlayers were appearing multiple times in the same squad:\n- **Brenna Renner** appeared **3 times** in CMF positions\n- **Troy Gorczany-Moscicki** appeared **3 times** in CMF positions\n- **Casandra Prosacco** appeared **2 times** in CB positions\n\n### **Root Cause:**\nThe system was not properly checking if a player already existed in the squad before assigning them to a new position. The duplicate detection was using `.indexOf()` on arrays that contained `null` values, which caused incorrect matching.\n\n---\n\n## ‚úÖ **Fixes Applied:**\n\n### **1. Strict Duplicate Detection**\n\n#### **Before (Buggy):**\n```javascript\nconst usedPlayerIds = [...currentSquad.main, ...currentSquad.bench];\n// This included null values, causing false matches\n```\n\n#### **After (Fixed):**\n```javascript\nconst usedPlayerIds = [\n    ...currentSquad.main.filter(id => id !== null && id !== undefined),\n    ...currentSquad.bench.filter(id => id !== null && id !== undefined)\n];\n// Filters out null/undefined before checking\n```\n\n### **2. Enhanced assignPlayerToPosition()**\n\n#### **New Checks:**\n```javascript\n// Check if player exists in squad (excluding nulls)\nconst inSquad = currentSquad.main.filter(id => id !== null).indexOf(playerId);\nif (inSquad !== -1 && inSquad !== positionIndex) {\n    alert('‚ö†Ô∏è This player is already in your squad at another position!');\n    return; // BLOCKS the action\n}\n\n// Check if player exists in bench\nconst inBench = currentSquad.bench.filter(id => id !== null).indexOf(playerId);\nif (inBench !== -1) {\n    alert('‚ö†Ô∏è This player is already on your bench!');\n    return; // BLOCKS the action\n}\n```\n\n### **3. Drag & Drop Duplicate Prevention**\n\nAll drag handlers now use strict checking:\n```javascript\n// Strict check - filters nulls first\nconst inSquad = currentSquad.main.filter(id => id !== null).indexOf(draggedPlayerId);\nconst inBench = currentSquad.bench.filter(id => id !== null).indexOf(draggedPlayerId);\n\nif (inSquad !== -1) {\n    alert('‚ö†Ô∏è This player is already in your squad!');\n    return false; // BLOCKS the drop\n}\n```\n\n---\n\n## üéØ **8-Player Bench Limit**\n\n### **New Feature:**\nMaximum 8 players allowed on bench (same as Discord bot)\n\n### **Implementation:**\n\n#### **Click Method:**\n```javascript\nif (currentSquad.bench.length >= 8) {\n    alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed on bench.');\n    return; // BLOCKS adding more\n}\n```\n\n#### **Drag & Drop:**\n```javascript\n// Check before adding to bench\nif (currentSquad.bench.length >= 8 && !draggedFromBench) {\n    alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n    return false; // BLOCKS the drop\n}\n```\n\n#### **When Replacing Players:**\n```javascript\n// If position occupied, check bench space first\nif (currentPlayerAtPosition && currentPlayerAtPosition !== playerId) {\n    if (currentSquad.bench.length >= 8) {\n        alert('‚ö†Ô∏è Bench is full! Maximum 8 players allowed.');\n        return; // BLOCKS the replacement\n    }\n    currentSquad.bench.push(currentPlayerAtPosition);\n}\n```\n\n---\n\n## üö´ **All Duplicate Scenarios Blocked:**\n\n### **Scenario 1: Click to Add Duplicate**\n```\nUser clicks CMF position\nTries to add \"Brenna Renner\" (already in squad)\n‚Üí ‚ö†Ô∏è Alert: \"This player is already in your squad at another position!\"\n‚Üí Action BLOCKED\n```\n\n### **Scenario 2: Drag Duplicate from Available**\n```\nUser drags \"Troy Gorczany-Moscicki\" from Available Players\nTries to drop on CMF (already has Troy in another CMF)\n‚Üí ‚ö†Ô∏è Alert: \"This player is already in your squad!\"\n‚Üí Drop BLOCKED\n```\n\n### **Scenario 3: Drag to Full Bench**\n```\nBench has 8 players\nUser drags 9th player to bench\n‚Üí ‚ö†Ô∏è Alert: \"Bench is full! Maximum 8 players allowed.\"\n‚Üí Drop BLOCKED\n```\n\n### **Scenario 4: Replace When Bench Full**\n```\nBench has 8 players\nUser tries to replace player on pitch\n‚Üí ‚ö†Ô∏è Alert: \"Bench is full! Maximum 8 players allowed.\"\n‚Üí Replacement BLOCKED (old player has nowhere to go)\n```\n\n---\n\n## ‚úÖ **What Now Works:**\n\n### **‚úÖ No Duplicates**\n- Each player can only appear ONCE in entire squad (main + bench)\n- Strict checking filters out null values\n- Alerts prevent any duplicate attempts\n\n### **‚úÖ Bench Limit**\n- Maximum 8 players on bench\n- Matches Discord bot behavior\n- Prevents overflow\n\n### **‚úÖ Smart Replacement**\n- Replacing player moves old one to bench\n- Only if bench has space\n- Otherwise blocks the action\n\n### **‚úÖ All Methods Protected**\n- Click to select\n- Drag from available\n- Drag between positions\n- Drag to/from bench\n\n---\n\n## üß™ **Testing Checklist:**\n\n### **Test 1: Add Same Player Twice**\n- [ ] Try to add \"Messi\" to LWF\n- [ ] Try to add \"Messi\" to RWF\n- [ ] Should see alert and be blocked\n\n### **Test 2: Fill Bench to 8**\n- [ ] Add 8 players to bench\n- [ ] Try to add 9th player\n- [ ] Should see \"Bench is full\" alert\n\n### **Test 3: Replace When Bench Full**\n- [ ] Fill bench with 8 players\n- [ ] Try to replace player on pitch\n- [ ] Should see \"Bench is full\" alert\n\n### **Test 4: Move Player Between Positions**\n- [ ] Add player to CMF position 1\n- [ ] Drag to CMF position 2\n- [ ] Should move (not duplicate)\n- [ ] Position 1 should be empty\n\n### **Test 5: Drag from Bench to Squad**\n- [ ] Add player to bench\n- [ ] Drag to pitch position\n- [ ] Should remove from bench\n- [ ] Should add to pitch\n- [ ] No duplicates\n\n---\n\n## üìù **Technical Details:**\n\n### **Key Changes:**\n\n1. **Null Filtering:**\n   - All duplicate checks now filter `null` and `undefined` first\n   - Prevents false matches on empty positions\n\n2. **Strict indexOf:**\n   - Uses `.filter().indexOf()` instead of direct `.indexOf()`\n   - Ensures accurate position detection\n\n3. **Early Returns:**\n   - Functions return immediately when duplicate detected\n   - Prevents any further processing\n\n4. **Bench Limit Checks:**\n   - Added to all functions that add to bench\n   - Consistent 8-player maximum\n\n5. **User Feedback:**\n   - Clear alert messages for all blocked actions\n   - Users know exactly why action was blocked\n\n---\n\n## üéâ **Result:**\n\n### **Before:**\n- ‚ùå Brenna Renner x3 in CMF\n- ‚ùå Troy Gorczany-Moscicki x3 in CMF\n- ‚ùå Casandra Prosacco x2 in CB\n- ‚ùå Unlimited bench\n\n### **After:**\n- ‚úÖ Each player appears ONCE only\n- ‚úÖ Maximum 8 bench players\n- ‚úÖ Clear error messages\n- ‚úÖ Matches Discord bot behavior\n\n---\n\n**The duplicate bug is now completely fixed!** üéâ‚öΩ\n\n**Refresh your browser and test the squad builder!**\n","size_bytes":6484},"commands/match.js":{"content":"const { \n    SlashCommandBuilder, \n    EmbedBuilder, \n    ActionRowBuilder, \n    ButtonBuilder, \n    ButtonStyle \n} = require('discord.js');\n\nconst AI_TEAMS = [\n    // üåç Top Clubs\n    { name: 'FC Barcelona', strength: 85 },\n    { name: 'Real Madrid', strength: 87 },\n    { name: 'Manchester City', strength: 86 },\n    { name: 'Liverpool', strength: 84 },\n    { name: 'Bayern Munich', strength: 85 },\n    { name: 'Paris Saint-Germain', strength: 83 },\n    { name: 'Chelsea', strength: 82 },\n    { name: 'Juventus', strength: 81 },\n    { name: 'Arsenal', strength: 80 },\n    { name: 'Manchester United', strength: 79 },\n    { name: 'Atletico Madrid', strength: 82 },\n    { name: 'Inter Milan', strength: 81 },\n    { name: 'AC Milan', strength: 80 },\n    { name: 'Tottenham', strength: 78 },\n    { name: 'Borussia Dortmund', strength: 79 },\n    { name: 'Ajax', strength: 77 },\n    { name: 'Sevilla', strength: 78 },\n    { name: 'RB Leipzig', strength: 80 },\n    { name: 'Napoli', strength: 81 },\n    { name: 'Roma', strength: 79 },\n    { name: 'Porto', strength: 78 },\n    { name: 'Benfica', strength: 79 },\n    { name: 'Sporting CP', strength: 77 },\n    { name: 'Monaco', strength: 78 },\n    { name: 'Lazio', strength: 78 },\n    { name: 'Villarreal', strength: 77 },\n    { name: 'Real Sociedad', strength: 77 },\n    { name: 'Athletic Bilbao', strength: 76 },\n    { name: 'Valencia', strength: 75 },\n    { name: 'Marseille', strength: 77 },\n    { name: 'Lyon', strength: 77 },\n    { name: 'Shakhtar Donetsk', strength: 76 },\n    { name: 'Galatasaray', strength: 75 },\n    { name: 'Fenerbahce', strength: 75 },\n    { name: 'Besiktas', strength: 74 },\n    { name: 'Celtic', strength: 74 },\n    { name: 'Rangers', strength: 74 },\n    { name: 'PSV Eindhoven', strength: 76 },\n    { name: 'Feyenoord', strength: 75 },\n    { name: 'Anderlecht', strength: 73 },\n    { name: 'Club Brugge', strength: 74 },\n    { name: 'Zenit St. Petersburg', strength: 76 },\n    { name: 'CSKA Moscow', strength: 74 },\n    { name: 'Spartak Moscow', strength: 73 },\n    { name: 'Dinamo Zagreb', strength: 73 },\n    { name: 'Red Bull Salzburg', strength: 74 },\n    { name: 'Basel', strength: 72 },\n    { name: 'Young Boys', strength: 72 },\n    { name: 'Olympiacos', strength: 74 },\n\n    // üåé National Teams\n    { name: 'Brazil', strength: 87 },\n    { name: 'Argentina', strength: 86 },\n    { name: 'France', strength: 88 },\n    { name: 'Germany', strength: 85 },\n    { name: 'Spain', strength: 84 },\n    { name: 'Portugal', strength: 84 },\n    { name: 'England', strength: 85 },\n    { name: 'Italy', strength: 83 },\n    { name: 'Netherlands', strength: 83 },\n    { name: 'Belgium', strength: 84 },\n    { name: 'Uruguay', strength: 82 },\n    { name: 'Croatia', strength: 82 },\n    { name: 'Denmark', strength: 81 },\n    { name: 'Switzerland', strength: 80 },\n    { name: 'Sweden', strength: 79 },\n    { name: 'Poland', strength: 79 },\n    { name: 'Serbia', strength: 78 },\n    { name: 'Mexico', strength: 81 },\n    { name: 'USA', strength: 80 },\n    { name: 'Canada', strength: 77 },\n    { name: 'Japan', strength: 79 },\n    { name: 'South Korea', strength: 78 },\n    { name: 'Australia', strength: 77 },\n    { name: 'Morocco', strength: 80 },\n    { name: 'Senegal', strength: 81 },\n    { name: 'Nigeria', strength: 78 },\n    { name: 'Egypt', strength: 78 },\n    { name: 'Ghana', strength: 77 },\n    { name: 'Cameroon', strength: 77 },\n    { name: 'Turkey', strength: 78 },\n    { name: 'Iran', strength: 76 },\n    { name: 'Saudi Arabia', strength: 75 },\n    { name: 'Qatar', strength: 74 },\n    { name: 'South Africa', strength: 74 },\n    { name: 'Ivory Coast', strength: 78 },\n    { name: 'Chile', strength: 80 },\n    { name: 'Colombia', strength: 81 },\n    { name: 'Peru', strength: 77 },\n    { name: 'Ecuador', strength: 78 },\n    { name: 'Paraguay', strength: 76 },\n    { name: 'Venezuela', strength: 74 },\n    { name: 'Costa Rica', strength: 75 },\n    { name: 'Panama', strength: 74 },\n    { name: 'Honduras', strength: 73 },\n    { name: 'Iraq', strength: 73 },\n    { name: 'UAE', strength: 74 },\n    { name: 'China', strength: 72 },\n    { name: 'India', strength: 70 },\n    { name: 'Thailand', strength: 71 }\n];\n\nconst MATCH_REWARDS = {\n    win: { gp: 5000, eCoins: 10 },\n    draw: { gp: 2000, eCoins: 5 },\n    loss: { gp: 1000, eCoins: 2 }\n};\n\nconst cooldowns = new Map();\nconst activeMatches = new Map(); // Track active matches\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('match')\n        .setDescription('üî• Battle against legendary AI teams - Are you ready to become a CHAMPION?! ‚öΩ'),\n    async execute(interaction) {\n        const { client } = interaction;\n        const userId = interaction.user.id;\n\n        // Cooldown\n        const now = Date.now();\n        const cooldownAmount = 20 * 1000;\n        if (cooldowns.has(userId)) {\n            const expiration = cooldowns.get(userId);\n            if (now < expiration) {\n                const remaining = Math.ceil((expiration - now) / 1000);\n                return await interaction.reply({\n                    content: `‚è≥ **WHOA THERE CHAMPION!** You gotta wait **${remaining} seconds** before your next EPIC battle! üî•‚öΩ`,\n                    ephemeral: true\n                });\n            }\n        }\n        cooldowns.set(userId, now + cooldownAmount);\n\n        const userData = client.getUserData(userId);\n        if (!userData.squad || userData.squad.main.length < 11) {\n            return await interaction.reply({\n                content: 'üö® **HOLD UP!** You need 11 players in your squad before stepping onto the battlefield! Go build your DREAM TEAM first! üí™‚öΩ',\n                ephemeral: true\n            });\n        }\n\n        const teamStrength = calculateTeamStrength(userData, client);\n        const opponent = AI_TEAMS[Math.floor(Math.random() * AI_TEAMS.length)];\n\n        // Initialize match state\n        const matchState = {\n            playerScore: 0,\n            opponentScore: 0,\n            events: [],\n            currentMinute: 0,\n            opponent: opponent,\n            userId: userId,\n            username: interaction.user.username\n        };\n        activeMatches.set(userId, matchState);\n\n        // Initial embed\n        const embed = new EmbedBuilder()\n            .setTitle('‚öΩ **EPIC FOOTBALL SHOWDOWN** üî•')\n            .setDescription(`**${interaction.user.username}'s LEGENDARY Team** üÜö **${opponent.name}**`)\n            .addFields(\n                { name: '‚öΩ Score', value: '**0 - 0**', inline: true },\n                { name: '‚è∞ Time', value: \"**0' - LET'S GOOO!** üöÄ\", inline: true },\n                { name: 'üí™ Team Power', value: `**${teamStrength}** vs **${opponent.strength}**`, inline: true }\n            )\n            .setColor('#3498db')\n            .setFooter({ text: 'üî• MATCH IS HEATING UP! Get ready for some ACTION!' });\n\n        await interaction.reply({ embeds: [embed] });\n\n        // Generate and process match events\n        const matchEvents = generateMatchTimeline(teamStrength, opponent.strength);\n        await processMatchEvents(interaction, matchEvents, matchState, client, userData);\n    }\n};\n\nasync function processMatchEvents(interaction, events, matchState, client, userData) {\n    let currentEventIndex = 0;\n    \n    // Sort events by minute\n    events.sort((a, b) => a.minute - b.minute);\n\n    for (const event of events) {\n        await new Promise(r => setTimeout(r, event.delay));\n        \n        // Update match state based on event\n        if (event.type === 'goal_player') {\n            matchState.playerScore++;\n        } else if (event.type === 'goal_opponent') {\n            matchState.opponentScore++;\n        }\n        \n        matchState.currentMinute = event.minute;\n        matchState.events.push(event);\n\n        if (event.type === 'chance') {\n            // Show interactive chance\n            const embed = createMatchEmbed(matchState, event.message);\n            const row = new ActionRowBuilder().addComponents(\n                new ButtonBuilder().setCustomId(`shoot_left_${matchState.userId}_${event.minute}_${event.kind}`).setLabel('Left').setEmoji('‚¨ÖÔ∏è').setStyle(ButtonStyle.Primary),\n                new ButtonBuilder().setCustomId(`shoot_center_${matchState.userId}_${event.minute}_${event.kind}`).setLabel('Center').setEmoji('‚¨ÜÔ∏è').setStyle(ButtonStyle.Primary),\n                new ButtonBuilder().setCustomId(`shoot_right_${matchState.userId}_${event.minute}_${event.kind}`).setLabel('Right').setEmoji('‚û°Ô∏è').setStyle(ButtonStyle.Primary)\n            );\n            \n            await interaction.editReply({ embeds: [embed], components: [row] });\n            \n            // Wait for button interaction or timeout\n            await new Promise(resolve => {\n                const timeout = setTimeout(() => {\n                    // Auto-resolve if no button pressed and not handled by button\n                    if (!matchState.buttonHandled) {\n                        const autoOutcome = Math.random() < 0.4 ? 'goal' : 'miss';\n                        if (autoOutcome === 'goal') {\n                            matchState.playerScore++;\n                        }\n                        // Update embed with timeout result\n                        const timeoutMessage = autoOutcome === 'goal' ? \n                            `**${event.minute}' ‚öΩ TIMEOUT GOAL! Lucky break!** üçÄ\\n\\n*CHANCE COMPLETED* ‚úÖ` :\n                            `**${event.minute}' ‚ùå MISSED! Time ran out!** ‚è∞\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n                        matchState.timeoutMessage = timeoutMessage;\n                    }\n                    resolve();\n                }, 10000); // 10 second timeout\n\n                // Store timeout for potential clearing\n                matchState.chanceTimeout = timeout;\n                matchState.chanceResolve = resolve;\n                matchState.buttonHandled = false; // Reset flag\n            });\n            \n        } else {\n            // Regular event - just update embed\n            const embed = createMatchEmbed(matchState, event.message);\n            await interaction.editReply({ embeds: [embed], components: [] });\n        }\n    }\n\n    // Final result\n    const outcome = determineOutcome(matchState.playerScore, matchState.opponentScore);\n    const reward = MATCH_REWARDS[outcome];\n    userData.gp += reward.gp;\n    userData.eCoins += reward.eCoins;\n    // Track stats for leaderboards\n    if (!userData.stats) userData.stats = { wins: 0, draws: 0, losses: 0, lastStrength: 0, bestStrength: 0 };\n    const strengthNow = calculateTeamStrength(userData, client);\n    userData.stats.lastStrength = strengthNow;\n    userData.stats.bestStrength = Math.max(userData.stats.bestStrength || 0, strengthNow);\n    if (outcome === 'win') userData.stats.wins += 1;\n    else if (outcome === 'draw') userData.stats.draws += 1;\n    else userData.stats.losses += 1;\n    client.setUserData(matchState.userId, userData);\n\n    const finalEmbed = new EmbedBuilder()\n        .setTitle(outcome === 'win' ? 'üèÜ **VICTORY!! YOU ARE THE CHAMPION!** üî•' : \n                 outcome === 'draw' ? 'ü§ù **EPIC DRAW! What a battle!** ‚ö°' : \n                 'üò§ **DEFEAT! Come back stronger!** üí™')\n        .setDescription(`**${matchState.username}'s LEGENDARY Team** üÜö **${matchState.opponent.name}**`)\n        .addFields(\n            { name: '‚öΩ **FINAL SCORE**', value: `**${matchState.playerScore} - ${matchState.opponentScore}**`, inline: true },\n            { name: 'üéØ **RESULT**', value: `**${outcome.toUpperCase()}**`, inline: true },\n            { name: 'üí∞ **EPIC REWARDS**', value: `**+${reward.gp} GP** üíé **+${reward.eCoins} eCoins** ü™ô`, inline: false }\n        )\n        .setColor(outcome === 'win' ? '#2ecc71' : outcome === 'draw' ? '#f1c40f' : '#e74c3c')\n        .setFooter({ text: outcome === 'win' ? 'üèÜ LEGENDARY PERFORMANCE! You\\'re unstoppable!' : \n                           outcome === 'draw' ? '‚ö° What an INTENSE battle! Both teams fought hard!' :\n                           'üí™ Every champion faces defeats! Train harder and come back stronger!' });\n\n    await interaction.editReply({ embeds: [finalEmbed], components: [] });\n    activeMatches.delete(matchState.userId);\n}\n\nfunction createMatchEmbed(matchState, latestEvent) {\n    const embed = new EmbedBuilder()\n        .setTitle('‚öΩ **EPIC FOOTBALL BATTLE** üî•')\n        .setDescription(`**${matchState.username}'s DREAM Team** üÜö **${matchState.opponent.name}**`)\n        .addFields(\n            { name: '‚öΩ **Score**', value: `**${matchState.playerScore} - ${matchState.opponentScore}**`, inline: true },\n            { name: '‚è∞ **Time**', value: `**${matchState.currentMinute}'**`, inline: true },\n            { name: 'üéØ **Latest Action**', value: latestEvent || '**Match starting... GET READY!** üöÄ', inline: false }\n        )\n        .setColor('#3498db');\n\n    // Add match status\n    if (matchState.currentMinute >= 90) {\n        embed.setFooter({ text: '‚è±Ô∏è FULL TIME! What an AMAZING match!' });\n    } else if (matchState.currentMinute >= 45 && matchState.currentMinute < 46) {\n        embed.setFooter({ text: '‚òï HALF TIME! Time to strategize!' });\n    } else {\n        embed.setFooter({ text: 'üî• MATCH IS ON FIRE! The tension is REAL!' });\n    }\n\n    return embed;\n}\n\nfunction calculateTeamStrength(userData, client) {\n    const positions = { GK: [], DEF: [], MID: [], ATT: [] };\n    \n    for (const id of userData.squad.main) {\n        const player = userData.players.find(p => p.id === id);\n        if (player) {\n            const pos = player.position || 'MID';\n            if (positions[pos]) {\n                positions[pos].push(player.overall);\n            } else {\n                positions.MID.push(player.overall);\n            }\n        }\n    }\n\n    const weights = { GK: 0.15, DEF: 0.30, MID: 0.35, ATT: 0.20 };\n    let totalStrength = 0;\n    \n    for (const [pos, players] of Object.entries(positions)) {\n        if (players.length > 0) {\n            const avgStrength = players.reduce((a, b) => a + b, 0) / players.length;\n            totalStrength += avgStrength * weights[pos];\n        }\n    }\n\n    return Math.round(totalStrength || 50);\n}\n\nfunction generateMatchTimeline(playerStrength, opponentStrength) {\n    const events = [];\n    \n    // Calculate probabilities\n    const playerChance = (playerStrength / (playerStrength + opponentStrength)) * 0.5;\n    const opponentChance = (opponentStrength / (playerStrength + opponentStrength)) * 0.5;\n\n  // First half events (0-45) - Random timeline\nconst firstHalfEventCount = 4 + Math.floor(Math.random() * 3); // 4-6 events\nconst firstHalfMinutes = [];\nfor (let i = 0; i < firstHalfEventCount; i++) {\n    const randomMinute = 5 + Math.floor(Math.random() * 40); // 5-44 minutes\n    if (!firstHalfMinutes.includes(randomMinute)) {\n        firstHalfMinutes.push(randomMinute);\n    }\n}\nfirstHalfMinutes.sort((a, b) => a - b);\n\nfirstHalfMinutes.forEach(minute => {\n        const rand = Math.random();\n        if (rand < playerChance * 0.6) {\n            events.push({\n                minute,\n                type: 'goal_player',\n                message: `**${minute}' ‚öΩ GOOOAAAAAL!! YOUR TEAM SCORES!! WHAT A STRIKE!** üî•üéØ`,\n                delay: 2000\n            });\n        } else if (rand < (playerChance * 0.6) + (opponentChance * 0.6)) {\n            events.push({\n                minute,\n                type: 'goal_opponent', \n                message: `**${minute}' ‚öΩ OH NO! ${events.find(e => e.minute === minute)?.opponent || 'Opponent'} scores! Time to fight back!** üò§`,\n                delay: 2000\n            });\n        } else if (rand < 0.8) {\n            const comments = [\n                `**${minute}' ü•Ö INCREDIBLE SAVE! The keeper is ON FIRE!** üî•`,\n                `**${minute}' üò± SO CLOSE! Just inches away from GLORY!** ‚ö°`,\n                `**${minute}' üõ°Ô∏è DEFENSIVE MASTERCLASS! What a tackle!** üí™`,\n                `**${minute}' üü® YELLOW CARD! Things are getting HEATED!** üå∂Ô∏è`,\n                `**${minute}' ‚ö° LIGHTNING FAST counter attack! AMAZING!** üèÉ‚Äç‚ôÇÔ∏è`,\n                `**${minute}' üéØ CROSSBAR! Unlucky! So close to perfection!** üò©`\n            ];\n            events.push({\n                minute,\n                type: 'comment',\n                message: comments[Math.floor(Math.random() * comments.length)],\n                delay: 1500\n            });\n        }\n    });\n\n    // Half time\n    events.push({\n        minute: 45,\n        type: 'halftime',\n        message: \"**45' ‚è∏Ô∏è HALF TIME! Time for tactical genius!** ‚òïüß†\",\n        delay: 2000\n    });\n\n // Second half events (46-90) - Random timeline\nconst secondHalfEventCount = 4 + Math.floor(Math.random() * 3); // 4-6 events\nconst secondHalfMinutes = [];\nfor (let i = 0; i < secondHalfEventCount; i++) {\n    const randomMinute = 46 + Math.floor(Math.random() * 44); // 46-89 minutes\n    if (!secondHalfMinutes.includes(randomMinute)) {\n        secondHalfMinutes.push(randomMinute);\n    }\n}\nsecondHalfMinutes.sort((a, b) => a - b);\n\nsecondHalfMinutes.forEach(minute => {\n        const rand = Math.random();\n        if (rand < playerChance * 0.6) {\n            events.push({\n                minute,\n                type: 'goal_player',\n                message: `**${minute}' ‚öΩ SPECTACULAR GOAL!! YOUR TEAM IS UNSTOPPABLE!!** üöÄ‚ö°`,\n                delay: 2000\n            });\n        } else if (rand < (playerChance * 0.6) + (opponentChance * 0.6)) {\n            events.push({\n                minute,\n                type: 'goal_opponent',\n                message: `**${minute}' ‚öΩ Opponent strikes back! The battle intensifies!** üî•üíÄ`,\n                delay: 2000\n            });\n        } else if (rand < 0.7) {\n            const lateComments = [\n                `**${minute}' üí® PACE! Lightning speed down the wing!** ‚ö°`,\n                `**${minute}' üîÑ SUBSTITUTION! Fresh legs for the final push!** üî•`,\n                `**${minute}' ‚è∞ TIME IS TICKING! Every second counts now!** ‚åõ`,\n                `**${minute}' üé™ SKILL MOVE! What technique! The crowd goes WILD!** ü§Ø`\n            ];\n            events.push({\n                minute,\n                type: 'comment',\n                message: lateComments[Math.floor(Math.random() * lateComments.length)],\n                delay: 1500\n            });\n        }\n    });\n\n // Random interactive chance\nif (Math.random() < 0.4) {\n    const chanceMinute = 10 + Math.floor(Math.random() * 75); // 10-84 minutes\n        const kinds = ['Chance', 'Free Kick', 'Penalty']; // <-- changed as requested\n        const kind = kinds[Math.floor(Math.random() * kinds.length)];\n        \n        events.push({\n            minute: chanceMinute,\n            type: 'chance',\n            kind: kind,\n            message: `**${chanceMinute}' üéØ ${kind} OPPORTUNITY!! This could be LEGENDARY! Choose your destiny!** ‚ö°üî•`,\n            delay: 2000\n        });\n    }\n\n    // Full time\n    events.push({\n        minute: 90,\n        type: 'fulltime',\n        message: \"**90' ‚è±Ô∏è FULL TIME! What an EPIC battle!** üèÜüî•\",\n        delay: 2000\n    });\n\n    return events;\n}\n\nfunction determineOutcome(playerScore, opponentScore) {\n    if (playerScore > opponentScore) return 'win';\n    if (playerScore < opponentScore) return 'loss';\n    return 'draw';\n}\n\nmodule.exports.handleButton = async (interaction, client) => {\n    const [action, direction, userId, minute, kind] = interaction.customId.split('_');\n    \n    if (action !== 'shoot') return;\n    if (interaction.user.id !== userId) {\n        return interaction.reply({ content: \"‚õî **HEY!** This button isn't for you, champion! Wait your turn! üò§\", ephemeral: true });\n    }\n\n    const matchState = activeMatches.get(userId);\n    if (!matchState) {\n        return interaction.reply({ content: \"‚ùå **OOPS!** Match not found! Maybe it already ended? ü§î\", ephemeral: true });\n    }\n\n    await interaction.deferUpdate();\n\n    // Clear timeout if exists\n    if (matchState.chanceTimeout) {\n        clearTimeout(matchState.chanceTimeout);\n    }\n\n    // Determine outcome based on shot type and direction\n    const successRates = {\n        'Penalty': 0.75,    // <-- changed key\n        'Free Kick': 0.35,  // <-- changed key\n        'Chance': 0.50      // <-- changed key\n    };\n    \n    const successRate = successRates[kind] || 0.50;\n    const outcome = Math.random() < successRate ? 'goal' : 'miss';\n    \n    if (outcome === 'goal') {\n        matchState.playerScore++;\n    }\n\n // Update with result message (checks match new kind strings)\nlet resultMessage;\nif (outcome === 'goal') {\n    if (kind === 'Free Kick') resultMessage = `**${minute}' üéØ GOOOAL!! INCREDIBLE FREE KICK to the ${direction.toLowerCase()}! WHAT A STRIKE!** ‚ö°üî•\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n    else if (kind === 'Penalty') resultMessage = `**${minute}' ‚úÖ PENALTY GOAL!! Cool as ice, straight to the ${direction.toLowerCase()}! LEGEND!** üßäüëë\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n    else resultMessage = `**${minute}' ‚öΩ AMAZING GOAL!! Perfect finish to the ${direction.toLowerCase()}! PURE CLASS!** üåüüíé\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n} else {\n    if (kind === 'Free Kick') resultMessage = `**${minute}' üò© OH NO! Free kick ${direction.toLowerCase()} of target! So close to greatness!** üíî\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n    else if (kind === 'Penalty') resultMessage = `**${minute}' ü•Ö SAVED!! Keeper guessed ${direction.toLowerCase()} perfectly! WHAT A SAVE!** üî•üß§\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n    else resultMessage = `**${minute}' üò± BLOCKED! Keeper made an INCREDIBLE save going ${direction.toLowerCase()}!** üõ°Ô∏è‚ö°\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n}\n\n// Update match state\nmatchState.currentMinute = parseInt(minute);\n\nconst embed = createMatchEmbed(matchState, resultMessage);\nawait interaction.editReply({ embeds: [embed], components: [] });\n\n    // Resolve the promise to continue match\n    if (matchState.chanceResolve) {\n        matchState.chanceResolve();\n    }\n};\n","size_bytes":22056},"rs.js":{"content":"const { execSync, spawn } = require('child_process');\nconst path = require('path');\n\nfunction killNodeProcesses() {\n  // no-op: removed aggressive taskkill for safety\n}\n\nfunction startBot() {\n  console.log('Starting bot...');\n  const proc = spawn('node', ['index.js'], {\n    cwd: __dirname,\n    stdio: 'inherit',\n    env: process.env,\n  });\n  return proc;\n}\n\nfunction deployCommands() {\n  try {\n    console.log('Deploying slash commands...');\n    execSync('node deploy-commands.js', {\n      cwd: __dirname,\n      stdio: 'inherit',\n      env: process.env,\n    });\n    console.log('Deploy complete.');\n  } catch (err) {\n    console.error('deploy-commands failed (continuing restart):', err && err.stack ? err.stack : (err?.message || err));\n  }\n}\n\nfunction main() {\n  try {\n    console.log('Restarting bot...');\n    // 1) Deploy commands\n    deployCommands();\n    // 2) Start the bot in the current console (no handoff, no detaching)\n    startBot();\n  } catch (e) {\n    console.error('restart-bot failed:', e && e.stack ? e.stack : e);\n    process.exit(1);\n  }\n}\n\nmain();\n//taskkill /F /IM node.exe\n//node deploy-commands.js","size_bytes":1122},"README.md":{"content":"# eFotbal wannabe - Discord Bot\n\nAn eFootball-inspired Discord bot with contract mechanics, squad management, and match simulation.\n\n## Features\n\n- **Contract System**: Pull players from different packs with varying rarities\n- **Player Collection**: Collect 900+ unique players with detailed stats\n- **Squad Management**: Build your team with formations and bench players\n- **Match Simulation**: Play against AI teams and earn rewards\n- **Currency System**: Manage GP and eCoins\n- **User Profiles**: Track your progress and collection\n- **Admin Commands**: Server management tools\n\n## Setup\n\n### Prerequisites\n\n- Node.js (v16 or higher)\n- A Discord Bot Token\n\n### Installation\n\n1. Clone or download this project\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Create a Discord Application:\n   - Go to [Discord Developer Portal](https://discord.com/developers/applications)\n   - Create a new application\n   - Go to \"Bot\" section and create a bot\n   - Copy the bot token\n\n4. Configure the bot:\n   - Open `.env` file\n   - Add your bot token: `DISCORD_TOKEN=your_bot_token_here`\n\n5. Invite the bot to your server:\n   - In Discord Developer Portal, go to OAuth2 > URL Generator\n   - Select \"bot\" scope and necessary permissions\n   - Use the generated URL to invite the bot\n\n6. Start the bot:\n   ```bash\n   node index.js\n   ```\n\n## Commands\n\n### Basic Commands\n\n- `!profile` - View your profile, currency, and player collection\n- `!contract` - View available contract packs\n- `!contract <pack_name>` - Pull from a specific pack\n- `!squad` - View your current squad\n- `!match` - Simulate a match against AI\n\n### Contract Packs\n\n- `!contract iconic` - Iconic Moment Pack (500 eCoins)\n- `!contract legend` - Legend Box Draw (25,000 GP)\n- `!contract standard` - Standard Pack (10,000 GP) - Black to White rarity\n\n### Squad Management\n\n- `!squad set <position> <player_name>` - Set a player in your main squad\n- `!squad remove <position>` - Remove a player from position\n- `!squad formation <formation>` - Change formation (4-3-3, 4-4-2, 3-5-2, 4-2-3-1)\n- `!squad bench add <player_name>` - Add player to bench\n- `!squad bench remove <player_name>` - Remove player from bench\n\n### Admin Commands (Server Owner Only)\n\n- `!admin givecurrency <gp|ecoins> <amount> [user]` - Give currency to a user\n- `!reset` - Reset your own data (with confirmation)\n\n## Player Rarities\n\nFrom highest to lowest:\n- **Iconic** (Magenta) - 95-100 overall\n- **Legend** (Gold) - 90-94 overall  \n- **Black** - 85-89 overall\n- **Gold** - 80-84 overall\n- **Silver** - 75-79 overall\n- **Bronze** - 70-74 overall\n- **White** - 60-69 overall\n\n## Currency\n\n- **GP (General Points)**: Primary currency for most packs and activities\n- **eCoins**: Premium currency for special packs\n\nStarting amounts:\n- 10,000 GP\n- 100 eCoins\n\n## Match Rewards\n\n- **Win**: 5,000 GP + 10 eCoins\n- **Draw**: 2,000 GP + 5 eCoins\n- **Loss**: 1,000 GP + 2 eCoins\n\n## File Structure\n\n```\neFotbal-wannabe/\n‚îú‚îÄ‚îÄ commands/           # Bot commands\n‚îÇ   ‚îú‚îÄ‚îÄ admin.js       # Admin commands\n‚îÇ   ‚îú‚îÄ‚îÄ contract.js    # Contract system\n‚îÇ   ‚îú‚îÄ‚îÄ contract2.js   # Contract multi-pull system\n‚îÇ   ‚îú‚îÄ‚îÄ contract-info.js # Contract pack info\n‚îÇ   ‚îú‚îÄ‚îÄ match.js       # Match simulation\n‚îÇ   ‚îú‚îÄ‚îÄ profile.js     # User profiles\n‚îÇ   ‚îú‚îÄ‚îÄ reset.js       # Data reset\n‚îÇ   ‚îî‚îÄ‚îÄ squad.js       # Squad management\n‚îú‚îÄ‚îÄ data/              # User data storage\n‚îú‚îÄ‚îÄ scripts/           # Utility scripts\n‚îÇ   ‚îî‚îÄ‚îÄ generate-players.js\n‚îú‚îÄ‚îÄ .env              # Environment variables\n‚îú‚îÄ‚îÄ config.json       # Bot configuration\n‚îú‚îÄ‚îÄ index.js          # Main bot file\n‚îú‚îÄ‚îÄ package.json      # Dependencies\n‚îú‚îÄ‚îÄ players.json      # Player database\n‚îî‚îÄ‚îÄ README.md         # This file\n```\n\n## Troubleshooting\n\n### Bot doesn't respond\n- Check if the bot token is correct in `.env`\n- Ensure the bot has necessary permissions in your Discord server\n- Check the console for error messages\n\n### Commands not working\n- Make sure you're using the correct prefix (`!`)\n- Check if the bot is online and has read/send message permissions\n\n### Player data issues\n- If players.json is empty, run: `node scripts/generate-players.js`\n\n## Support\n\nIf you encounter any issues or have questions, please check the console logs for error messages. The bot logs important information that can help diagnose problems.\n\n## License\n\nThis project is for educational and entertainment purposes.\n","size_bytes":4490},"scripts/update.js":{"content":"const fs = require('fs');\n\n// Rarity-based configuration with randomized max levels\nconst RARITY_CONFIG = {\n    'Iconic': { maxLevelRange: [25, 50], statMultiplier: 1.0, overallBonus: 0 },\n    'Legend': { maxLevelRange: [20, 45], statMultiplier: 0.95, overallBonus: -2 },\n    'Black': { maxLevelRange: [25, 50], statMultiplier: 0.90, overallBonus: -5 },\n    'Gold': { maxLevelRange: [35, 45], statMultiplier: 0.85, overallBonus: -8 },\n    'Silver': { maxLevelRange: [45, 55], statMultiplier: 0.80, overallBonus: -12 },\n    'Bronze': { maxLevelRange: [40, 60], statMultiplier: 0.75, overallBonus: -16 },\n    'White': { maxLevelRange: [30, 60], statMultiplier: 0.70, overallBonus: -20 }\n};   // foii\"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"//},\n\n// Position-based stat priorities\nconst POSITION_STATS = {\n  'GK': {\n    primary: ['goalkeeping'],\n    secondary: ['defending', 'physicality'],\n    tertiary: ['passing'],\n    weak: ['attacking', 'dribbling']\n  },\n  'CB': {\n    primary: ['defending', 'physicality'],\n    secondary: ['passing'],\n    tertiary: ['goalkeeping'],\n    weak: ['attacking', 'dribbling']\n  },\n  'LB': {\n    primary: ['defending', 'dribbling'],\n    secondary: ['passing', 'physicality'], \n    tertiary: ['attacking'],\n    weak: ['goalkeeping']\n  },\n  'RB': {\n    primary: ['defending', 'dribbling'],\n    secondary: ['passing', 'physicality'], \n    tertiary: ['attacking'],\n    weak: ['goalkeeping']\n  },\n  'DMF': {\n    primary: ['defending', 'passing'],\n    secondary: ['physicality', 'dribbling'],\n    tertiary: ['attacking'],\n    weak: ['goalkeeping']\n  },\n  'CMF': {\n    primary: ['passing', 'dribbling'],\n    secondary: ['attacking', 'defending'],\n    tertiary: ['physicality'],\n    weak: ['goalkeeping']\n  },\n  'LMF': {\n    primary: ['dribbling', 'passing'],\n    secondary: ['attacking', 'physicality'],\n    tertiary: ['defending'],\n    weak: ['goalkeeping']\n  },\n  'RMF': {\n    primary: ['dribbling', 'passing'],\n    secondary: ['attacking', 'physicality'],\n    tertiary: ['defending'],\n    weak: ['goalkeeping']\n  },\n  'AMF': {\n    primary: ['attacking', 'dribbling'],\n    secondary: ['passing'],\n    tertiary: ['physicality'],\n    weak: ['defending', 'goalkeeping']\n  },\n  'LWF': {\n    primary: ['attacking', 'dribbling'],\n    secondary: ['passing'],\n    tertiary: ['physicality'],\n    weak: ['defending', 'goalkeeping']\n  },\n  'RWF': {\n    primary: ['attacking', 'dribbling'],\n    secondary: ['passing'],\n    tertiary: ['physicality'],\n    weak: ['defending', 'goalkeeping']\n  },\n  'SS': {\n    primary: ['attacking', 'dribbling'],\n    secondary: ['passing'],\n    tertiary: ['physicality'],\n    weak: ['defending', 'goalkeeping']\n  },\n  'CF': {\n    primary: ['attacking', 'physicality'],\n    secondary: ['dribbling'],\n    tertiary: ['passing'],\n    weak: ['defending', 'goalkeeping']\n  }\n};\n\nfunction getMaxStatRanges(rarity) {\n  switch (rarity) {\n    case 'Iconic':\n      return { primary: [88, 99], secondary: [78, 90], tertiary: [65, 80], weak: [20, 40] };\n    case 'Legend':\n      return { primary: [85, 96], secondary: [75, 87], tertiary: [60, 75], weak: [18, 38] };\n    case 'Black':\n      return { primary: [80, 92], secondary: [70, 82], tertiary: [55, 70], weak: [15, 35] };\n    case 'Gold':\n      return { primary: [75, 87], secondary: [65, 77], tertiary: [50, 65], weak: [15, 35] };\n    case 'Silver':\n      return { primary: [70, 82], secondary: [60, 72], tertiary: [45, 60], weak: [15, 35] };\n    case 'Bronze':\n      return { primary: [65, 77], secondary: [55, 67], tertiary: [40, 55], weak: [15, 35] };\n    case 'White':\n      return { primary: [60, 72], secondary: [50, 62], tertiary: [35, 50], weak: [15, 35] };\n    default:\n      return { primary: [60, 72], secondary: [50, 62], tertiary: [35, 50], weak: [15, 35] };\n  }\n}\n\nfunction getLevel1StatRanges(rarity) {\n  switch (rarity) {\n    case 'Iconic':\n      return { primary: [55, 65], secondary: [45, 55], tertiary: [35, 45], weak: [15, 25] };\n    case 'Legend':\n      return { primary: [53, 63], secondary: [43, 53], tertiary: [33, 43], weak: [15, 25] };\n    case 'Black':\n      return { primary: [50, 60], secondary: [40, 50], tertiary: [30, 40], weak: [15, 25] };\n    case 'Gold':\n      return { primary: [48, 58], secondary: [38, 48], tertiary: [28, 38], weak: [15, 25] };\n    case 'Silver':\n      return { primary: [45, 55], secondary: [35, 45], tertiary: [25, 35], weak: [15, 25] };\n    case 'Bronze':\n      return { primary: [43, 53], secondary: [33, 43], tertiary: [23, 33], weak: [15, 25] };\n    case 'White':\n      return { primary: [40, 50], secondary: [30, 40], tertiary: [20, 30], weak: [15, 25] };\n    default:\n      return { primary: [40, 50], secondary: [30, 40], tertiary: [20, 30], weak: [15, 25] };\n  }\n}\n\nfunction randomInRange(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction generateStatsForPlayer(player, isMaxLevel = true) {\n  const position = player.position;\n  const rarity = player.rarity;\n  \n  // Get position template or default to CMF\n  const positionTemplate = POSITION_STATS[position] || POSITION_STATS['CMF'];\n  const ranges = isMaxLevel ? getMaxStatRanges(rarity) : getLevel1StatRanges(rarity);\n  \n  const newStats = {\n    attacking: 50,\n    dribbling: 50,\n    defending: 50,\n    passing: 50,\n    physicality: 50,\n    goalkeeping: 50\n  };\n\n  // Assign primary stats (highest)\n  positionTemplate.primary.forEach(stat => {\n    newStats[stat] = randomInRange(ranges.primary[0], ranges.primary[1]);\n  });\n\n  // Assign secondary stats\n  positionTemplate.secondary.forEach(stat => {\n    newStats[stat] = randomInRange(ranges.secondary[0], ranges.secondary[1]);\n  });\n\n  // Assign tertiary stats\n  positionTemplate.tertiary.forEach(stat => {\n    newStats[stat] = randomInRange(ranges.tertiary[0], ranges.tertiary[1]);\n  });\n\n  // Assign weak stats (lowest)\n  positionTemplate.weak.forEach(stat => {\n    newStats[stat] = randomInRange(ranges.weak[0], ranges.weak[1]);\n  });\n\n  return newStats;\n}\n\nfunction calculateOverall(stats, rarity, isMaxLevel = false) {\n  // Define overall ranges for each rarity\n  const overallRanges = {\n    'Iconic': { level1: [87, 94], maxLevel: [94, 105] },\n    'Legend': { level1: [85, 88], maxLevel: [90, 100] },\n    'Black': { level1: [82, 89], maxLevel: [88, 99] },\n    'Gold': { level1: [75, 83], maxLevel: [84, 95] },\n    'Silver': { level1: [69, 78], maxLevel: [79, 92] },\n    'Bronze': { level1: [60, 69], maxLevel: [74, 89] },\n    'White': { level1: [45, 61], maxLevel: [65, 85] }\n  };\n  \n  const ranges = overallRanges[rarity] || overallRanges['White'];\n  const targetRange = isMaxLevel ? ranges.maxLevel : ranges.level1;\n  \n  // Generate random overall within the specified range\n  return randomInRange(targetRange[0], targetRange[1]);\n}\n\nfunction updatePlayersStats() {\n  try {\n    // Read the players.json file\n    const playersData = JSON.parse(fs.readFileSync('players.json', 'utf8'));\n    \n    console.log(`üîÑ Updating stats and levels for ${playersData.length} players...`);\n    \n    // Update each player's stats and level system\n    playersData.forEach((player, index) => {\n      const rarityConfig = RARITY_CONFIG[player.rarity] || RARITY_CONFIG['White'];\n      \n      // Generate random max level within rarity range\n      const randomMaxLevel = randomInRange(rarityConfig.maxLevelRange[0], rarityConfig.maxLevelRange[1]);\n      \n      // Generate max level stats\n      const maxStats = generateStatsForPlayer(player, true);\n      const maxOverall = calculateOverall(maxStats, player.rarity, true);\n      \n      // Generate level 1 stats\n      const level1Stats = generateStatsForPlayer(player, false);\n      const level1Overall = calculateOverall(level1Stats, player.rarity, false);\n      \n      // Update player with level system\n      player.level = 1;\n      player.exp = 0;\n      player.maxLevel = randomMaxLevel;\n      player.stats = level1Stats;\n      player.overall = level1Overall;\n      player.maxStats = maxStats;\n      player.maxOverall = maxOverall;\n      \n      // Log the changes for first few players as examples\n      if (index < 5) {\n        console.log(`\\n‚úÖ ${player.name} (${player.position}, ${player.rarity})`);\n        console.log(`   Level 1 Overall: ${level1Overall} | Max Overall: ${maxOverall}`);\n        console.log(`   Max Level: ${player.maxLevel}`);\n        console.log(`   Level 1 Stats: ATT:${level1Stats.attacking} DRI:${level1Stats.dribbling} DEF:${level1Stats.defending} PAS:${level1Stats.passing} PHY:${level1Stats.physicality} GK:${level1Stats.goalkeeping}`);\n        console.log(`   Max Stats: ATT:${maxStats.attacking} DRI:${maxStats.dribbling} DEF:${maxStats.defending} PAS:${maxStats.passing} PHY:${maxStats.physicality} GK:${maxStats.goalkeeping}`);\n      }\n    });\n    \n    // Create backup of original file\n    const backupName = `players_backup_${Date.now()}.json`;\n    fs.writeFileSync(backupName, fs.readFileSync('players.json'));\n    console.log(`\\nüìÇ Backup created: ${backupName}`);\n    \n    // Write updated data back to file\n    fs.writeFileSync('players.json', JSON.stringify(playersData, null, 2));\n    \n    console.log(`\\nüéâ Successfully updated stats and levels for all ${playersData.length} players!`);\n    console.log(`üíæ Updated file saved as players.json`);\n    \n    // Show some statistics\n    const rarityStats = {};\n    let totalLevel1Overall = 0;\n    let minLevel1Overall = 99;\n    let maxLevel1Overall = 0;\n    \n    playersData.forEach(player => {\n      if (!rarityStats[player.rarity]) {\n        rarityStats[player.rarity] = { count: 0, avgLevel1: 0, avgMaxLevel: 0, avgLevel1Overall: 0 };\n      }\n      rarityStats[player.rarity].count++;\n      rarityStats[player.rarity].avgMaxLevel += player.maxLevel;\n      rarityStats[player.rarity].avgLevel1Overall += player.overall;\n      \n      totalLevel1Overall += player.overall;\n      minLevel1Overall = Math.min(minLevel1Overall, player.overall);\n      maxLevel1Overall = Math.max(maxLevel1Overall, player.overall);\n    });\n    \n    console.log('\\nüìä Update Statistics:');\n    console.log(`   Overall Level 1 Range: ${minLevel1Overall} - ${maxLevel1Overall}`);\n    console.log(`   Average Level 1 Overall: ${Math.round(totalLevel1Overall / playersData.length)}`);\n    \n    Object.entries(rarityStats).forEach(([rarity, stats]) => {\n      const avgOverall = Math.round(stats.avgLevel1Overall / stats.count);\n      const avgMaxLevel = Math.round(stats.avgMaxLevel / stats.count);\n      console.log(`   ${rarity}: ${stats.count} players, Avg Level 1 Overall: ${avgOverall}, Max Level: ${avgMaxLevel}`);\n    });\n    \n  } catch (error) {\n    console.error('‚ùå Error updating player stats:', error.message);\n  }\n}\n\n// Run the update\nupdatePlayersStats();","size_bytes":10702},"commands/pvp.js":{"content":"const { \n    SlashCommandBuilder, \n    EmbedBuilder, \n    ActionRowBuilder, \n    ButtonBuilder, \n    ButtonStyle \n} = require('discord.js');\n\nconst MATCH_REWARDS = {\n    pvp: {\n        win: { gp: 12000, eCoins: 25 },\n        draw: { gp: 6000, eCoins: 15 },\n        loss: { gp: 3000, eCoins: 8 }\n    },\n    ai: {\n        win: { gp: 4000, eCoins: 8 },\n        draw: { gp: 2000, eCoins: 4 },\n        loss: { gp: 1000, eCoins: 2 }\n    }\n};\n\nconst cooldowns = new Map();\nconst activeMatches = new Map();\nconst matchmakingQueue = new Map(); // userId -> { userData, interaction, timestamp }\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('pvp')\n        .setDescription('üî• Battle against real players - PvP Football Showdown! ‚öΩ'),\n    \n    async execute(interaction) {\n        const { client } = interaction;\n        const userId = interaction.user.id;\n\n        // Cooldown check\n        const now = Date.now();\n        const cooldownAmount = 30 * 1000; // 30 seconds for PvP\n        if (cooldowns.has(userId)) {\n            const expiration = cooldowns.get(userId);\n            if (now < expiration) {\n                const remaining = Math.ceil((expiration - now) / 1000);\n                return await interaction.reply({\n                    content: `‚è≥ **EASY THERE CHAMPION!** Wait **${remaining} seconds** before your next PvP battle! üî•‚öΩ`,\n                    ephemeral: true\n                });\n            }\n        }\n\n        const userData = client.getUserData(userId);\n        if (!userData.squad || userData.squad.main.length < 11) {\n            return await interaction.reply({\n                content: 'üö® **HOLD UP!** You need 11 players in your squad before facing real opponents! Build your DREAM TEAM first! üí™‚öΩ',\n                ephemeral: true\n            });\n        }\n\n        // Check if already in queue or match\n        if (matchmakingQueue.has(userId) || activeMatches.has(userId)) {\n            return await interaction.reply({\n                content: '‚ö†Ô∏è **You\\'re already in matchmaking or in a match!** Wait for it to finish first! üéÆ',\n                ephemeral: true\n            });\n        }\n\n        cooldowns.set(userId, now + cooldownAmount);\n\n        // Show connection status embed\n        const connectionEmbed = new EmbedBuilder()\n            .setTitle('üîç **SEARCHING FOR OPPONENT...**')\n            .setDescription('‚è≥ Checking connection status...\\nüåê Looking for worthy opponents online!')\n            .setColor('#f39c12')\n            .addFields(\n                { name: 'üë§ Your Team', value: `**${interaction.user.username}**`, inline: true },\n                { name: 'üéØ Status', value: 'üîÑ **CONNECTING...**', inline: true },\n                { name: '‚ö° Mode', value: '**PvP Battle**', inline: true }\n            )\n            .setFooter({ text: 'Finding the perfect match for you...' });\n\n        await interaction.reply({ embeds: [connectionEmbed] });\n\n        // Add to matchmaking queue\n        matchmakingQueue.set(userId, {\n            userData,\n            interaction,\n            timestamp: now,\n            username: interaction.user.username\n        });\n\n        // Try to find a match\n        setTimeout(async () => {\n            await findMatch(userId, client);\n        }, 2000); // 2 second delay for \"connection checking\"\n    }\n};\n\nasync function findMatch(userId, client) {\n    const playerData = matchmakingQueue.get(userId);\n    if (!playerData) return;\n\n    // Look for another player in queue (excluding self)\n    const availableOpponents = Array.from(matchmakingQueue.entries())\n        .filter(([id, data]) => id !== userId && (Date.now() - data.timestamp) < 60000) // Within 1 minute\n        .sort((a, b) => a[1].timestamp - b[1].timestamp); // Oldest first\n\n    let opponent = null;\n    let opponentId = null;\n\n    if (availableOpponents.length > 0) {\n        // Found a real opponent\n        [opponentId, opponent] = availableOpponents[0];\n    } else {\n        // No real opponent found, create AI opponent based on existing users on disk\n        const allUserIds = (typeof client.listAllUserIds === 'function' ? client.listAllUserIds() : []).filter(id => id !== userId);\n        if (allUserIds.length > 0) {\n            opponentId = allUserIds[Math.floor(Math.random() * allUserIds.length)];\n            const opponentUserData = client.getUserData(opponentId);\n            \n            // Try to get Discord user info\n            let opponentUsername = 'AI Opponent';\n            try {\n                const discordUser = await client.users.fetch(opponentId);\n                opponentUsername = discordUser.username;\n            } catch (error) {\n                // Fallback to generic name if user not found\n                opponentUsername = `Player ${opponentId.slice(-4)}`;\n            }\n\n            opponent = {\n                userData: opponentUserData,\n                interaction: null, // AI opponent\n                timestamp: Date.now(),\n                username: opponentUsername\n            };\n        }\n    }\n\n    if (!opponent) {\n        // No opponents available, update embed\n        const noOpponentEmbed = new EmbedBuilder()\n            .setTitle('üòî **NO OPPONENTS FOUND**')\n            .setDescription('üåê No other players are currently looking for a match!\\n\\n‚è∞ **Try again in a few minutes** or invite friends to play!')\n            .setColor('#e74c3c')\n            .addFields(\n                { name: 'üí° Tip', value: 'Share the bot with friends for more PvP action!', inline: false }\n            );\n\n        await playerData.interaction.editReply({ embeds: [noOpponentEmbed] });\n        matchmakingQueue.delete(userId);\n        return;\n    }\n\n    // Remove both players from queue\n    matchmakingQueue.delete(userId);\n    if (opponentId && matchmakingQueue.has(opponentId)) {\n        matchmakingQueue.delete(opponentId);\n    }\n\n    // Start the match\n    await startPvPMatch(playerData, opponent, opponentId, client);\n}\n\nasync function startPvPMatch(player1, player2, player2Id, client) {\n    const teamStrength1 = calculateTeamStrength(player1.userData, client);\n    const teamStrength2 = calculateTeamStrength(player2.userData, client);\n\n    // Create match state\n    const matchState = {\n        player1Score: 0,\n        player2Score: 0,\n        events: [],\n        currentMinute: 0,\n        player1: {\n            id: player1.interaction.user.id,\n            username: player1.username,\n            strength: teamStrength1\n        },\n        player2: {\n            id: player2Id,\n            username: player2.username,\n            strength: teamStrength2,\n            isAI: !player2.interaction // Mark if AI opponent\n        }\n    };\n\n    activeMatches.set(player1.interaction.user.id, matchState);\n    if (player2.interaction) {\n        activeMatches.set(player2Id, matchState);\n    }\n\n    // Update connection embed to show match found\n    const matchFoundEmbed = new EmbedBuilder()\n        .setTitle('‚úÖ **OPPONENT FOUND!**')\n        .setDescription(`üéÆ **${player1.username}** üÜö **${player2.username}**\\n\\nüî• **MATCH STARTING...**`)\n        .setColor('#27ae60')\n        .addFields(\n            { name: '‚öΩ Score', value: '**0 - 0**', inline: true },\n            { name: '‚è∞ Time', value: \"**0' - KICK OFF!** üöÄ\", inline: true },\n            { name: 'üí™ Team Power', value: `**${teamStrength1}** vs **${teamStrength2}**`, inline: true }\n        )\n        .setFooter({ text: 'üî• PvP MATCH IS STARTING! Get ready for EPIC action!' });\n\n    await player1.interaction.editReply({ embeds: [matchFoundEmbed] });\n\n    // If real opponent, notify them too\n    if (player2.interaction) {\n        try {\n            await player2.interaction.editReply({ embeds: [matchFoundEmbed] });\n        } catch (error) {\n            console.log('Could not update opponent embed:', error.message);\n        }\n    }\n\n    // Generate and process match events\n    const matchEvents = generatePvPMatchTimeline(teamStrength1, teamStrength2);\n    await processPvPMatchEvents(player1.interaction, player2.interaction, matchEvents, matchState, client);\n}\n\nfunction generatePvPMatchTimeline(strength1, strength2) {\n    const events = [];\n    const totalStrength = strength1 + strength2;\n    const player1Chance = strength1 / totalStrength;\n    const player2Chance = strength2 / totalStrength;\n\n    // First half events (0-45 minutes)\n    const firstHalfMinutes = [];\n    for (let i = 0; i < 4; i++) {\n        const randomMinute = 5 + Math.floor(Math.random() * 40);\n        firstHalfMinutes.push(randomMinute);\n    }\n    firstHalfMinutes.sort((a, b) => a - b);\n\n    firstHalfMinutes.forEach(minute => {\n        const rand = Math.random();\n        if (rand < player1Chance * 0.4) {\n            events.push({\n                minute,\n                type: 'goal_player1',\n                message: `**${minute}' ‚öΩ SPECTACULAR GOAL by ${events.length > 0 ? 'Player 1' : 'you'}!!** üöÄ‚ö°`,\n                delay: 2000\n            });\n        } else if (rand < (player1Chance * 0.4) + (player2Chance * 0.4)) {\n            events.push({\n                minute,\n                type: 'goal_player2',\n                message: `**${minute}' ‚öΩ AMAZING GOAL by the opponent!** üî•üíÄ`,\n                delay: 2000\n            });\n        } else if (rand < 0.6) {\n            const comments = [\n                `**${minute}' üí® Lightning fast attack!** ‚ö°`,\n                `**${minute}' üõ°Ô∏è Solid defensive play!** üîí`,\n                `**${minute}' üéØ Close chance! So near!** üò±`,\n                `**${minute}' üî• The intensity is building!** üí™`\n            ];\n            events.push({\n                minute,\n                type: 'comment',\n                message: comments[Math.floor(Math.random() * comments.length)],\n                delay: 1500\n            });\n        }\n    });\n\n    // Half time\n    events.push({\n        minute: 45,\n        type: 'halftime',\n        message: \"**45' ‚è±Ô∏è HALF TIME! What a battle so far!** üî•\",\n        delay: 2000\n    });\n\n    // Second half events (46-90 minutes)\n    const secondHalfMinutes = [];\n    for (let i = 0; i < 5; i++) {\n        const randomMinute = 46 + Math.floor(Math.random() * 44);\n        secondHalfMinutes.push(randomMinute);\n    }\n    secondHalfMinutes.sort((a, b) => a - b);\n\n    secondHalfMinutes.forEach(minute => {\n        const rand = Math.random();\n        if (rand < player1Chance * 0.6) {\n            events.push({\n                minute,\n                type: 'goal_player1',\n                message: `**${minute}' ‚öΩ INCREDIBLE GOAL!! UNSTOPPABLE!!** üöÄ‚ö°`,\n                delay: 2000\n            });\n        } else if (rand < (player1Chance * 0.6) + (player2Chance * 0.6)) {\n            events.push({\n                minute,\n                type: 'goal_player2',\n                message: `**${minute}' ‚öΩ BRILLIANT STRIKE! What a response!** üî•üíÄ`,\n                delay: 2000\n            });\n        } else if (rand < 0.7) {\n            const lateComments = [\n                `**${minute}' üí® PACE! Lightning speed!** ‚ö°`,\n                `**${minute}' üîÑ Tactical substitution!** üî•`,\n                `**${minute}' ‚è∞ Time is running out!** ‚åõ`,\n                `**${minute}' üé™ SKILL! The crowd goes WILD!** ü§Ø`\n            ];\n            events.push({\n                minute,\n                type: 'comment',\n                message: lateComments[Math.floor(Math.random() * lateComments.length)],\n                delay: 1500\n            });\n        }\n    });\n\n    // Interactive chance\n    if (Math.random() < 0.5) {\n        const chanceMinute = 15 + Math.floor(Math.random() * 70);\n        const kinds = ['Chance', 'Free Kick', 'Penalty'];\n        const kind = kinds[Math.floor(Math.random() * kinds.length)];\n        \n        events.push({\n            minute: chanceMinute,\n            type: 'chance',\n            kind: kind,\n            message: `**${chanceMinute}' üéØ ${kind} OPPORTUNITY!! This could change everything!** ‚ö°üî•`,\n            delay: 2000\n        });\n    }\n\n    // Full time\n    events.push({\n        minute: 90,\n        type: 'fulltime',\n        message: \"**90' ‚è±Ô∏è FULL TIME! What an EPIC PvP battle!** üèÜüî•\",\n        delay: 2000\n    });\n\n    return events;\n}\n\nasync function processPvPMatchEvents(interaction1, interaction2, events, matchState, client) {\n    events.sort((a, b) => a.minute - b.minute);\n\n    for (const event of events) {\n        await new Promise(r => setTimeout(r, event.delay));\n        \n        // Update match state\n        if (event.type === 'goal_player1') {\n            matchState.player1Score++;\n        } else if (event.type === 'goal_player2') {\n            matchState.player2Score++;\n        }\n\n        matchState.currentMinute = event.minute;\n\n        // Handle interactive chances\n        if (event.type === 'chance') {\n            await handlePvPChance(interaction1, interaction2, event, matchState);\n            continue;\n        }\n\n        // Create and send embeds\n        const embed = createPvPMatchEmbed(matchState, event.message);\n        \n        try {\n            await interaction1.editReply({ embeds: [embed] });\n        } catch (error) {\n            console.log('Could not update player 1 embed:', error.message);\n        }\n\n        if (interaction2) {\n            try {\n                await interaction2.editReply({ embeds: [embed] });\n            } catch (error) {\n                console.log('Could not update player 2 embed:', error.message);\n            }\n        }\n\n        // Handle full time\n        if (event.type === 'fulltime') {\n            await handlePvPMatchEnd(interaction1, interaction2, matchState, client);\n            break;\n        }\n    }\n}\n\nasync function handlePvPChance(interaction1, interaction2, event, matchState) {\n    const buttons = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId(`pvpshoot_left_${matchState.player1.id}_${event.minute}_${event.kind}`)\n                .setLabel('‚¨ÖÔ∏è LEFT')\n                .setStyle(ButtonStyle.Primary),\n            new ButtonBuilder()\n                .setCustomId(`pvpshoot_center_${matchState.player1.id}_${event.minute}_${event.kind}`)\n                .setLabel('üéØ CENTER')\n                .setStyle(ButtonStyle.Success),\n            new ButtonBuilder()\n                .setCustomId(`pvpshoot_right_${matchState.player1.id}_${event.minute}_${event.kind}`)\n                .setLabel('‚û°Ô∏è RIGHT')\n                .setStyle(ButtonStyle.Primary)\n        );\n\n    const embed = createPvPMatchEmbed(matchState, event.message);\n    \n    try {\n        await interaction1.editReply({ embeds: [embed], components: [buttons] });\n    } catch (error) {\n        console.log('Could not update player 1 chance embed:', error.message);\n    }\n\n    if (interaction2) {\n        try {\n            await interaction2.editReply({ embeds: [embed] });\n        } catch (error) {\n            console.log('Could not update player 2 chance embed:', error.message);\n        }\n    }\n\n    // Wait for button interaction or timeout\n    return new Promise((resolve) => {\n        matchState.chanceResolve = resolve;\n        matchState.chanceTimeout = setTimeout(() => {\n            // Auto-miss if no response\n            const autoEmbed = createPvPMatchEmbed(matchState, `**${event.minute}' ‚è∞ TIME'S UP! Opportunity missed!** üò±\\n\\n*CHANCE COMPLETED* ‚úÖ`);\n            interaction1.editReply({ embeds: [autoEmbed], components: [] }).catch(() => {});\n            if (interaction2) {\n                interaction2.editReply({ embeds: [autoEmbed], components: [] }).catch(() => {});\n            }\n            resolve();\n        }, 10000);\n    });\n}\n\nfunction createPvPMatchEmbed(matchState, message) {\n    return new EmbedBuilder()\n        .setTitle('‚öΩ **PvP FOOTBALL BATTLE** üî•')\n        .setDescription(`**${matchState.player1.username}** üÜö **${matchState.player2.username}**${matchState.player2.isAI ? ' (AI)' : ''}`)\n        .addFields(\n            { name: '‚öΩ Score', value: `**${matchState.player1Score} - ${matchState.player2Score}**`, inline: true },\n            { name: '‚è∞ Time', value: `**${matchState.currentMinute}'**`, inline: true },\n            { name: 'üí™ Power', value: `**${matchState.player1.strength}** vs **${matchState.player2.strength}**`, inline: true },\n            { name: 'üìù Match Update', value: message, inline: false }\n        )\n        .setColor('#e74c3c')\n        .setFooter({ text: 'üî• PvP BATTLE IN PROGRESS!' });\n}\n\nasync function handlePvPMatchEnd(interaction1, interaction2, matchState, client) {\n    // Determine outcomes\n    const player1Outcome = determineOutcome(matchState.player1Score, matchState.player2Score);\n    const player2Outcome = determineOutcome(matchState.player2Score, matchState.player1Score);\n\n    // Determine reward type based on opponent\n    const rewardType = matchState.player2.isAI ? 'ai' : 'pvp';\n\n    // Award rewards\n    const player1Data = client.getUserData(matchState.player1.id);\n    const player1Rewards = MATCH_REWARDS[rewardType][player1Outcome];\n    player1Data.gp += player1Rewards.gp;\n    player1Data.eCoins += player1Rewards.eCoins;\n    client.setUserData(matchState.player1.id, player1Data);\n\n    if (!matchState.player2.isAI) {\n        const player2Data = client.getUserData(matchState.player2.id);\n        const player2Rewards = MATCH_REWARDS.pvp[player2Outcome];\n        player2Data.gp += player2Rewards.gp;\n        player2Data.eCoins += player2Rewards.eCoins;\n        client.setUserData(matchState.player2.id, player2Data);\n    }\n\n    // Create final embeds\n    const finalEmbed1 = new EmbedBuilder()\n        .setTitle(`üèÜ **MATCH RESULT: ${player1Outcome.toUpperCase()}!** üèÜ`)\n        .setDescription(`**Final Score:** ${matchState.player1Score} - ${matchState.player2Score}`)\n        .addFields(\n            { name: 'üí∞ Rewards Earned', value: `**+${player1Rewards.gp.toLocaleString()} GP**\\n**+${player1Rewards.eCoins} eCoins**`, inline: true },\n            { name: 'üéÆ Match Type', value: matchState.player2.isAI ? '**vs AI**' : '**PvP Battle**', inline: true },\n            { name: 'üî• Result', value: getResultMessage(player1Outcome), inline: false }\n        )\n        .setColor(getResultColor(player1Outcome))\n        .setFooter({ text: 'Great PvP match! Play again soon!' });\n\n    try {\n        await interaction1.editReply({ embeds: [finalEmbed1], components: [] });\n    } catch (error) {\n        console.log('Could not send final embed to player 1:', error.message);\n    }\n\n    if (interaction2) {\n        const finalEmbed2 = new EmbedBuilder()\n            .setTitle(`üèÜ **MATCH RESULT: ${player2Outcome.toUpperCase()}!** üèÜ`)\n            .setDescription(`**Final Score:** ${matchState.player2Score} - ${matchState.player1Score}`)\n            .addFields(\n                { name: 'üí∞ Rewards Earned', value: `**+${MATCH_REWARDS.pvp[player2Outcome].gp.toLocaleString()} GP**\\n**+${MATCH_REWARDS.pvp[player2Outcome].eCoins} eCoins**`, inline: true },\n                { name: 'üéÆ Match Type', value: '**PvP Battle**', inline: true },\n                { name: 'üî• Result', value: getResultMessage(player2Outcome), inline: false }\n            )\n            .setColor(getResultColor(player2Outcome))\n            .setFooter({ text: 'Great PvP match! Play again soon!' });\n\n        try {\n            await interaction2.editReply({ embeds: [finalEmbed2], components: [] });\n        } catch (error) {\n            console.log('Could not send final embed to player 2:', error.message);\n        }\n    }\n\n    // Clean up\n    activeMatches.delete(matchState.player1.id);\n    if (!matchState.player2.isAI) {\n        activeMatches.delete(matchState.player2.id);\n    }\n}\n\n// Import utility functions from match.js\nfunction calculateTeamStrength(userData, client) {\n    if (!userData.squad || !userData.squad.main || userData.squad.main.length < 11) {\n        return 50; // Default low strength\n    }\n\n    let totalStrength = 0;\n    let playerCount = 0;\n\n    for (const playerId of userData.squad.main) {\n        if (playerId) {\n            const player = userData.players.find(p => p.id === playerId);\n            if (player) {\n                totalStrength += player.overall;\n                playerCount++;\n            }\n        }\n    }\n\n    return playerCount > 0 ? Math.round(totalStrength / playerCount) : 50;\n}\n\nfunction determineOutcome(playerScore, opponentScore) {\n    if (playerScore > opponentScore) return 'win';\n    if (playerScore < opponentScore) return 'loss';\n    return 'draw';\n}\n\nfunction getResultMessage(outcome) {\n    const messages = {\n        win: 'üéâ **VICTORY!** You dominated the field! üèÜ',\n        draw: 'ü§ù **DRAW!** A hard-fought battle! ‚öñÔ∏è',\n        loss: 'üí™ **DEFEAT!** You fought bravely! üõ°Ô∏è'\n    };\n    return messages[outcome] || '‚öΩ Match completed!';\n}\n\nfunction getResultColor(outcome) {\n    const colors = {\n        win: '#27ae60',\n        draw: '#f39c12',\n        loss: '#e74c3c'\n    };\n    return colors[outcome] || '#95a5a6';\n}\n\n// Handle PvP button interactions\nmodule.exports.handleButton = async (interaction, client) => {\n    const [action, direction, userId, minute, kind] = interaction.customId.split('_');\n    \n    if (action !== 'pvpshoot') return;\n    if (interaction.user.id !== userId) {\n        return interaction.reply({ content: \"‚õî **HEY!** This button isn't for you! üò§\", ephemeral: true });\n    }\n\n    const matchState = activeMatches.get(userId);\n    if (!matchState) {\n        return interaction.reply({ content: \"‚ùå **OOPS!** Match not found! ü§î\", ephemeral: true });\n    }\n\n    await interaction.deferUpdate();\n\n    if (matchState.chanceTimeout) {\n        clearTimeout(matchState.chanceTimeout);\n    }\n\n    // Determine outcome\n    const successRates = {\n        'Penalty': 0.75,\n        'Free Kick': 0.35,\n        'Chance': 0.50\n    };\n    \n    const successRate = successRates[kind] || 0.50;\n    const outcome = Math.random() < successRate ? 'goal' : 'miss';\n    \n    if (outcome === 'goal') {\n        matchState.player1Score++;\n    }\n\n    // Create result message\n    let resultMessage;\n    if (outcome === 'goal') {\n        if (kind === 'Free Kick') resultMessage = `**${minute}' üéØ GOOOAL!! INCREDIBLE FREE KICK to the ${direction.toLowerCase()}!** ‚ö°üî•\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n        else if (kind === 'Penalty') resultMessage = `**${minute}' ‚úÖ PENALTY GOAL!! Perfect shot to the ${direction.toLowerCase()}!** üßäüëë\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n        else resultMessage = `**${minute}' ‚öΩ AMAZING GOAL!! Perfect finish to the ${direction.toLowerCase()}!** üåüüíé\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n    } else {\n        if (kind === 'Free Kick') resultMessage = `**${minute}' üò© OH NO! Free kick ${direction.toLowerCase()} of target!** üíî\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n        else if (kind === 'Penalty') resultMessage = `**${minute}' ü•Ö SAVED!! Keeper guessed ${direction.toLowerCase()} perfectly!** üî•üß§\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n        else resultMessage = `**${minute}' üò± BLOCKED! Keeper made an INCREDIBLE save going ${direction.toLowerCase()}!** üõ°Ô∏è‚ö°\\n\\n*CHANCE COMPLETED* ‚úÖ`;\n    }\n\n    matchState.currentMinute = parseInt(minute);\n\n    const embed = createPvPMatchEmbed(matchState, resultMessage);\n    await interaction.editReply({ embeds: [embed], components: [] });\n\n    // Resolve the promise to continue match\n    if (matchState.chanceResolve) {\n        matchState.chanceResolve();\n    }\n};\n","size_bytes":23499},"commands/use.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\nconst config = require('../config.json');\nconst players = require('../players.json');\n\nfunction getAvailablePacks(userData) {\n  const fp = (userData.inventory && userData.inventory.freePacks) || { Iconic: 0, Legend: 0, Black: 0 };\n  const options = [];\n  if (fp.Iconic > 0) options.push({ name: `Iconic Pack (${fp.Iconic})`, value: 'Iconic' });\n  if (fp.Legend > 0) options.push({ name: `Legend Pack (${fp.Legend})`, value: 'Legend' });\n  if (fp.Black > 0) options.push({ name: `Black Pack (${fp.Black})`, value: 'Black' });\n  return options;\n}\n\nfunction pullByRarity(rarity) {\n  const pool = players.filter(p => p.rarity === rarity);\n  if (pool.length === 0) return null;\n  return pool[Math.floor(Math.random() * pool.length)];\n}\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('use')\n    .setDescription('Use a free item')\n    .addStringOption(o => o\n      .setName('pack')\n      .setDescription('Free pack to open')\n      .setAutocomplete(true)\n      .setRequired(true)\n    ),\n\n  async autocomplete(interaction) {\n    const { client } = interaction;\n    const userData = client.getUserData(interaction.user.id);\n    const opts = getAvailablePacks(userData).slice(0, 25);\n    await interaction.respond(opts);\n  },\n\n  async execute(interaction) {\n    const { client } = interaction;\n    const userData = client.getUserData(interaction.user.id);\n    const rarity = interaction.options.getString('pack');\n\n    if (!['Iconic', 'Legend', 'Black'].includes(rarity)) {\n      return await interaction.reply({ content: 'Invalid pack selection.', ephemeral: true });\n    }\n\n    const fp = (userData.inventory && userData.inventory.freePacks) || { Iconic: 0, Legend: 0, Black: 0 };\n    if (!fp[rarity] || fp[rarity] <= 0) {\n      return await interaction.reply({ content: `You have no free ${rarity} packs.`, ephemeral: true });\n    }\n\n    // Consume one pack\n    fp[rarity] -= 1;\n    userData.inventory.freePacks = fp;\n\n    const pulled = pullByRarity(rarity);\n    if (!pulled) {\n      return await interaction.reply({ content: `No players available for rarity ${rarity}.`, ephemeral: true });\n    }\n\n    // Defer to allow preview + delay safely\n    await interaction.deferReply();\n\n// 1) Send initial reply immediately\nawait interaction.editReply({ content: `Opening free ${rarity} pack...` });\nawait new Promise(r => setTimeout(r, 1000));\n\n// 2) Send rarity GIF preview for 10 seconds\nconst preview = new EmbedBuilder()\n  .setTitle(`Free ${rarity} Pack ‚Äî Opening...`)\n  .setColor(rarity === 'Iconic' ? '#FF00FF' : (rarity === 'Legend' ? '#FFD700' : '#000000'));\n\nconst gif = getRarityGif(rarity);\nlet files = [];\nif (gif) {\n  if (gif.type === 'attachment') {\n    preview.setImage(`attachment://${gif.filename}`);\n    files = [gif.filePath];\n  } else if (gif.type === 'url') {\n    preview.setImage(gif.url);\n  }\n}\nawait interaction.editReply({ embeds: [preview], files });\nawait new Promise(r => setTimeout(r, 10000));\n\n    // Add to collection unless duplicate; duplicates convert to GP\n    const isDuplicate = userData.players.some(p => p.id === pulled.id);\n    let footer = '';\n    if (isDuplicate) {\n      // Simple sellback values aligned with gacha.js\n      const sellValue = { Iconic: 50000, Legend: 25000, Black: 10000 }[rarity] || 5000;\n      userData.gp += sellValue;\n      footer = `Duplicate! +${sellValue.toLocaleString()} GP.`;\n    } else {\n      userData.players.push(pulled);\n      footer = 'New player added to your collection!';\n    }\n\n    client.setUserData(interaction.user.id, userData);\n\n    const embed = new EmbedBuilder()\n      .setTitle(`Free ${rarity} Pack ‚Äî Result`)\n      .setColor(rarity === 'Iconic' ? '#FF00FF' : (rarity === 'Legend' ? '#FFD700' : '#000000'))\n      .setDescription(`You opened a free ${rarity} pack and got **${pulled.name}**!`)\n      .addFields(\n        { name: 'Overall', value: String(pulled.overall), inline: true },\n        { name: 'Position', value: pulled.position, inline: true },\n      )\n      .setFooter({ text: footer });\n\n    await interaction.editReply({ embeds: [embed], files: [] });\n  }\n};\n\nfunction getRarityGif(rarity) {\n  const lower = String(rarity || '').toLowerCase();\n  const filename = `${lower}.gif`;\n  const filePath = path.join(__dirname, '..', 'assets', 'gifs', filename);\n  if (fs.existsSync(filePath)) {\n    return { type: 'attachment', filename, filePath };\n  }\n  const url = config?.gachaGifs?.[rarity];\n  if (url) return { type: 'url', url };\n  return null;\n}\n","size_bytes":4583},"PLAYER_FACES_UPDATE.md":{"content":"# ‚öΩ Player Faces & Available Players Update\n\n## ‚úÖ **Changes Made:**\n\n### **1. Local Player Face Images** üñºÔ∏è\nAll player images now load from local assets folder!\n\n**Image Path:**\n```\n/assets/faces/[player_name].png\n```\n\n**Fallback:**\n```\n/assets/faces/default_player.png\n```\n\n### **2. Reserves Section Removed** üóëÔ∏è\n- Removed reserves section completely\n- Simplified to: **Squad + Bench only**\n- No more unlimited storage\n\n### **3. Available Players - FIFA Style** üéÆ\nAvailable players now display with FIFA-style cards!\n\n---\n\n## üñºÔ∏è **Image System:**\n\n### **File Structure:**\n```\nassets/\n  faces/\n    ‚îú‚îÄ‚îÄ default_player.png (fallback)\n    ‚îú‚îÄ‚îÄ Lionel Messi.png\n    ‚îú‚îÄ‚îÄ Cristiano Ronaldo.png\n    ‚îú‚îÄ‚îÄ Kenny Abshire.png\n    ‚îî‚îÄ‚îÄ [player_name].png\n```\n\n### **How It Works:**\n1. System looks for: `/assets/faces/${player.name}.png`\n2. If not found ‚Üí Uses `default_player.png`\n3. Works for all sections: Squad, Bench, Available\n\n---\n\n## üé® **Available Players - New Design:**\n\n### **Before:**\n```\nSimple list\nNo images\nBasic cards\n```\n\n### **After (FIFA Style):**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ 92      CMF ‚îÇ ‚Üê Rating + Position\n‚îÇ   [FACE]    ‚îÇ ‚Üê Player Photo\n‚îÇ   Messi ‚≠ê  ‚îÇ ‚Üê Name + Rarity\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### **Features:**\n- ‚úÖ **Rating badge** (top-left, yellow)\n- ‚úÖ **Position badge** (top-right)\n- ‚úÖ **Rarity icon** (top-right, below position)\n- ‚úÖ **Circular face image** (70x70px)\n- ‚úÖ **Player name** (below image)\n- ‚úÖ **Draggable** to squad or bench\n- ‚úÖ **Hover effects** (scale + glow)\n\n---\n\n## üéØ **Card Sizes:**\n\n| Section | Card Width | Image Size | Border Color |\n|---------|-----------|------------|--------------|\n| **Squad** | 110px | 80x80px | Yellow |\n| **Bench** | 90px | 60x60px | Yellow |\n| **Available** | 110px | 70x70px | Yellow |\n\n---\n\n## üîÑ **Drag & Drop:**\n\n### **Available Players ‚Üí Squad:**\n```\n1. Drag player card from available section\n2. Drop on squad position\n3. Player added to squad\n4. Removed from available list\n```\n\n### **Available Players ‚Üí Bench:**\n```\n1. Drag player card\n2. Drop on bench section\n3. Player added to bench (max 8)\n4. Removed from available list\n```\n\n### **Auto-Scroll:**\n- Drag near top ‚Üí Scrolls up\n- Drag near bottom ‚Üí Scrolls down\n- Smooth scrolling experience\n\n---\n\n## üì¶ **What Was Removed:**\n\n### **Reserves Section:**\n- ‚ùå Reserves section HTML\n- ‚ùå Reserves rendering function\n- ‚ùå Reserves drag handlers\n- ‚ùå Reserves drop zones\n- ‚ùå Reserves variables\n- ‚ùå Reserves CSS\n\n### **Now Only:**\n- ‚úÖ Squad (11 players)\n- ‚úÖ Bench (max 8 players)\n- ‚úÖ Available players (unlimited)\n\n---\n\n## üéÆ **Available Players Features:**\n\n### **Draggable:**\n```javascript\n// Can drag to:\n- Squad positions ‚úÖ\n- Bench section ‚úÖ\n- Auto-scroll enabled ‚úÖ\n```\n\n### **Visual Feedback:**\n```css\nHover: Scale up + yellow glow\nDragging: 50% opacity\nDrop zones: Highlight on dragover\n```\n\n### **Grid Layout:**\n```css\nGrid: Auto-fill, 120px min\nGap: 15px\nCentered: Yes\nResponsive: Yes\n```\n\n---\n\n## üñºÔ∏è **Setting Up Player Faces:**\n\n### **Step 1: Create Folder**\n```\nCreate: assets/faces/\n```\n\n### **Step 2: Add Images**\n```\nSave player images as:\n- [Exact Player Name].png\n- Example: \"Kenny Abshire.png\"\n- Example: \"Lionel Messi.png\"\n```\n\n### **Step 3: Add Default**\n```\nCreate: default_player.png\n- Used when player image not found\n- Fallback for all players\n```\n\n### **Image Requirements:**\n- **Format:** PNG (recommended)\n- **Size:** Any (auto-scaled)\n- **Naming:** Exact match with player name\n- **Case-sensitive:** Yes\n\n---\n\n## üí° **Examples:**\n\n### **Player Name in Database:**\n```\n\"Kenny Abshire\"\n```\n\n### **Image File Name:**\n```\nKenny Abshire.png\n```\n\n### **Full Path:**\n```\n/assets/faces/Kenny Abshire.png\n```\n\n### **If Not Found:**\n```\nFalls back to: /assets/faces/default_player.png\n```\n\n---\n\n## üé® **CSS Classes Added:**\n\n### **Available Player Cards:**\n```css\n.available-player-card\n.available-card-rating\n.available-card-position\n.available-card-rarity\n.available-card-image\n.available-card-name\n```\n\n### **Styling:**\n- Blue gradient background\n- Yellow border\n- Circular image\n- Hover: Scale + glow\n- Dragging: Opacity 0.5\n\n---\n\n## üöÄ **How to Test:**\n\n### **1. Add Player Images:**\n```\n1. Create assets/faces/ folder\n2. Add default_player.png\n3. Add player images (exact names)\n```\n\n### **2. Refresh Browser:**\n```\nCtrl + F5 (Windows)\nCmd + Shift + R (Mac)\n```\n\n### **3. Check Available Players:**\n```\n- Should show FIFA-style cards\n- Should show player faces\n- Should be draggable\n```\n\n### **4. Test Drag & Drop:**\n```\n- Drag to squad ‚Üí Works ‚úÖ\n- Drag to bench ‚Üí Works ‚úÖ\n- Auto-scroll ‚Üí Works ‚úÖ\n```\n\n---\n\n## üìä **Before vs After:**\n\n### **Before:**\n```\nSquad: FIFA-style ‚úÖ\nBench: FIFA-style ‚úÖ\nReserves: Simple cards ‚ùå\nAvailable: Simple list ‚ùå\nImages: External URLs ‚ùå\n```\n\n### **After:**\n```\nSquad: FIFA-style ‚úÖ\nBench: FIFA-style ‚úÖ\nReserves: Removed ‚úÖ\nAvailable: FIFA-style ‚úÖ\nImages: Local assets ‚úÖ\n```\n\n---\n\n## ‚úÖ **Summary:**\n\n1. ‚úÖ **Local images** - All faces from `/assets/faces/`\n2. ‚úÖ **Default fallback** - `default_player.png` for missing images\n3. ‚úÖ **Reserves removed** - Simplified to Squad + Bench\n4. ‚úÖ **Available players** - FIFA-style cards with faces\n5. ‚úÖ **Draggable** - Can drag to squad or bench\n6. ‚úÖ **Auto-scroll** - Smooth scrolling when dragging\n7. ‚úÖ **Consistent design** - All sections use same style\n\n---\n\n## üéâ **Result:**\n\n**All player cards now show faces from local assets!**\n- Squad, Bench, and Available players all have FIFA-style cards\n- Images load from `/assets/faces/[player_name].png`\n- Falls back to `default_player.png` if image not found\n- Available players are draggable to squad or bench\n- No more reserves section - simplified interface\n\n**Just add your player images to `assets/faces/` and refresh!** ‚öΩüéÆ\n","size_bytes":5931},"PLAYER_FACE_CARDS.md":{"content":"# ‚öΩ FIFA-Style Player Face Cards\n\n## ‚úÖ **New Visual Design!**\n\nAll player cards now display with **player face images** in FIFA/eFootball style!\n\n---\n\n## üé® **Card Design:**\n\n### **Squad Pitch Cards:**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ 92  ‚ÜêRating  CF ‚îÇ‚Üê Position\n‚îÇ                 ‚îÇ\n‚îÇ    [FACE IMG]   ‚îÇ‚Üê Player Photo\n‚îÇ                 ‚îÇ\n‚îÇ   Messi ‚≠ê      ‚îÇ‚Üê Name + Rarity\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### **Features:**\n- **Rating Badge** (top-left, yellow background)\n- **Position Badge** (top-right, dark background)\n- **Circular Face Image** (80x80px, yellow border)\n- **Player Name** (below image)\n- **Rarity Icon** (emoji badge)\n\n---\n\n## üì¶ **All Sections Updated:**\n\n### **1. Squad Pitch** ‚öΩ\n- Large cards (110px wide)\n- 80x80px face images\n- Yellow accent (rating badge)\n- Hover: Scale up + glow effect\n\n### **2. Bench** ü™ë\n- Medium cards (90px wide)\n- 60x60px face images\n- Yellow theme\n- Compact layout\n\n### **3. Reserves** üì¶\n- Medium cards (90px wide)\n- 60x60px face images\n- Blue theme\n- Same as bench style\n\n### **4. Available Players** üéÆ\n- Standard player cards\n- Face images included\n- Grid layout\n\n---\n\n## üñºÔ∏è **Image Sources:**\n\n### **Default Image URL:**\n```javascript\nhttps://cdn.sofifa.net/players/${player.id}/25_60.png\n```\n\n### **Fallback:**\nIf image fails to load, shows:\n- Colored placeholder\n- Player's first initial\n- Team color background\n\n### **Custom Images:**\nYou can add custom images by setting:\n```javascript\nplayer.image = \"your-image-url.png\"\n```\n\n---\n\n## üéØ **Visual Hierarchy:**\n\n### **Squad Cards (Largest):**\n```css\nRating: 1.1em, Yellow badge\nImage: 80x80px, Yellow border\nName: 0.85em, White text\n```\n\n### **Bench/Reserve Cards (Medium):**\n```css\nRating: 0.9em, Yellow/Blue badge\nImage: 60x60px, Yellow/Blue border\nName: 0.75em, White text\n```\n\n---\n\n## üåà **Color Coding:**\n\n| Section | Rating Badge | Border | Theme |\n|---------|-------------|--------|-------|\n| **Squad** | Yellow (#FFED00) | Yellow | Primary |\n| **Bench** | Yellow (#FFED00) | Yellow | Warning |\n| **Reserves** | Blue (#4169E1) | Blue | Info |\n\n---\n\n## ‚ú® **Hover Effects:**\n\n### **Squad Cards:**\n```css\nTransform: translateY(-5px) scale(1.05)\nShadow: 0 10px 30px rgba(255, 237, 0, 0.6)\nBorder: Bright yellow (#FFF500)\n```\n\n### **Bench/Reserve Cards:**\n```css\nTransform: translateY(-3px) scale(1.05)\nShadow: 0 5px 20px (yellow/blue glow)\nBorder: Bright accent color\n```\n\n---\n\n## üì± **Responsive Design:**\n\n### **Card Sizes:**\n- **Squad:** 110px min-width\n- **Bench:** 90px min-width\n- **Reserves:** 90px min-width\n\n### **Image Sizes:**\n- **Squad:** 80x80px\n- **Bench:** 60x60px\n- **Reserves:** 60x60px\n\n---\n\n## üéÆ **Interactive Features:**\n\n### **Click:**\n- Opens player details modal\n- Shows full stats\n\n### **Drag:**\n- Grab cursor on hover\n- Smooth drag animation\n- Visual feedback\n\n### **Drop:**\n- Highlight on valid drop zones\n- Swap/move animations\n\n---\n\n## üîß **Technical Details:**\n\n### **HTML Structure:**\n```html\n<div class=\"pitch-card\">\n    <div class=\"pitch-card-rating\">92</div>\n    <div class=\"pitch-card-position\">CF</div>\n    <div class=\"pitch-card-image\">\n        <img src=\"player-face.png\" alt=\"Messi\">\n    </div>\n    <div class=\"pitch-card-name\">Messi</div>\n    <div class=\"pitch-card-stats\">\n        <span class=\"stat-badge\">‚≠ê</span>\n    </div>\n</div>\n```\n\n### **CSS Classes:**\n- `.pitch-card` - Main container\n- `.pitch-card-rating` - Rating badge\n- `.pitch-card-position` - Position badge\n- `.pitch-card-image` - Image container\n- `.pitch-card-name` - Player name\n- `.pitch-card-stats` - Stats/badges\n\n---\n\n## üé® **Styling Features:**\n\n### **Gradients:**\n```css\nSquad: linear-gradient(135deg, rgba(0, 20, 220, 0.95), rgba(0, 0, 80, 0.95))\nBench: linear-gradient(135deg, rgba(0, 20, 220, 0.8), rgba(0, 0, 51, 0.8))\nReserves: linear-gradient(135deg, rgba(65, 105, 225, 0.7), rgba(0, 0, 51, 0.7))\n```\n\n### **Shadows:**\n```css\nImage: 0 4px 10px rgba(255, 237, 0, 0.3)\nHover: 0 10px 30px rgba(255, 237, 0, 0.6)\nBadge: 0 2px 5px rgba(0, 0, 0, 0.3)\n```\n\n### **Borders:**\n```css\nCard: 3px solid (yellow/blue)\nImage: 3px solid (yellow/blue)\nRounded: 10px (card), 50% (image)\n```\n\n---\n\n## üí° **Empty Slots:**\n\n### **Visual:**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                 ‚îÇ\n‚îÇ      CMF        ‚îÇ‚Üê Position\n‚îÇ   Click to add  ‚îÇ‚Üê Instruction\n‚îÇ                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### **Style:**\n- Dashed border\n- Gray text\n- Clickable\n- No image\n\n---\n\n## üöÄ **Performance:**\n\n### **Image Loading:**\n- Lazy load on scroll\n- Fallback placeholder\n- Error handling\n- Cached images\n\n### **Optimization:**\n- CSS transforms (GPU accelerated)\n- Smooth transitions\n- Minimal repaints\n\n---\n\n## üéØ **Comparison:**\n\n### **Before:**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   CMF    ‚îÇ\n‚îÇ  Messi   ‚îÇ\n‚îÇ    92    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### **After (FIFA Style):**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ92      CMF‚îÇ\n‚îÇ  [FACE]  ‚îÇ\n‚îÇ  Messi‚≠ê ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## ‚úÖ **Benefits:**\n\n1. **Visual Appeal** - Modern FIFA/eFootball style\n2. **Easy Recognition** - See player faces instantly\n3. **Professional Look** - Polished UI\n4. **Better UX** - Clear visual hierarchy\n5. **Engaging** - More interactive and fun\n\n---\n\n## üéâ **Summary:**\n\n‚úÖ **Squad cards** - Large with player faces\n‚úÖ **Bench cards** - Medium with faces (yellow theme)\n‚úÖ **Reserve cards** - Medium with faces (blue theme)\n‚úÖ **Hover effects** - Scale + glow animations\n‚úÖ **Rating badges** - Top-left corner\n‚úÖ **Position badges** - Top-right corner\n‚úÖ **Fallback images** - Placeholder with initials\n\n**Refresh your browser to see the new FIFA-style player cards!** ‚öΩüéÆ\n","size_bytes":5865},"commands/contract.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\nconst players = require('../players.json');\nconst config = require('../config.json');\n\n// --- Contract Configuration ---\n\nconst PACKS = {\n    'iconic': {\n        name: 'Iconic Moment Pack',\n        cost: 500,\n        currency: 'eCoins',\n        description: 'A special pack containing players of all rarities, with a chance to get an Iconic Moment player!',\n        rarity_chances: {\n            'Iconic': 0.01,\n            'Legend': 0.03,\n            'Black': 0.10,\n            'Gold': 0.20,\n            'Silver': 0.30,\n            'Bronze': 0.26,\n            'White': 0.10,\n        }\n    },\n    'legend': {\n        name: 'Legend Box Draw',\n        cost: 25000,\n        currency: 'GP',\n        description: 'A box draw with a chance to get a Legend player!',\n        rarity_chances: {\n            'Legend': 0.05,\n            'Black': 0.15,\n            'Gold': 0.25,\n            'Silver': 0.35,\n            'Bronze': 0.20,\n            'White': 0.00, // No white balls in this pack\n        }\n    },\n    'standard': {\n        name: 'Standard Pack',\n        cost: 10000,\n        currency: 'GP',\n        description: 'A standard pack containing players from Black to White rarity.',\n        rarity_chances: {\n            'Black': 0.05,\n            'Gold': 0.20,\n            'Silver': 0.40,\n            'Bronze': 0.25,\n            'White': 0.10,\n        }\n    }\n};\n\nconst RARITY_SELL_VALUE = {\n    'Iconic': 50000,\n    'Legend': 25000,\n    'Black': 10000,\n    'Gold': 5000,\n    'Silver': 2500,\n    'Bronze': 1000,\n    'White': 500,\n};\n\nconst RARITY_COLORS = {\n    'Iconic': '#FF00FF', // Magenta\n    'Legend': '#FFD700', // Gold\n    'Black': '#000000',\n    'Gold': '#FFC300',\n    'Silver': '#C0C0C0',\n    'Bronze': '#CD7F32',\n    'White': '#FFFFFF',\n};\n\n// --- Emoji mappings (presentation only, logic unchanged) ---\nconst RARITY_EMOJIS = {\n    'Iconic': 'üíé',\n    'Legend': 'üåü',\n    'Black': '‚ö´',\n    'Gold': 'üü°',\n    'Silver': '‚ö™',\n    'Bronze': 'üü§',\n    'White': '‚¨ú',\n};\n\nconst PACK_EMOJIS = {\n    'iconic': 'üíé',\n    'legend': 'üèÜ',\n    'standard': 'üì¶',\n};\n\n// --- Helper Functions ---\n\nfunction selectRarity(chances) {\n    const rand = Math.random();\n    let cumulative = 0;\n    for (const rarity in chances) {\n        cumulative += chances[rarity];\n        if (rand < cumulative) {\n            return rarity;\n        }\n    }\n    return Object.keys(chances)[Object.keys(chances).length - 1]; // Fallback\n}\n\nfunction pullPlayer(rarity) {\n    const filteredPlayers = players.filter(p => p.rarity === rarity);\n    if (filteredPlayers.length === 0) return null;\n    return filteredPlayers[Math.floor(Math.random() * filteredPlayers.length)];\n}\n\nfunction getRarityGif(rarity) {\n    // Prefer local assets/gifs/<rarity>.gif (lowercased), fallback to config.contractGifs[rarity]\n    const lower = String(rarity || '').toLowerCase();\n    const filename = `${lower}.gif`;\n    const filePath = path.join(__dirname, '..', 'assets', 'gifs', filename);\n    if (fs.existsSync(filePath)) {\n        return { type: 'attachment', filename, filePath };\n    }\n    const url = config?.contractGifs?.[rarity] || config?.gachaGifs?.[rarity];\n    if (url) return { type: 'url', url };\n    return null;\n}\n\n// --- Command Definition ---\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('contract')\n        .setDescription('Use the contract system to pull new players')\n        .addStringOption(option =>\n            option.setName('pack')\n                .setDescription('Choose a contract pack')\n                .addChoices(\n                    { name: 'Iconic Moment Pack (500 eCoins)', value: 'iconic' },\n                    { name: 'Legend Box Draw (25,000 GP)', value: 'legend' },\n                    { name: 'Standard Pack (10,000 GP)', value: 'standard' }\n                )),\n    async execute(interaction) {\n        const { client } = interaction;\n        const userData = client.getUserData(interaction.user.id);\n\n        const packName = interaction.options.getString('pack');\n\n        if (!packName) {\n            const helpEmbed = new EmbedBuilder()\n                .setTitle('eFutbal Contract System')\n                .setDescription('Choose a pack to pull from using the pack option.')\n                .setColor('#0099ff');\n\n            for (const packKey in PACKS) {\n                const pack = PACKS[packKey];\n                const emoji = PACK_EMOJIS[packKey] || '';\n                helpEmbed.addFields({ name: `${emoji} ${pack.name}`, value: `${pack.description}\\nCost: **${pack.cost} ${pack.currency}**` });\n            }\n\n            return await interaction.reply({ embeds: [helpEmbed] });\n        }\n\n        const pack = PACKS[packName];\n\n        if (!pack) {\n            return await interaction.reply({ content: 'That pack does not exist.', ephemeral: true });\n        }\n\n        // Ensure userData.players exists (presentation-only safeguard)\n        if (!userData.players) userData.players = [];\n\n        // Check currency\n        if (pack.currency === 'GP' && userData.gp < pack.cost) {\n            return await interaction.reply({ content: `You don't have enough GP! You need ${pack.cost} GP.`, ephemeral: true });\n        } else if (pack.currency === 'eCoins' && userData.eCoins < pack.cost) {\n            return await interaction.reply({ content: `You don't have enough eCoins! You need ${pack.cost} eCoins.`, ephemeral: true });\n        }\n\n        // Defer reply to avoid interaction timeout while we process\n        await interaction.deferReply();\n\n        // Deduct currency\n        if (pack.currency === 'GP') {\n            userData.gp -= pack.cost;\n        } else {\n            userData.eCoins -= pack.cost;\n        }\n\n        // Pull the player\n        const targetRarity = selectRarity(pack.rarity_chances);\n        const newPlayer = pullPlayer(targetRarity);\n\n        if (!newPlayer) {\n            // This should ideally not happen if players.json is populated correctly\n            // NOTE: Keeping original behavior (don't change logic) ‚Äî use editReply because we already deferred\n            return await interaction.editReply({ content: 'Could not find a player for the determined rarity. Please contact an admin.' });\n        }\n\n        // Check for duplicates\n        const isDuplicate = userData.players.some(p => p.id === newPlayer.id);\n        let footerText = '';\n\n        if (isDuplicate) {\n            const sellValue = RARITY_SELL_VALUE[newPlayer.rarity] || 500;\n            userData.gp += sellValue;\n            footerText = `Duplicate! You received ${sellValue} GP for selling the extra copy.`;\n        } else {\n            userData.players.push(newPlayer);\n            footerText = 'New player added to your collection!';\n        }\n\n        client.setUserData(interaction.user.id, userData);\n\n        // Send result embed (beautified only)\n        const rarityEmoji = RARITY_EMOJIS[newPlayer.rarity] || '';\n        const resultEmbed = new EmbedBuilder()\n            .setTitle(`${rarityEmoji} Contract Pull! ${rarityEmoji}`)\n            .setDescription(`You pulled **${newPlayer.name}**!`)\n            .setColor(RARITY_COLORS[newPlayer.rarity] || '#0099ff')\n            .addFields(\n                { name: 'Rarity', value: `${rarityEmoji} ${newPlayer.rarity}`, inline: true },\n                { name: 'Overall', value: `üìä ${String(newPlayer.overall)}`, inline: true },\n                { name: 'Position', value: `üéØ ${newPlayer.position}`, inline: true }\n            )\n            .setFooter({ text: footerText });\n\n        // Attach rarity gif if available\n        const gif = getRarityGif(newPlayer.rarity);\n        if (gif) {\n            if (gif.type === 'attachment') {\n                resultEmbed.setImage(`attachment://${gif.filename}`);\n                return await interaction.editReply({ embeds: [resultEmbed], files: [gif.filePath] });\n            }\n            if (gif.type === 'url') {\n                resultEmbed.setImage(gif.url);\n            }\n        }\n\n        await interaction.editReply({ embeds: [resultEmbed] });\n    },\n};\n","size_bytes":8152},"commands/mail.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('mail')\n    .setDescription('View your free items and rewards'),\n\n  async execute(interaction) {\n    const { client } = interaction;\n    const userData = client.getUserData(interaction.user.id);\n\n    const packs = (userData.inventory && userData.inventory.freePacks) || { Iconic: 0, Legend: 0, Black: 0 };\n    const mail = Array.isArray(userData.mail) ? userData.mail : [];\n\n    const lines = [\n      `Iconic Packs: ${packs.Iconic || 0}`,\n      `Legend Packs: ${packs.Legend || 0}`,\n      `Black Packs: ${packs.Black || 0}`,\n    ];\n\n    const mailLines = mail.length ? mail.map(m => {\n        if (m.type === 'pack') {\n          return `‚Ä¢ [${m.date}] ${m.rarity} Pack x${m.qty || 1}`;\n        } else if (m.type === 'eCoins') {\n          return `‚Ä¢ [${m.date}] ${m.amount} eCoins`;\n        } else if (m.type === 'gp') {\n          return `‚Ä¢ [${m.date}] ${m.amount.toLocaleString()} GP`;\n        } else if (m.type === 'trainer') {\n          const label = m.trainerName || 'Trainer';\n          const exp = m.exp || 0;\n          return `‚Ä¢ [${m.date}] ${label} (+${exp.toLocaleString()} EXP)`;\n        } else {\n          return `‚Ä¢ [${m.date}] ${m.type}: ${m.amount || 'Unknown'}`;\n        }\n      }) : ['No mail items.'];\n\n    const embed = new EmbedBuilder()\n      .setTitle(`${interaction.user.username}'s Mail & Free Items`)\n      .setColor('#8e44ad')\n      .addFields(\n        { name: 'Free Packs', value: lines.join('\\n'), inline: true },\n        { name: 'Mail', value: mailLines.slice(0, 10).join('\\n'), inline: false }\n      )\n      .setFooter({ text: 'Use /use to open a free pack.' });\n\n    const components = [];\n    if (mail.length > 0) {\n      const row = new ActionRowBuilder().addComponents(\n        new ButtonBuilder().setCustomId('mail:claimall').setStyle(ButtonStyle.Primary).setLabel('Claim All')\n      );\n      components.push(row);\n    }\n\n    await interaction.reply({ embeds: [embed], components, ephemeral: true });\n  },\n\n  // Placeholder to allow future mail actions (claim buttons, etc.)\n  async handleButton(interaction) {\n    if (!interaction.customId.startsWith('mail:')) return;\n    const { client } = interaction;\n    const userData = client.getUserData(interaction.user.id);\n    const mail = Array.isArray(userData.mail) ? userData.mail : [];\n\n    if (interaction.customId === 'mail:claimall') {\n      if (mail.length === 0) {\n        return interaction.reply({ content: 'No mail to claim.', ephemeral: true });\n      }\n\n      // Ensure inventory exists\n      if (!userData.inventory) userData.inventory = { freePacks: { Iconic: 0, Legend: 0, Black: 0 } };\n      if (!userData.inventory.freePacks) userData.inventory.freePacks = { Iconic: 0, Legend: 0, Black: 0 };\n      if (!Array.isArray(userData.playerTrainers)) userData.playerTrainers = [];\n\n      let coinsAdded = 0;\n      let gpAdded = 0;\n      let packsAdded = { Iconic: 0, Legend: 0, Black: 0 };\n      let trainersAdded = 0;\n\n      for (const m of mail) {\n        if (m.type === 'pack' && m.rarity && ['Iconic','Legend','Black'].includes(m.rarity)) {\n          packsAdded[m.rarity] += m.qty || 1;\n        } else if (m.type === 'eCoins') {\n          coinsAdded += m.amount || 0;\n        } else if (m.type === 'gp') {\n          gpAdded += m.amount || 0;\n        } else if (m.type === 'trainer') {\n          // Convert mail trainer to playerTrainers inventory item\n          const token = Math.random().toString(36).slice(2, 10);\n          userData.playerTrainers.push({\n            token,\n            name: m.trainerName || 'Trainer',\n            rarity: 'S+',\n            exp: m.exp || 0,\n            createdAt: Date.now(),\n          });\n          trainersAdded += 1;\n        }\n      }\n\n      // Apply\n      userData.eCoins = (userData.eCoins || 0) + coinsAdded;\n      userData.gp = (userData.gp || 0) + gpAdded;\n      userData.inventory.freePacks.Iconic += packsAdded.Iconic;\n      userData.inventory.freePacks.Legend += packsAdded.Legend;\n      userData.inventory.freePacks.Black += packsAdded.Black;\n      userData.mail = []; // clear\n\n      client.setUserData(interaction.user.id, userData);\n\n      const summary = [\n        coinsAdded ? `+${coinsAdded} eCoins` : null,\n        gpAdded ? `+${gpAdded.toLocaleString()} GP` : null,\n        (packsAdded.Iconic || packsAdded.Legend || packsAdded.Black) ? `Packs ‚Äî Iconic:${packsAdded.Iconic} Legend:${packsAdded.Legend} Black:${packsAdded.Black}` : null,\n        trainersAdded ? `Trainers: S+ x${trainersAdded}` : null,\n      ].filter(Boolean).join(' | ');\n\n      return interaction.reply({ content: `Claimed: ${summary || 'Nothing'}`, ephemeral: true });\n    }\n\n    return interaction.reply({ content: 'Unknown mail action.', ephemeral: true });\n  }\n};\n","size_bytes":4878},"commands/formation.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\n// Enhanced formation definitions with tactical info\nconst FORMATIONS = {\n    '4-3-3': {\n        positions: ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', 'LWF', 'CF', 'RWF'],\n        name: 'Classic 4-3-3',\n        style: 'Balanced Attack',\n        description: 'Versatile formation with strong wing play and midfield control',\n        visual: [\n            '      ü•Ö     ',\n            '‚¨ÖÔ∏è  üõ°Ô∏è  üõ°Ô∏è  ‚û°Ô∏è',\n            '  ‚öΩ  ‚öΩ  ‚öΩ  ',\n            'üèÉ    ‚ö°    üèÉ'\n        ]\n    },\n    '4-4-2': {\n        positions: ['GK', 'LB', 'CB', 'CB', 'RB', 'LMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n        name: 'Traditional 4-4-2',\n        style: 'Solid & Direct',\n        description: 'Classic formation with two strikers and wide midfield support',\n        visual: [\n            '      ü•Ö     ',\n            '‚¨ÖÔ∏è  üõ°Ô∏è  üõ°Ô∏è  ‚û°Ô∏è',\n            '‚¨ÖÔ∏è  ‚öΩ  ‚öΩ  ‚û°Ô∏è',\n            '   ‚ö°    ‚ö°   '\n        ]\n    },\n    '3-5-2': {\n        positions: ['GK', 'CB', 'CB', 'CB', 'LMF', 'CMF', 'CMF', 'CMF', 'RMF', 'CF', 'CF'],\n        name: 'Dynamic 3-5-2',\n        style: 'Wing-Back Focus',\n        description: 'Attacking formation with overlapping wing-backs and strong midfield',\n        visual: [\n            '     ü•Ö      ',\n            '  üõ°Ô∏è üõ°Ô∏è üõ°Ô∏è  ',\n            '‚¨ÖÔ∏è ‚öΩ ‚öΩ ‚öΩ ‚û°Ô∏è',\n            '   ‚ö°   ‚ö°    '\n        ]\n    },\n    '4-2-3-1': {\n        positions: ['GK', 'LB', 'CB', 'CB', 'RB', 'DMF', 'DMF', 'AMF', 'AMF', 'AMF', 'CF'],\n        name: 'Modern 4-2-3-1',\n        style: 'Possession Game',\n        description: 'Contemporary formation with defensive midfield shield and attacking creativity',\n        visual: [\n            '      ü•Ö     ',\n            '‚¨ÖÔ∏è  üõ°Ô∏è  üõ°Ô∏è  ‚û°Ô∏è',\n            '   üîí  üîí   ',\n            'üéØ   üéØ   üéØ ',\n            '     ‚ö°      '\n        ]\n    },\n    '3-4-3': {\n        positions: ['GK', 'CB', 'CB', 'CB', 'LMF', 'CMF', 'CMF', 'RMF', 'LWF', 'CF', 'RWF'],\n        name: 'Attacking 3-4-3',\n        style: 'High Pressure',\n        description: 'Aggressive formation with three forwards and attacking midfield',\n        visual: [\n            '     ü•Ö      ',\n            '  üõ°Ô∏è üõ°Ô∏è üõ°Ô∏è  ',\n            '‚¨ÖÔ∏è  ‚öΩ  ‚öΩ  ‚û°Ô∏è',\n            'üèÉ    ‚ö°    üèÉ'\n        ]\n    },\n    '4-1-4-1': {\n        positions: ['GK', 'LB', 'CB', 'CB', 'RB', 'DMF', 'LMF', 'CMF', 'CMF', 'RMF', 'CF'],\n        name: 'Defensive 4-1-4-1',\n        style: 'Counter Attack',\n        description: 'Solid defensive setup with quick counter-attacking options',\n        visual: [\n            '      ü•Ö     ',\n            '‚¨ÖÔ∏è  üõ°Ô∏è  üõ°Ô∏è  ‚û°Ô∏è',\n            '     üîí     ',\n            '‚¨ÖÔ∏è ‚öΩ  ‚öΩ  ‚û°Ô∏è',\n            '     ‚ö°      '\n        ]\n    }\n};\n\nconst POSITION_EMOJIS = {\n    'GK': 'ü•Ö', 'CB': 'üõ°Ô∏è', 'LB': '‚¨ÖÔ∏è', 'RB': '‚û°Ô∏è', \n    'DMF': 'üîí', 'CMF': '‚öΩ', 'AMF': 'üéØ', 'LMF': '‚¨ÖÔ∏è', 'RMF': '‚û°Ô∏è',\n    'CF': '‚ö°', 'LWF': 'üèÉ', 'RWF': 'üèÉ'\n};\n\nconst POSITION_NAMES = {\n    'GK': 'Goalkeeper', 'CB': 'Centre Back', 'LB': 'Left Back', 'RB': 'Right Back',\n    'DMF': 'Defensive Mid', 'CMF': 'Central Mid', 'AMF': 'Attacking Mid',\n    'LMF': 'Left Mid', 'RMF': 'Right Mid', 'CF': 'Centre Forward',\n    'LWF': 'Left Wing', 'RWF': 'Right Wing'\n};\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('formation')\n        .setDescription('Advanced formation and tactical management')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('view')\n                .setDescription('View your current formation with visual display'))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('list')\n                .setDescription('Show all available formations with tactical info'))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('change')\n                .setDescription('Change your team formation')\n                .addStringOption(option =>\n                    option.setName('formation')\n                        .setDescription('Select new formation')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: '4-3-3 (Classic)', value: '4-3-3' },\n                            { name: '4-4-2 (Traditional)', value: '4-4-2' },\n                            { name: '3-5-2 (Dynamic)', value: '3-5-2' },\n                            { name: '4-2-3-1 (Modern)', value: '4-2-3-1' },\n                            { name: '3-4-3 (Attacking)', value: '3-4-3' },\n                            { name: '4-1-4-1 (Defensive)', value: '4-1-4-1' }\n                        )))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('analyze')\n                .setDescription('Get tactical analysis of your current setup'))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('optimize')\n                .setDescription('Get formation suggestions based on your players')),\n\n    async execute(interaction) {\n        const { client } = interaction;\n        const userData = client.getUserData(interaction.user.id);\n        const subcommand = interaction.options.getSubcommand();\n\n        // Initialize formation if not set\n        if (!userData.formation) {\n            userData.formation = '4-3-3';\n            client.setUserData(interaction.user.id, userData);\n        }\n\n        switch (subcommand) {\n            case 'view':\n                await viewFormation(interaction, userData);\n                break;\n            case 'list':\n                await listFormations(interaction);\n                break;\n            case 'change':\n                await changeFormation(interaction, userData, client);\n                break;\n            case 'analyze':\n                await analyzeFormation(interaction, userData);\n                break;\n            case 'optimize':\n                await optimizeFormation(interaction, userData);\n                break;\n        }\n    },\n};\n\nasync function viewFormation(interaction, userData) {\n    const formation = userData.formation || '4-3-3';\n    const formationData = FORMATIONS[formation];\n    \n    if (!userData.squad) {\n        userData.squad = { main: new Array(11).fill(null), bench: [] };\n    }\n\n    const embed = new EmbedBuilder()\n        .setTitle(`‚öΩ ${formationData.name}`)\n        .setColor('#1e90ff')\n        .setDescription(`**Style:** ${formationData.style}\\n*${formationData.description}*`)\n        .setThumbnail(interaction.user.displayAvatarURL());\n\n    // Visual formation display\n    const visualField = formationData.visual.join('\\n');\n    embed.addFields({ \n        name: 'üèüÔ∏è Formation Layout', \n        value: `\\`\\`\\`\\n${visualField}\\n\\`\\`\\``, \n        inline: false \n    });\n\n    // Show current players in formation\n    const squadDisplay = formationData.positions.map((pos, index) => {\n        const playerId = userData.squad.main[index];\n        const player = playerId ? userData.players?.find(p => p.id === playerId) : null;\n        const emoji = POSITION_EMOJIS[pos];\n        const posName = POSITION_NAMES[pos];\n        \n        if (player) {\n            return `${emoji} **${pos}** - ${player.name} (${player.overall})`;\n        } else {\n            return `${emoji} **${pos}** - *Empty Position*`;\n        }\n    }).join('\\n');\n\n    embed.addFields({ \n        name: 'üë• Current Lineup', \n        value: squadDisplay, \n        inline: false \n    });\n\n    // Team statistics\n    const filledPositions = userData.squad.main.filter(id => id !== null).length;\n    const mainPlayers = userData.squad.main\n        .map(id => userData.players?.find(p => p.id === id))\n        .filter(Boolean);\n    \n    const teamOverall = mainPlayers.length > 0 \n        ? Math.round(mainPlayers.reduce((sum, p) => sum + p.overall, 0) / mainPlayers.length)\n        : 0;\n\n    const chemistry = calculateChemistry(userData, formation);\n    \n    embed.addFields({ \n        name: 'üìä Team Stats', \n        value: `**Players:** ${filledPositions}/11\\n**Team Rating:** ${teamOverall}\\n**Chemistry:** ${chemistry}/100\\n**Formation:** ${formation}`, \n        inline: true \n    });\n\n    embed.setFooter({ text: 'Use /formation change to switch formations or /squad autoset to fill empty positions' });\n    \n    await interaction.reply({ embeds: [embed] });\n}\n\nasync function listFormations(interaction) {\n    const embed = new EmbedBuilder()\n        .setTitle('‚öΩ Available Formations')\n        .setColor('#ff6b35')\n        .setDescription('Choose the perfect tactical setup for your team');\n\n    Object.entries(FORMATIONS).forEach(([key, formation]) => {\n        const visualMini = formation.visual.slice(0, 2).join('\\n'); // Show first 2 lines only\n        embed.addFields({\n            name: `${formation.name} (${key})`,\n            value: `**Style:** ${formation.style}\\n*${formation.description}*\\n\\`\\`\\`\\n${visualMini}\\n\\`\\`\\``,\n            inline: true\n        });\n    });\n\n    embed.setFooter({ text: 'Use /formation change <formation> to switch formations' });\n    \n    await interaction.reply({ embeds: [embed] });\n}\n\nasync function changeFormation(interaction, userData, client) {\n    const newFormation = interaction.options.getString('formation');\n    const oldFormation = userData.formation || '4-3-3';\n    \n    if (newFormation === oldFormation) {\n        return await interaction.reply({ \n            content: `‚ùå You're already using the **${FORMATIONS[newFormation].name}** formation.`, \n            ephemeral: true \n        });\n    }\n\n    userData.formation = newFormation;\n    client.setUserData(interaction.user.id, userData);\n    \n    const formationData = FORMATIONS[newFormation];\n    const embed = new EmbedBuilder()\n        .setTitle('‚úÖ Formation Changed!')\n        .setColor('#00ff00')\n        .setDescription(`Switched from **${FORMATIONS[oldFormation].name}** to **${formationData.name}**`)\n        .addFields(\n            { \n                name: 'üéØ New Tactical Setup', \n                value: `**Style:** ${formationData.style}\\n*${formationData.description}*`, \n                inline: false \n            },\n            { \n                name: 'üèüÔ∏è Formation Layout', \n                value: `\\`\\`\\`\\n${formationData.visual.join('\\n')}\\n\\`\\`\\``, \n                inline: false \n            }\n        );\n\n    // Warn about potential player repositioning\n    if (userData.squad && userData.squad.main.some(id => id !== null)) {\n        embed.addFields({\n            name: '‚ö†Ô∏è Important Note',\n            value: 'Your current players will remain in their numbered positions, but may need repositioning for optimal chemistry. Use `/squad view` to check your lineup.',\n            inline: false\n        });\n    }\n\n    embed.setFooter({ text: 'Use /formation view to see your current lineup in the new formation' });\n    \n    await interaction.reply({ embeds: [embed] });\n}\n\nasync function analyzeFormation(interaction, userData) {\n    const formation = userData.formation || '4-3-3';\n    const formationData = FORMATIONS[formation];\n    \n    if (!userData.squad || !userData.players) {\n        return await interaction.reply({ \n            content: '‚ùå You need players and a squad to analyze. Use `/contract` to get players first.', \n            ephemeral: true \n        });\n    }\n\n    const mainPlayers = userData.squad.main\n        .map(id => userData.players?.find(p => p.id === id))\n        .filter(Boolean);\n\n    if (mainPlayers.length === 0) {\n        return await interaction.reply({ \n            content: '‚ùå No players in your starting XI. Use `/squad autoset` to fill your team first.', \n            ephemeral: true \n        });\n    }\n\n    // Analyze team composition\n    const positionCounts = {};\n    const overallsByPosition = {};\n    \n    formationData.positions.forEach((pos, index) => {\n        const player = mainPlayers.find((_, i) => userData.squad.main[i] === mainPlayers[i]?.id);\n        if (player) {\n            positionCounts[pos] = (positionCounts[pos] || 0) + 1;\n            if (!overallsByPosition[pos]) overallsByPosition[pos] = [];\n            overallsByPosition[pos].push(player.overall);\n        }\n    });\n\n    const teamOverall = Math.round(mainPlayers.reduce((sum, p) => sum + p.overall, 0) / mainPlayers.length);\n    const chemistry = calculateChemistry(userData, formation);\n    \n    // Determine strengths and weaknesses\n    const strengths = [];\n    const weaknesses = [];\n    \n    // Analyze by formation type\n    switch (formation) {\n        case '4-3-3':\n            if (getPositionAverage(overallsByPosition, 'LWF') > 85 && getPositionAverage(overallsByPosition, 'RWF') > 85) {\n                strengths.push('Strong wing attack');\n            }\n            if (getPositionAverage(overallsByPosition, 'CMF') < 75) {\n                weaknesses.push('Weak midfield control');\n            }\n            break;\n        case '4-4-2':\n            if (getPositionAverage(overallsByPosition, 'CF') > 85) {\n                strengths.push('Powerful strike partnership');\n            }\n            if (!overallsByPosition['DMF'] || getPositionAverage(overallsByPosition, 'CMF') < 80) {\n                weaknesses.push('Lacks midfield depth');\n            }\n            break;\n        case '4-2-3-1':\n            if (getPositionAverage(overallsByPosition, 'DMF') > 80) {\n                strengths.push('Solid defensive midfield');\n            }\n            if (getPositionAverage(overallsByPosition, 'AMF') > 85) {\n                strengths.push('Creative attacking midfield');\n            }\n            break;\n    }\n\n    // General analysis\n    if (teamOverall > 85) strengths.push('High overall team quality');\n    if (chemistry > 80) strengths.push('Good team chemistry');\n    if (chemistry < 60) weaknesses.push('Poor team chemistry');\n    \n    const embed = new EmbedBuilder()\n        .setTitle(`üìä Tactical Analysis - ${formationData.name}`)\n        .setColor('#9966cc')\n        .setDescription(`Detailed breakdown of your **${formation}** setup`)\n        .addFields(\n            {\n                name: 'üìà Team Statistics',\n                value: `**Overall Rating:** ${teamOverall}/100\\n**Chemistry:** ${chemistry}/100\\n**Players:** ${mainPlayers.length}/11\\n**Formation Style:** ${formationData.style}`,\n                inline: true\n            },\n            {\n                name: 'üí™ Strengths',\n                value: strengths.length > 0 ? strengths.map(s => `‚Ä¢ ${s}`).join('\\n') : '‚Ä¢ No major strengths identified',\n                inline: true\n            },\n            {\n                name: '‚ö†Ô∏è Areas to Improve',\n                value: weaknesses.length > 0 ? weaknesses.map(w => `‚Ä¢ ${w}`).join('\\n') : '‚Ä¢ Well-balanced setup',\n                inline: true\n            }\n        );\n\n    // Position-by-position breakdown\n    const positionAnalysis = Object.entries(overallsByPosition)\n        .map(([pos, ratings]) => {\n            const avg = Math.round(ratings.reduce((a, b) => a + b, 0) / ratings.length);\n            const grade = avg >= 90 ? 'A+' : avg >= 85 ? 'A' : avg >= 80 ? 'B+' : avg >= 75 ? 'B' : avg >= 70 ? 'C+' : avg >= 65 ? 'C' : 'D';\n            return `**${pos}**: ${avg} (${grade})`;\n        })\n        .join('\\n');\n\n    embed.addFields({\n        name: 'üéØ Position Breakdown',\n        value: positionAnalysis || 'No players to analyze',\n        inline: false\n    });\n\n    embed.setFooter({ text: 'Use /formation optimize for improvement suggestions' });\n    \n    await interaction.reply({ embeds: [embed] });\n}\n\nasync function optimizeFormation(interaction, userData) {\n    if (!userData.players || userData.players.length < 11) {\n        return await interaction.reply({ \n            content: '‚ùå You need at least 11 players to get formation optimization. Use `/contract` to get more players.', \n            ephemeral: true \n        });\n    }\n\n    // Analyze player positions and overall ratings\n    const playersByPosition = {};\n    userData.players.forEach(player => {\n        if (!playersByPosition[player.position]) {\n            playersByPosition[player.position] = [];\n        }\n        playersByPosition[player.position].push(player);\n    });\n\n    // Sort players by overall in each position\n    Object.keys(playersByPosition).forEach(pos => {\n        playersByPosition[pos].sort((a, b) => b.overall - a.overall);\n    });\n\n    // Suggest best formations based on player strength\n    const suggestions = [];\n    \n    Object.entries(FORMATIONS).forEach(([formationKey, formationData]) => {\n        let score = 0;\n        let filledPositions = 0;\n        \n        formationData.positions.forEach(requiredPos => {\n            if (playersByPosition[requiredPos] && playersByPosition[requiredPos].length > 0) {\n                score += playersByPosition[requiredPos][0].overall;\n                filledPositions++;\n            }\n        });\n        \n        // Average score for this formation\n        const avgScore = filledPositions > 0 ? score / formationData.positions.length : 0;\n        const completeness = (filledPositions / 11) * 100;\n        \n        suggestions.push({\n            formation: formationKey,\n            data: formationData,\n            score: avgScore,\n            completeness,\n            totalScore: avgScore * (completeness / 100) // Weight by completeness\n        });\n    });\n\n    // Sort by total score\n    suggestions.sort((a, b) => b.totalScore - a.totalScore);\n    const currentFormation = userData.formation || '4-3-3';\n    \n    const embed = new EmbedBuilder()\n        .setTitle('üéØ Formation Optimization')\n        .setColor('#ff9500')\n        .setDescription(`Based on your ${userData.players.length} players, here are the best tactical setups:`);\n\n    // Show top 3 recommendations\n    suggestions.slice(0, 3).forEach((suggestion, index) => {\n        const emoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';\n        const isCurrent = suggestion.formation === currentFormation;\n        \n        embed.addFields({\n            name: `${emoji} ${suggestion.data.name}${isCurrent ? ' (Current)' : ''}`,\n            value: `**Projected Rating:** ${Math.round(suggestion.score)}/100\\n` +\n                   `**Squad Completeness:** ${Math.round(suggestion.completeness)}%\\n` +\n                   `**Style:** ${suggestion.data.style}\\n` +\n                   `*${suggestion.data.description}*`,\n            inline: true\n        });\n    });\n\n    // Show specific recommendations\n    const bestFormation = suggestions[0];\n    if (bestFormation.formation !== currentFormation) {\n        embed.addFields({\n            name: 'üí° Recommendation',\n            value: `Consider switching to **${bestFormation.data.name}** for a **${Math.round(bestFormation.score - calculateCurrentTeamRating(userData))}** point improvement in team rating!`,\n            inline: false\n        });\n    } else {\n        embed.addFields({\n            name: '‚úÖ Current Setup',\n            value: `Your **${FORMATIONS[currentFormation].name}** is already optimal for your current squad!`,\n            inline: false\n        });\n    }\n\n    embed.setFooter({ text: 'Use /formation change <formation> to switch tactical setups' });\n    \n    await interaction.reply({ embeds: [embed] });\n}\n\n// Helper functions\nfunction getPositionAverage(overallsByPosition, position) {\n    if (!overallsByPosition[position]) return 0;\n    return overallsByPosition[position].reduce((a, b) => a + b, 0) / overallsByPosition[position].length;\n}\n\nfunction calculateChemistry(userData, formation) {\n    if (!userData.squad || !userData.players) return 0;\n    \n    const formationData = FORMATIONS[formation];\n    let chemistryScore = 0;\n    let playerCount = 0;\n    \n    userData.squad.main.forEach((playerId, index) => {\n        if (playerId) {\n            const player = userData.players.find(p => p.id === playerId);\n            const requiredPosition = formationData.positions[index];\n            \n            if (player) {\n                playerCount++;\n                // Perfect match: 100 points\n                if (player.position === requiredPosition) {\n                    chemistryScore += 100;\n                } else {\n                    // Partial match based on compatibility\n                    const compatibility = getPositionCompatibility(player.position, requiredPosition);\n                    chemistryScore += compatibility;\n                }\n            }\n        }\n    });\n    \n    return playerCount > 0 ? Math.round(chemistryScore / playerCount) : 0;\n}\n\nfunction getPositionCompatibility(playerPos, requiredPos) {\n    // Compatibility matrix - how well each position fits in another\n    const compatibility = {\n        'GK': { 'GK': 100 }, // GK only fits GK\n        'CB': { 'CB': 100, 'LB': 70, 'RB': 70, 'DMF': 60 },\n        'LB': { 'LB': 100, 'CB': 70, 'LMF': 80, 'LWF': 60 },\n        'RB': { 'RB': 100, 'CB': 70, 'RMF': 80, 'RWF': 60 },\n        'DMF': { 'DMF': 100, 'CMF': 85, 'CB': 60 },\n        'CMF': { 'CMF': 100, 'DMF': 85, 'AMF': 80 },\n        'AMF': { 'AMF': 100, 'CMF': 80, 'CF': 70 },\n        'LMF': { 'LMF': 100, 'LB': 80, 'LWF': 85, 'CMF': 70 },\n        'RMF': { 'RMF': 100, 'RB': 80, 'RWF': 85, 'CMF': 70 },\n        'CF': { 'CF': 100, 'AMF': 70, 'LWF': 60, 'RWF': 60 },\n        'LWF': { 'LWF': 100, 'CF': 60, 'LMF': 85 },\n        'RWF': { 'RWF': 100, 'CF': 60, 'RMF': 85 }\n    };\n    \n    return compatibility[playerPos]?.[requiredPos] || 30; // Default low compatibility\n}\n\nfunction calculateCurrentTeamRating(userData) {\n    if (!userData.squad || !userData.players) return 0;\n    \n    const mainPlayers = userData.squad.main\n        .map(id => userData.players?.find(p => p.id === id))\n        .filter(Boolean);\n    \n    return mainPlayers.length > 0 \n        ? Math.round(mainPlayers.reduce((sum, p) => sum + p.overall, 0) / mainPlayers.length)\n        : 0;\n}","size_bytes":22016},"commands/training.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Helper function to get player face image\nfunction getPlayerFace(playerName) {\n    // Sanitize player name for filename\n    const baseSanitized = playerName.replace(/[^a-zA-Z0-9\\-_]/g, '_').toLowerCase();\n    // Additional normalizations: collapse multiple underscores and trim trailing underscores\n    const collapsed = baseSanitized.replace(/_+/g, '_');\n    const trimmed = collapsed.replace(/_+$/g, '');\n\n    const candidates = Array.from(new Set([\n        baseSanitized,\n        collapsed,\n        trimmed,\n    ])).filter(Boolean);\n\n    for (const name of candidates) {\n        const jpg = path.join(__dirname, '..', 'assets', 'faces', `${name}.jpg`);\n        if (fs.existsSync(jpg)) {\n            return { type: 'attachment', filename: `${name}.jpg`, filePath: jpg };\n        }\n        const png = path.join(__dirname, '..', 'assets', 'faces', `${name}.png`);\n        if (fs.existsSync(png)) {\n            return { type: 'attachment', filename: `${name}.png`, filePath: png };\n        }\n    }\n    \n    // Default placeholder if no face found\n    const defaultPath = path.join(__dirname, '..', 'assets', 'faces', 'default_player.png');\n    if (fs.existsSync(defaultPath)) {\n        return { type: 'attachment', filename: 'default_player.png', filePath: defaultPath };\n    }\n    \n    return null;\n}\n\n// Updated Training Configuration\nconst TRAINER_TYPES = {\n    'normal': {\n        name: 'Normal Trainer',\n        cost: 1500,\n        currency: 'GP',\n        expGain: 500,\n        description: 'Gives 500 EXP to a player'\n    },\n    'basic': {\n        name: 'Basic Trainer',\n        cost: 3000,\n        currency: 'GP',\n        expGain: 1000,\n        description: 'Gives 1,000 EXP to a player'\n    },\n    'special': {\n        name: 'Special Trainer',\n        cost: 28000,\n        currency: 'GP',\n        expGain: 10000,\n        description: 'Gives 10,000 EXP to a player'\n    },\n    'special_coin': {\n        name: 'Special Trainer (eCoin)',\n        cost: 50,\n        currency: 'eCoins',\n        expGain: 10000,\n        description: 'Gives 10,000 EXP to a player'\n    }\n};\n// Player conversion EXP based on rarity\nconst CONVERSION_EXP = {\n    'Iconic': { min: 7500, max: 9000 },\n    'Legend': { min: 6000, max: 7500 },\n    'Black': { min: 4500, max: 6000 },\n    'Gold': { min: 3000, max: 4500 },\n    'Silver': { min: 2000, max: 3000 },\n    'Bronze': { min: 1200, max: 2000 },\n    'White': { min: 800, max: 1200 }\n};\n\n// Level and EXP system\nconst LEVEL_CONFIG = {\n    maxLevel: 50,\n    expPerLevel: 1000, // Base EXP needed per level\n    expMultiplier: 1.1 // Each level requires 10% more EXP\n};\n\n// Rarity-based max level and stat multipliers\nconst RARITY_CONFIG = {\n    'Iconic': { maxLevel: 50, statMultiplier: 1.0, overallBonus: 0 },\n    'Legend': { maxLevel: 45, statMultiplier: 0.95, overallBonus: -2 },\n    'Black': { maxLevel: 40, statMultiplier: 0.90, overallBonus: -5 },\n    'Gold': { maxLevel: 35, statMultiplier: 0.85, overallBonus: -8 },\n    'Silver': { maxLevel: 30, statMultiplier: 0.80, overallBonus: -12 },\n    'Bronze': { maxLevel: 25, statMultiplier: 0.75, overallBonus: -16 },\n    'White': { maxLevel: 20, statMultiplier: 0.70, overallBonus: -20 }\n};\n\n// Position-based stat growth priorities\nconst POSITION_STAT_PRIORITY = {\n    'GK': { goalkeeping: 2.0, defending: 1.2, physicality: 1.1, passing: 0.8, attacking: 0.3, dribbling: 0.4 },\n    'CB': { defending: 1.8, physicality: 1.5, passing: 1.0, goalkeeping: 0.1, attacking: 0.4, dribbling: 0.5 },\n    'LB': { defending: 1.4, passing: 1.3, physicality: 1.1, dribbling: 1.0, attacking: 0.8, goalkeeping: 0.1 },\n    'RB': { defending: 1.4, passing: 1.3, physicality: 1.1, dribbling: 1.0, attacking: 0.8, goalkeeping: 0.1 },\n    'DMF': { defending: 1.5, passing: 1.4, physicality: 1.2, dribbling: 0.9, attacking: 0.7, goalkeeping: 0.1 },\n    'CMF': { passing: 1.6, dribbling: 1.3, defending: 1.0, physicality: 1.0, attacking: 1.1, goalkeeping: 0.1 },\n    'AMF': { passing: 1.5, dribbling: 1.4, attacking: 1.3, physicality: 0.8, defending: 0.6, goalkeeping: 0.1 },\n    'LMF': { dribbling: 1.4, passing: 1.3, attacking: 1.1, physicality: 1.0, defending: 0.8, goalkeeping: 0.1 },\n    'RMF': { dribbling: 1.4, passing: 1.3, attacking: 1.1, physicality: 1.0, defending: 0.8, goalkeeping: 0.1 },\n    'LWF': { dribbling: 1.5, attacking: 1.4, passing: 1.0, physicality: 0.9, defending: 0.5, goalkeeping: 0.1 },\n    'RWF': { dribbling: 1.5, attacking: 1.4, passing: 1.0, physicality: 0.9, defending: 0.5, goalkeeping: 0.1 },\n    'SS': { attacking: 1.6, dribbling: 1.4, passing: 1.2, physicality: 1.0, defending: 0.4, goalkeeping: 0.1 },\n    'CF': { attacking: 1.8, physicality: 1.3, dribbling: 1.1, passing: 1.0, defending: 0.3, goalkeeping: 0.1 }\n};\n\n// Playing style bonuses\nconst PLAYSTYLE_BONUSES = {\n    'Offensive Wingback': { attacking: 1.2, dribbling: 1.1 },\n    'Classic No. 10': { passing: 1.3, dribbling: 1.2 },\n    'Box-to-Box': { physicality: 1.2, passing: 1.1 },\n    'Destroyer': { defending: 1.3, physicality: 1.2 },\n    'Orchestrator': { passing: 1.4, dribbling: 1.1 },\n    'Hole Player': { attacking: 1.2, dribbling: 1.2 },\n    'Roaming Flank': { dribbling: 1.3, attacking: 1.1 },\n    'Cross Specialist': { passing: 1.2, attacking: 1.1 },\n    'Prolific Winger': { dribbling: 1.4, attacking: 1.2 },\n    'Goal Poacher': { attacking: 1.5 },\n    'Target Man': { physicality: 1.4, attacking: 1.2 },\n    'Deep-lying Forward': { passing: 1.3, attacking: 1.1 }\n};\n\nfunction calculateExpNeeded(level) {\n    if (level >= LEVEL_CONFIG.maxLevel) return 0;\n    return Math.floor(LEVEL_CONFIG.expPerLevel * Math.pow(LEVEL_CONFIG.expMultiplier, level - 1));\n}\n\nfunction calculateOverall(stats, position, playingStyle) {\n    // Weight stats based on position importance\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    \n    let weightedSum = 0;\n    let totalWeight = 0;\n    \n    for (const [statName, statValue] of Object.entries(stats)) {\n        if (statName === 'goalkeeping' && position !== 'GK') {\n            continue; // Skip GK stat for outfield players\n        }\n        const weight = positionPriority[statName] || 1.0;\n        weightedSum += statValue * weight;\n        totalWeight += weight;\n    }\n    \n    const weightedAvg = totalWeight > 0 ? weightedSum / totalWeight : 50;\n    return Math.max(30, Math.min(99, Math.round(weightedAvg)));\n}\n\nfunction calculateStatsForLevel(baseStats, position, playingStyle, level, maxLevel, rarity) {\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    const styleBonuses = PLAYSTYLE_BONUSES[playingStyle] || {};\n    \n    const levelProgress = (level - 1) / (maxLevel - 1);\n    const newStats = {};\n    \n    for (const [statName, baseStat] of Object.entries(baseStats)) {\n        const positionMultiplier = positionPriority[statName] || 1.0;\n        const styleMultiplier = styleBonuses[statName] || 1.0;\n        \n        const maxGrowth = 15;\n        const growth = levelProgress * maxGrowth * positionMultiplier * styleMultiplier;\n        newStats[statName] = Math.max(10, Math.min(99, Math.floor(baseStat + growth)));\n    }\n    \n    return newStats;\n}\n\nfunction initializePlayerLevel(player) {\n    const rarityConfig = RARITY_CONFIG[player.rarity] || RARITY_CONFIG['White'];\n    \n    if (!player.level) {\n        player.level = 1;\n        player.exp = 0;\n        player.maxLevel = rarityConfig.maxLevel;\n        player.baseStats = { ...player.stats };\n        // Recalculate overall to match current stats\n        player.overall = calculateOverall(player.stats, player.position, player.playingStyle);\n    }\n    \n    return player;\n}\n\nfunction getConversionExp(rarity) {\n    const expRange = CONVERSION_EXP[rarity] || CONVERSION_EXP['White'];\n    return Math.floor(Math.random() * (expRange.max - expRange.min + 1)) + expRange.min;\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('training')\n        .setDescription('Train your players to increase their level and stats')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('player')\n                .setDescription('Train a specific player')\n                .addStringOption(option =>\n                    option.setName('player')\n                        .setDescription('Player name to train')\n                        .setRequired(true)\n                        .setAutocomplete(true))\n                .addStringOption(option =>\n                    option.setName('trainer')\n                        .setDescription('Trainer to use (standard or your player trainers)')\n                        .setRequired(true)\n                        .setAutocomplete(true))\n                .addIntegerOption(option =>\n                    option.setName('amount')\n                        .setDescription('Number of trainers to use')\n                        .setMinValue(1)\n                        .setMaxValue(10)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('convert')\n                .setDescription('Convert a player to training EXP')\n                .addStringOption(option =>\n                    option.setName('player')\n                        .setDescription('Player name to convert')\n                        .setRequired(true)\n                        .setAutocomplete(true)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('info')\n                .setDescription('View training information and player levels')\n                .addStringOption(option =>\n                    option.setName('player')\n                        .setDescription('Player name to view info')\n                        .setAutocomplete(true)))\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('shop')\n                .setDescription('Buy training items')),\n\n    async execute(interaction) {\n        try {\n            const { client } = interaction;\n            const userData = client.getUserData(interaction.user.id);\n            const subcommand = interaction.options.getSubcommand();\n\n            // Ensure user has players array and training inventory\n            if (!userData.players) userData.players = [];\n            if (!Array.isArray(userData.playerTrainers)) userData.playerTrainers = [];\n            if (!userData.trainingExp) userData.trainingExp = 0;\n\n            if (subcommand === 'player') {\n                await this.handleTrainPlayer(interaction, userData, client);\n            } else if (subcommand === 'convert') {\n                await this.handleConvertPlayer(interaction, userData, client);\n            } else if (subcommand === 'info') {\n                await this.handleTrainingInfo(interaction, userData);\n            } else if (subcommand === 'shop') {\n                await this.handleTrainingShop(interaction, userData, client);\n            }\n        } catch (error) {\n            console.error('Training command error:', error);\n            try { \n                await interaction.reply({ content: '‚ùå Error executing training command. Please try again!', ephemeral: true }); \n            } catch {}\n        }\n    },\n\n    async handleTrainPlayer(interaction, userData, client) {\n        const playerName = interaction.options.getString('player');\n        const trainerInput = interaction.options.getString('trainer');\n        const amount = interaction.options.getInteger('amount') || 1;\n\n        // Find player\n        const player = userData.players.find(p => \n            p.name.toLowerCase().includes(playerName.toLowerCase())\n        );\n\n        if (!player) {\n            return await interaction.reply({ \n                content: `‚ùå Player \"${playerName}\" not found in your collection!`, \n                ephemeral: true \n            });\n        }\n\n        // Initialize player level if needed\n        initializePlayerLevel(player);\n\n        // Check if player is max level\n        if (player.level >= player.maxLevel) {\n            return await interaction.reply({ \n                content: `‚ùå ${player.name} is already at max level (${player.maxLevel})!`, \n                ephemeral: true \n            });\n        }\n\n        let totalCost = 0;\n        let totalExp = 0;\n        let currency = 'GP';\n        let trainersUsedDescription = '';\n\n        // Case 1: player trainer selected (value format: player:<token>)\n        if (trainerInput && trainerInput.startsWith('player:')) {\n            const token = trainerInput.split(':')[1];\n            const idx = Array.isArray(userData.playerTrainers) ? userData.playerTrainers.findIndex(t => t.token === token) : -1;\n            if (idx === -1) {\n                return await interaction.reply({ content: '‚ùå That player trainer is no longer available.', ephemeral: true });\n            }\n            const trainerItem = userData.playerTrainers[idx];\n            // Player trainers are single-use; ignore amount and apply exactly once\n            totalExp = Number(trainerItem.exp || 0);\n            totalCost = 0; // already paid at conversion time\n            currency = 'GP';\n            trainersUsedDescription = `Player Trainer: ${trainerItem.name} (+${totalExp.toLocaleString()} EXP)`;\n            // consume it\n            userData.playerTrainers.splice(idx, 1);\n        } else {\n            // Case 2: standard trainer type\n            const trainer = TRAINER_TYPES[trainerInput];\n            if (!trainer) {\n                return await interaction.reply({ content: '‚ùå Invalid trainer selected.', ephemeral: true });\n            }\n            totalCost = trainer.cost * amount;\n            totalExp = trainer.expGain * amount;\n            currency = trainer.currency;\n            trainersUsedDescription = `${trainer.name} √ó${amount} (+${totalExp.toLocaleString()} EXP)`;\n            // Check currency\n            if (currency === 'GP' && userData.gp < totalCost) {\n                return await interaction.reply({ \n                    content: `‚ùå You need ${totalCost.toLocaleString()} GP but only have ${userData.gp.toLocaleString()} GP!`, \n                    ephemeral: true \n                });\n            } else if (currency === 'eCoins' && userData.eCoins < totalCost) {\n                return await interaction.reply({ \n                    content: `‚ùå You need ${totalCost} eCoins but only have ${userData.eCoins} eCoins!`, \n                    ephemeral: true \n                });\n            }\n        }\n\n        await interaction.deferReply();\n\n        // Deduct currency\n        if (totalCost > 0) {\n            if (currency === 'GP') userData.gp -= totalCost; else userData.eCoins -= totalCost;\n        }\n\n        // Apply EXP and level up\n        const oldLevel = player.level;\n        const oldOverall = player.overall;\n        const statsBefore = { ...(player.stats || {}) };\n        player.exp += totalExp;\n\n        let levelsGained = 0;\n        while (player.level < player.maxLevel) {\n            const expNeeded = calculateExpNeeded(player.level);\n            if (player.exp >= expNeeded) {\n                player.exp -= expNeeded;\n                player.level++;\n                levelsGained++;\n                \n                // Update stats and overall for new level\n                const baseStats = player.baseStats || player.stats;\n                player.stats = calculateStatsForLevel(\n                    baseStats, \n                    player.position, \n                    player.playingStyle, \n                    player.level, \n                    player.maxLevel, \n                    player.rarity\n                );\n                // Clamp to maxStats if available to avoid current > max\n                if (player.maxStats) {\n                    for (const key of Object.keys(player.stats)) {\n                        const maxVal = typeof player.maxStats[key] === 'number' ? player.maxStats[key] : 99;\n                        if (player.stats[key] > maxVal) player.stats[key] = maxVal;\n                    }\n                }\n                const baseOverall = calculateOverall(player.stats, player.position, player.playingStyle);\n                // Blend toward maxOverall based on level progress so overall can exceed 99 safely\n                let blendedOverall = baseOverall;\n                if (typeof player.maxOverall === 'number') {\n                    const progress = player.maxLevel > 1 ? (player.level - 1) / (player.maxLevel - 1) : 1;\n                    blendedOverall = Math.round(baseOverall + (player.maxOverall - baseOverall) * progress);\n                    // Do not exceed declared cap\n                    blendedOverall = Math.min(blendedOverall, player.maxOverall);\n                }\n                // Ensure overall never decreases\n                player.overall = Math.max(oldOverall, blendedOverall);\n            } else {\n                break;\n            }\n        }\n\n        client.setUserData(interaction.user.id, userData);\n\n        // Create result embed\n        const embed = new EmbedBuilder()\n            .setTitle('üèãÔ∏è Training Complete!')\n            .setColor('#27ae60')\n            .setDescription(`**${player.name}** has been trained!`)\n            .addFields(\n                { name: 'üìä EXP Gained', value: `+${totalExp.toLocaleString()}` , inline: true },\n                { name: '‚≠ê Level', value: `${oldLevel} ‚Üí ${player.level}`, inline: true },\n                { name: 'üéØ Overall', value: `${oldOverall} ‚Üí ${player.overall}${player.maxOverall ? `/${player.maxOverall}` : ''}` , inline: true }\n            );\n        // Show stat upgrades\n        const labelMap = {\n            attacking: 'Att',\n            dribbling: 'Drib',\n            defending: 'Def',\n            passing: 'Pass',\n            physicality: 'Phys',\n            goalkeeping: 'GK',\n        };\n        const statLines = [];\n        for (const [k, vAfter] of Object.entries(player.stats || {})) {\n            const before = typeof statsBefore[k] === 'number' ? statsBefore[k] : vAfter;\n            if (typeof vAfter === 'number' && vAfter > before) {\n                const label = labelMap[k] || k;\n                statLines.push(`${label}: ${before} ‚Üí ${vAfter}`);\n            }\n        }\n        if (statLines.length > 0) {\n            embed.addFields({ name: 'üìà Stat Upgrades', value: statLines.join('\\n') });\n        }\n        if (trainersUsedDescription) {\n            embed.addFields({ name: 'üßë‚Äçüè´ Trainer Used', value: trainersUsedDescription });\n        }\n\n        if (levelsGained > 0) {\n            embed.addFields({ \n                name: 'üéâ Level Up!', \n                value: `${player.name} gained ${levelsGained} level${levelsGained > 1 ? 's' : ''}!` \n            });\n        }\n\n        const expNeeded = player.level >= player.maxLevel ? 0 : calculateExpNeeded(player.level);\n        embed.setFooter({ \n            text: `EXP: ${player.exp}/${expNeeded} | Max Level: ${player.maxLevel}` \n        });\n\n        await interaction.editReply({ embeds: [embed] });\n    },\n\n    async handleConvertPlayer(interaction, userData, client) {\n        const playerName = interaction.options.getString('player');\n\n        // Find player\n        const playerIndex = userData.players.findIndex(p => \n            p.name.toLowerCase().includes(playerName.toLowerCase())\n        );\n\n        if (playerIndex === -1) {\n            return await interaction.reply({ \n                content: `‚ùå Player \"${playerName}\" not found in your collection!`, \n                ephemeral: true \n            });\n        }\n\n        const player = userData.players[playerIndex];\n        const conversionExp = getConversionExp(player.rarity);\n\n        // Create confirmation embed\n        const embed = new EmbedBuilder()\n            .setTitle('‚ö†Ô∏è Convert Player to Training EXP')\n            .setColor('#e67e22')\n            .setDescription(`Are you sure you want to convert **${player.name}** to training EXP?`)\n            .addFields(\n                { name: 'üèÜ Player Rarity', value: player.rarity, inline: true },\n                { name: 'üéØ Player Overall', value: player.overall.toString(), inline: true },\n                { name: 'üìä EXP Gained', value: `${conversionExp.toLocaleString()}`, inline: true },\n                { name: '‚ö†Ô∏è Warning', value: '**This action cannot be undone!** The player will be permanently removed from your collection.', inline: false }\n            );\n\n        const row = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId('confirm_convert')\n                    .setLabel('Confirm Convert')\n                    .setStyle(ButtonStyle.Danger),\n                new ButtonBuilder()\n                    .setCustomId('cancel_convert')\n                    .setLabel('Cancel')\n                    .setStyle(ButtonStyle.Secondary)\n            );\n\n        const response = await interaction.reply({ \n            embeds: [embed], \n            components: [row], \n            ephemeral: true \n        });\n\n        try {\n            const confirmation = await response.awaitMessageComponent({ \n                filter: i => i.user.id === interaction.user.id, \n                time: 30000 \n            });\n\n            if (confirmation.customId === 'confirm_convert') {\n                // Remove player and create a player trainer item\n                userData.players.splice(playerIndex, 1);\n                if (!Array.isArray(userData.playerTrainers)) userData.playerTrainers = [];\n                const token = Math.random().toString(36).slice(2, 10);\n                userData.playerTrainers.push({\n                    token,\n                    playerId: player.id,\n                    name: player.name,\n                    rarity: player.rarity,\n                    exp: conversionExp,\n                    createdAt: Date.now()\n                });\n\n                client.setUserData(interaction.user.id, userData);\n\n                const successEmbed = new EmbedBuilder()\n                    .setTitle('‚úÖ Player Converted!')\n                    .setColor('#27ae60')\n                    .setDescription(`**${player.name}** has been converted to a Player Trainer item!`)\n                    .addFields(\n                        { name: 'üßë‚Äçüè´ Trainer', value: `${player.name} ‚Äî ${player.rarity}`, inline: true },\n                        { name: 'üìä EXP Value', value: `+${conversionExp.toLocaleString()}`, inline: true },\n                        { name: 'How to use', value: 'Use `/training player` and select the trainer option, then pick your Player Trainer from the list.' }\n                    );\n\n                await confirmation.update({ embeds: [successEmbed], components: [] });\n            } else {\n                await confirmation.update({ \n                    content: '‚ùå Player conversion cancelled.', \n                    embeds: [], \n                    components: [] \n                });\n            }\n        } catch (error) {\n            await interaction.editReply({ \n                content: '‚è∞ Conversion timed out. Player was not converted.', \n                embeds: [], \n                components: [] \n            });\n        }\n    },\n\n    async handleTrainingInfo(interaction, userData) {\n        const playerName = interaction.options.getString('player');\n\n        if (playerName) {\n            // Show specific player info\n            const player = userData.players.find(p => \n                p.name.toLowerCase().includes(playerName.toLowerCase())\n            );\n\n            if (!player) {\n                return await interaction.reply({ \n                    content: `‚ùå Player \"${playerName}\" not found in your collection!`, \n                    ephemeral: true \n                });\n            }\n\n            initializePlayerLevel(player);\n\n            const expNeeded = player.level >= player.maxLevel ? 0 : calculateExpNeeded(player.level);\n            const progressBar = this.createProgressBar(player.exp, expNeeded);\n            const conversionExp = getConversionExp(player.rarity);\n\n            const embed = new EmbedBuilder()\n                .setTitle(`üèãÔ∏è Training Info: ${player.name}`)\n                .setColor('#3498db')\n                .setDescription(`Level ${player.level}/${player.maxLevel} ‚Ä¢ Overall: ${player.overall}`)\n                .addFields(\n                    { name: 'üéØ Position', value: player.position, inline: true },\n                    { name: '‚≠ê Rarity', value: player.rarity, inline: true },\n                    { name: 'üé™ Playing Style', value: player.playingStyle || 'None', inline: true },\n                    { name: 'üìà EXP Progress', value: `${player.exp}/${expNeeded} (${this.createProgressBar(player.exp, expNeeded)})`, inline: false }\n                );\n\n            // Add player face as thumbnail\n            const playerFace = getPlayerFace(player.name);\n            let files = [];\n            if (playerFace) {\n                embed.setThumbnail(`attachment://${playerFace.filename}`);\n                files.push(playerFace.filePath);\n            }\n\n            embed.addFields({ name: 'üîÑ Conversion Value', value: `${conversionExp.toLocaleString()} EXP`, inline: true });\n\n            // Always show stats \n            let statDisplay = '';\n            for (const [statName, currentStat] of Object.entries(player.stats)) {\n                if (player.level >= player.maxLevel) {\n                    statDisplay += `${statName}: ${currentStat}\\n`;\n                } else {\n                    const maxStats = calculateStatsForLevel(\n                        player.maxStats, \n                        player.position, \n                        player.playingStyle, \n                        player.maxLevel, \n                        player.maxLevel, \n                        player.rarity\n                    );\n                    const maxStat = maxStats[statName];\n                    statDisplay += `${statName}: ${currentStat}/${maxStat}\\n`;\n                }\n            }\n\n            const statFieldName = player.level >= player.maxLevel ? 'üìä Player Stats' : 'üìä Stats (Current/Max)';\n            embed.addFields({ name: statFieldName, value: statDisplay, inline: true });\n\n            await interaction.reply({ embeds: [embed], files });\n        } else {\n            // Show training overview\n            const trainablePlayers = userData.players.filter(p => {\n                initializePlayerLevel(p);\n                return p.level < p.maxLevel;\n            }).slice(0, 10);\n\n            const embed = new EmbedBuilder()\n                .setTitle('üèãÔ∏è Training Center')\n                .setColor('#f39c12')\n                .setDescription('Your trainable players and training options')\n                .addFields(\n                    { name: 'üíº Training EXP', value: `${userData.trainingExp || 0} EXP available`, inline: true }\n                );\n\n            if (trainablePlayers.length > 0) {\n                const playerList = trainablePlayers.map(p => {\n                    const expNeeded = calculateExpNeeded(p.level);\n                    return `**${p.name}** - Lv.${p.level}/${p.maxLevel} (${p.exp}/${expNeeded} EXP)`;\n                }).join('\\n');\n\n                embed.addFields({ name: 'üìã Trainable Players', value: playerList });\n            } else {\n                embed.addFields({ name: 'üìã Trainable Players', value: 'All your players are at max level!' });\n            }\n\n            // Add trainer info\n            let trainerInfo = '';\n            for (const [key, trainer] of Object.entries(TRAINER_TYPES)) {\n                trainerInfo += `**${trainer.name}**\\n`;\n                trainerInfo += `Cost: ${trainer.cost.toLocaleString()} ${trainer.currency}\\n`;\n                trainerInfo += `EXP: +${trainer.expGain.toLocaleString()}\\n\\n`;\n            }\n\n            embed.addFields({ name: 'üéØ Available Trainers', value: trainerInfo });\n\n            await interaction.reply({ embeds: [embed] });\n        }\n    },\n\n    async handleTrainingShop(interaction, userData, client) {\n        const embed = new EmbedBuilder()\n            .setTitle('üè™ Training Shop')\n            .setColor('#e74c3c')\n            .setDescription('Purchase training items to level up your players!')\n            .addFields(\n                { \n                    name: 'üí∞ Your Currency', \n                    value: `GP: ${userData.gp.toLocaleString()}\\neCoins: ${userData.eCoins}\\nTraining EXP: ${userData.trainingExp || 0}`, \n                    inline: true \n                }\n            );\n\n        let shopItems = '';\n        for (const [key, trainer] of Object.entries(TRAINER_TYPES)) {\n            shopItems += `**${trainer.name}**\\n`;\n            shopItems += `${trainer.description}\\n`;\n            shopItems += `Cost: ${trainer.cost.toLocaleString()} ${trainer.currency}\\n\\n`;\n        }\n\n        embed.addFields({ name: 'üõí Available Items', value: shopItems });\n        embed.addFields({ \n            name: 'üîÑ Player Conversion', \n            value: 'Convert unwanted players to training EXP!\\nUse `/training convert` to convert a player.' \n        });\n        embed.setFooter({ text: 'Use /training player to train your players!' });\n\n        await interaction.reply({ embeds: [embed] });\n    },\n\n    createProgressBar(current, max, length = 10) {\n        if (max === 0) return '‚ñà'.repeat(length) + ' MAX';\n        const progress = Math.min(current / max, 1);\n        const filled = Math.floor(progress * length);\n        const empty = length - filled;\n        return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty) + ` ${Math.floor(progress * 100)}%`;\n    },\n\n    async autocomplete(interaction) {\n        const focusedOption = interaction.options.getFocused(true);\n        const { client } = interaction;\n        const userData = client.getUserData(interaction.user.id);\n\n        if (focusedOption.name === 'player' && userData.players) {\n            const subcommand = interaction.options.getSubcommand();\n            \n            let filtered;\n            if (subcommand === 'convert') {\n                // For conversion, show all players with their conversion value\n                filtered = userData.players\n                    .filter(player => \n                        player.name.toLowerCase().includes(focusedOption.value.toLowerCase())\n                    )\n                    .slice(0, 25)\n                    .map(player => {\n                        const conversionExp = getConversionExp(player.rarity);\n                        return {\n                            name: `${player.name} - ${player.rarity} (${conversionExp} EXP)`,\n                            value: player.name\n                        };\n                    });\n            } else {\n                // For training, show players with level info\n                filtered = userData.players\n                    .filter(player => \n                        player.name.toLowerCase().includes(focusedOption.value.toLowerCase())\n                    )\n                    .slice(0, 25)\n                    .map(player => ({\n                        name: `${player.name} (Lv.${player.level || 1}/${player.maxLevel || 20}) - ${player.rarity}`,\n                        value: player.name\n                    }));\n            }\n\n            await interaction.respond(filtered);\n        } else if (focusedOption.name === 'trainer') {\n            // Trainer autocomplete: include standard trainer types first, then player's own trainers\n            const query = String(focusedOption.value || '').toLowerCase();\n\n            const standard = Object.entries(TRAINER_TYPES).map(([key, t]) => ({\n                name: `${t.name} ‚Äî Cost: ${t.cost.toLocaleString()} ${t.currency} ‚Äî +${t.expGain.toLocaleString()} EXP`,\n                value: key\n            }));\n\n            const playerTrainers = (userData.playerTrainers || []).map(pt => ({\n                name: `Player Trainer: ${pt.name} (${pt.rarity}) ‚Äî +${pt.exp.toLocaleString()} EXP`,\n                value: `player:${pt.token}`\n            }));\n\n            const merged = [...standard, ...playerTrainers]\n                .filter(opt => opt.name.toLowerCase().includes(query))\n                .slice(0, 25);\n\n            await interaction.respond(merged);\n        }\n    }\n};","size_bytes":32434},"REAL_BUG_FOUND.md":{"content":"# üêõ THE REAL BUG - FOUND AND FIXED!\n\n## üéØ **YOU WERE RIGHT!**\n\nThe problem was NOT in the drag-and-drop or duplicate detection. It was in the **RENDERING CODE**!\n\n---\n\n## üîç **The Real Bug:**\n\n### **Formation Array:**\n```javascript\n'4-3-3': ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', 'LWF', 'CF', 'RWF']\n//                      ‚Üë    ‚Üë          ‚Üë     ‚Üë     ‚Üë\n//                   index 2  3      index 5   6    7\n//                   Same position!  Same position!\n```\n\n### **Buggy Code:**\n```javascript\nrows[line].forEach((position, idx) => {\n    const posIndex = positions.indexOf(position);\n    //    ‚Üë BUG! indexOf('CMF') ALWAYS returns 5 (first CMF)\n    //    So ALL 3 CMF slots use index 5!\n    \n    const playerId = currentSquad.main[posIndex];\n    // Result: Same player appears 3 times!\n});\n```\n\n---\n\n## üí• **What Was Happening:**\n\n### **Example with CMF positions:**\n\n```javascript\nFormation: ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', ...]\n            index 0    1    2    3    4     5      6      7\n\nSquad data:\ncurrentSquad.main[5] = \"Kenny Abshire\"  // First CMF\ncurrentSquad.main[6] = \"Player B\"       // Second CMF  \ncurrentSquad.main[7] = \"Player C\"       // Third CMF\n\nRendering loop:\n- Loop 1: position = 'CMF' ‚Üí indexOf('CMF') = 5 ‚Üí Shows Kenny ‚úì\n- Loop 2: position = 'CMF' ‚Üí indexOf('CMF') = 5 ‚Üí Shows Kenny ‚ùå (should be Player B)\n- Loop 3: position = 'CMF' ‚Üí indexOf('CMF') = 5 ‚Üí Shows Kenny ‚ùå (should be Player C)\n\nResult: Kenny appears 3 times!\n```\n\n### **Same with CB positions:**\n\n```javascript\nFormation: ['GK', 'LB', 'CB', 'CB', 'RB', ...]\n            index 0    1    2    3    4\n\nSquad data:\ncurrentSquad.main[2] = \"Lafayette Wolff\"  // First CB\ncurrentSquad.main[3] = \"Player D\"         // Second CB\n\nRendering loop:\n- Loop 1: position = 'CB' ‚Üí indexOf('CB') = 2 ‚Üí Shows Lafayette ‚úì\n- Loop 2: position = 'CB' ‚Üí indexOf('CB') = 2 ‚Üí Shows Lafayette ‚ùå (should be Player D)\n\nResult: Lafayette appears 2 times!\n```\n\n---\n\n## ‚úÖ **The Fix:**\n\n### **New Code:**\n```javascript\n// Track which indices we've already used\nconst usedIndices = new Set();\n\nrows[line].forEach((position, idx) => {\n    // Find the NEXT occurrence that we haven't used yet\n    let posIndex = -1;\n    for (let i = 0; i < positions.length; i++) {\n        if (positions[i] === position && !usedIndices.has(i)) {\n            posIndex = i;\n            usedIndices.add(i);  // Mark as used\n            break;\n        }\n    }\n    \n    const playerId = currentSquad.main[posIndex];\n    // Now each position gets its OWN unique index!\n});\n```\n\n### **How It Works Now:**\n\n```javascript\nFormation: ['GK', 'LB', 'CB', 'CB', 'RB', 'CMF', 'CMF', 'CMF', ...]\n\nRendering loop with fix:\n- Loop 1: Find first unused 'CMF' ‚Üí index 5 ‚Üí Kenny ‚úì\n  usedIndices = {5}\n  \n- Loop 2: Find first unused 'CMF' ‚Üí index 6 ‚Üí Player B ‚úì\n  usedIndices = {5, 6}\n  \n- Loop 3: Find first unused 'CMF' ‚Üí index 7 ‚Üí Player C ‚úì\n  usedIndices = {5, 6, 7}\n\nResult: Each player appears once! ‚úÖ\n```\n\n---\n\n## üéØ **Why This Caused Duplicates:**\n\n### **The Chain Reaction:**\n\n1. **Rendering shows duplicates** (Kenny x3)\n2. **User sees Kenny in all 3 CMF slots**\n3. **But actual data has:**\n   - `main[5] = \"Kenny\"`\n   - `main[6] = null` (or different player)\n   - `main[7] = null` (or different player)\n4. **Display doesn't match data!**\n5. **User clicks to change ‚Üí confusion**\n6. **Drag and drop ‚Üí more confusion**\n\n---\n\n## üìä **Before vs After:**\n\n### **Before (Buggy):**\n```\nDisplay:\nCMF: Kenny Abshire (88)\nCMF: Kenny Abshire (88)  ‚Üê WRONG! Should be empty\nCMF: Kenny Abshire (88)  ‚Üê WRONG! Should be empty\n\nActual Data:\nmain[5] = \"Kenny\"\nmain[6] = null\nmain[7] = null\n```\n\n### **After (Fixed):**\n```\nDisplay:\nCMF: Kenny Abshire (88)  ‚Üê Correct (index 5)\nCMF: Click to add        ‚Üê Correct (index 6 is null)\nCMF: Click to add        ‚Üê Correct (index 7 is null)\n\nActual Data:\nmain[5] = \"Kenny\"\nmain[6] = null\nmain[7] = null\n\nDISPLAY MATCHES DATA! ‚úÖ\n```\n\n---\n\n## üöÄ **Test Now:**\n\n### **1. Hard Refresh:**\n```\nCtrl + Shift + R (Windows)\nCmd + Shift + R (Mac)\n```\n\n### **2. Expected Result:**\n\n**If you have Kenny in only ONE CMF position:**\n- Display should show Kenny ONCE\n- Other CMF slots should be empty\n\n**If you have Lafayette in only ONE CB position:**\n- Display should show Lafayette ONCE\n- Other CB slot should be empty\n\n### **3. Verify:**\n- Website display matches Discord bot\n- No visual duplicates\n- Each player appears once only\n\n---\n\n## üéâ **Summary:**\n\n### **The Bug:**\n- `indexOf()` always returns the FIRST occurrence\n- Multiple positions with same name (CMF, CMF, CMF) all got index 5\n- Same player displayed 3 times\n\n### **The Fix:**\n- Track which indices we've used\n- Find NEXT unused occurrence\n- Each position gets unique index\n- Each player displays once\n\n### **Why You Were Right:**\nThe duplicate detection WAS working! The data was clean! But the RENDERING was showing the same player multiple times because of the `indexOf()` bug.\n\n---\n\n**Refresh your browser now - the duplicates should be GONE!** üéâ‚öΩ\n","size_bytes":5099},"commands/news.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst NEWS_FILE = path.join(__dirname, '..', 'news.json');\n\n// Load news\nfunction loadNews() {\n    if (!fs.existsSync(NEWS_FILE)) {\n        return [];\n    }\n    const data = fs.readFileSync(NEWS_FILE, 'utf8');\n    return JSON.parse(data);\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('news')\n        .setDescription('View the latest game updates and news')\n        .addIntegerOption(option =>\n            option.setName('page')\n                .setDescription('Page number to view')\n                .setRequired(false)\n                .setMinValue(1)),\n    \n    async execute(interaction) {\n        try {\n            const newsArray = loadNews();\n            \n            if (newsArray.length === 0) {\n                return interaction.reply({\n                    embeds: [\n                        new EmbedBuilder()\n                            .setColor('#0014DC')\n                            .setTitle('üì∞ Game News')\n                            .setDescription('No news available at the moment. Check back later!\\n\\nVisit the website for more: http://localhost:3000/news')\n                            .setTimestamp()\n                    ],\n                    ephemeral: true\n                });\n            }\n            \n            // Sort news by date (newest first)\n            const sortedNews = newsArray.sort((a, b) => new Date(b.date) - new Date(a.date));\n            \n            const page = interaction.options.getInteger('page') || 1;\n            const itemsPerPage = 5;\n            const totalPages = Math.ceil(sortedNews.length / itemsPerPage);\n            \n            if (page > totalPages) {\n                return interaction.reply({\n                    content: `‚ùå Invalid page number. There are only ${totalPages} page(s) of news.`,\n                    ephemeral: true\n                });\n            }\n            \n            const startIndex = (page - 1) * itemsPerPage;\n            const endIndex = startIndex + itemsPerPage;\n            const pageNews = sortedNews.slice(startIndex, endIndex);\n            \n            const embed = new EmbedBuilder()\n                .setColor('#FFED00')\n                .setTitle('üì∞ eFOOTBALL WANNABE - Latest News')\n                .setDescription('Stay updated with the latest game updates, events, and announcements!\\n\\nüåê View on website: http://localhost:3000/news')\n                .setFooter({ text: `Page ${page}/${totalPages} ‚Ä¢ Total News: ${sortedNews.length}` })\n                .setTimestamp();\n            \n            const categoryEmoji = {\n                'Update': '‚¨ÜÔ∏è',\n                'Issue': '‚úï',\n                'Event': 'üéâ',\n                'Maintenance': 'üîß',\n                'Announcement': 'üì¢'\n            };\n            \n            pageNews.forEach((news) => {\n                const newsDate = new Date(news.date);\n                const formattedDate = newsDate.toLocaleDateString('en-US', {\n                    year: 'numeric',\n                    month: 'short',\n                    day: 'numeric'\n                });\n                \n                const emoji = categoryEmoji[news.category] || 'üì∞';\n                \n                embed.addFields({\n                    name: `${emoji} ${news.title}`,\n                    value: `${news.content}\\n\\n*${formattedDate}*`,\n                    inline: false\n                });\n            });\n            \n            await interaction.reply({ embeds: [embed] });\n            \n        } catch (error) {\n            console.error('Error in news command:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while fetching the news.',\n                ephemeral: true\n            });\n        }\n    }\n};\n","size_bytes":3873},"DRAG_DROP_GUIDE.md":{"content":"# üéÆ Drag & Drop Squad Builder Guide\n\nYour eFotball wannabe dashboard now has **full drag-and-drop functionality**!\n\n---\n\n## ‚úÖ What's New:\n\n### **1. Updated Branding**\n- ‚úÖ Changed \"eFotball Manager\" ‚Üí **\"eFOOTBALL WANNABE\"**\n- ‚úÖ New navigation style matching official eFotball design\n- ‚úÖ Yellow HOME button and Pink LOGOUT button\n\n### **2. Drag & Drop Features**\n\n#### **üîÑ Swap Players on Pitch**\n- **Drag** any player from one position\n- **Drop** on another position to swap them\n- Visual feedback shows where you're dropping\n\n#### **‚ûï Add Players from List**\n- **Drag** players from \"Available Players\" list\n- **Drop** them onto empty positions on the pitch\n- Or **click** positions to select from a list (old method still works!)\n\n#### **üëÜ Click to Change**\n- **Click** any position on the pitch\n- Select a player from the filtered list\n- Works alongside drag-and-drop\n\n---\n\n## üéØ How to Use:\n\n### **Method 1: Drag & Drop (NEW!)**\n\n1. Go to **Squad Builder** tab\n2. **Grab** a player card (cursor changes to grab hand)\n3. **Drag** it to a position on the pitch\n4. **Drop** it (position highlights in yellow)\n5. Players automatically swap if position is occupied!\n\n### **Method 2: Click to Select (Original)**\n\n1. **Click** any position on the pitch\n2. Choose from filtered compatible players\n3. Player is assigned to that position\n\n### **Method 3: Swap on Pitch**\n\n1. **Drag** a player already on the pitch\n2. **Drop** on another player's position\n3. They swap positions automatically!\n\n---\n\n## üé® Visual Feedback:\n\n- **Grab Cursor** (üñêÔ∏è) - Hover over draggable players\n- **Grabbing** (‚úä) - While dragging\n- **Yellow Highlight** - Valid drop zone\n- **Rotation Effect** - Player being dragged\n- **Opacity** - Shows what's being moved\n\n---\n\n## üîß Navigation Updates:\n\n### **New Button Styles:**\n\n```\n[HOME] Overview Squad-Builder My-Players Online-Support [LOGOUT]\n  ‚Üë                                                        ‚Üë\nYellow                                                   Pink\nButton                                                  Button\n```\n\n- **HOME** - Yellow button, takes you to overview\n- **Overview** - Regular link\n- **Squad Builder** - Regular link\n- **My Players** - Regular link  \n- **Online Support** - Regular link\n- **LOGOUT** - Pink button, logs you out\n\n---\n\n## üí° Tips:\n\n1. **Drag from anywhere** - Grab players from the available list or from the pitch\n2. **Swap easily** - Drag one player onto another to swap positions\n3. **Visual feedback** - Yellow glow shows valid drop zones\n4. **Save your squad** - Click \"üíæ Save Squad\" when done\n5. **Formation changes** - Select different formations (4-3-3, 4-4-2, etc.)\n\n---\n\n## üêõ Troubleshooting:\n\n### **Drag not working?**\n- Make sure you're grabbing the player card itself\n- Check that the player is in your collection\n- Try clicking instead - both methods work!\n\n### **Can't drop player?**\n- Position might not be compatible\n- Try a different position\n- Use click method as backup\n\n### **Players not swapping?**\n- Make sure you're dropping on a valid position\n- Check that both players are compatible with their new positions\n\n---\n\n## üéÆ Keyboard Shortcuts:\n\n- **Click** - Select player (original method)\n- **Drag** - Move/swap players (new method)\n- **Escape** - Close modals\n- **Tab** - Navigate between tabs\n\n---\n\n## üì± Mobile Support:\n\n- Touch and drag works on mobile devices\n- Long press to grab players\n- Drag to position and release\n- Click method also available for easier mobile use\n\n---\n\n## üöÄ What's Next:\n\nFuture enhancements could include:\n- Auto-suggest best formation\n- Player chemistry indicators\n- Drag to bench\n- Undo/redo functionality\n- Save multiple squad presets\n\n---\n\n**Enjoy building your dream team with drag & drop! ‚öΩüéÆ**\n","size_bytes":3783},"public/mail.js":{"content":"// Global state\nlet userData = null;\nlet mailData = [];\n\nconst REWARD_EMOJIS = {\n    'gp': 'üí∞',\n    'eCoins': 'ü™ô',\n    'player': 'üë§',\n    'pack': 'üì¶',\n    'trainer': 'üìö'\n};\n\n// Initialize\nasync function init() {\n    await loadUserData();\n    await loadMail();\n    document.getElementById('loading').style.display = 'none';\n}\n\n// Load user data\nasync function loadUserData() {\n    try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        userData = data;\n        \n        // Update UI\n        document.getElementById('username').textContent = data.discord.username;\n        document.getElementById('userAvatar').src = `https://cdn.discordapp.com/avatars/${data.discord.id}/${data.discord.avatar}.png`;\n        \n        if (data.gameData) {\n            document.getElementById('topGP').textContent = (data.gameData.gp || 0).toLocaleString();\n            document.getElementById('topEcoins').textContent = data.gameData.eCoins || 0;\n        }\n    } catch (error) {\n        console.error('Error loading user data:', error);\n    }\n}\n\n// Load mail\nasync function loadMail() {\n    try {\n        const response = await fetch('/api/mail');\n        const data = await response.json();\n        mailData = data.mail || [];\n        \n        console.log('Loaded mail data:', mailData);\n        console.log('Mail count:', mailData.length);\n        \n        renderMail();\n        updateStats();\n    } catch (error) {\n        console.error('Error loading mail:', error);\n        document.getElementById('emptyState').style.display = 'block';\n    }\n}\n\n// Render mail\nfunction renderMail() {\n    const container = document.getElementById('mailList');\n    container.innerHTML = '';\n    \n    console.log('Rendering mail. Total items:', mailData.length);\n    \n    // Sort by date (newest first) and filter out claimed mail\n    const sortedMail = [...mailData]\n        .filter(m => !m.claimed)\n        .sort((a, b) => new Date(b.date) - new Date(a.date));\n    \n    console.log('Unclaimed mail:', sortedMail.length);\n    console.log('Mail items:', sortedMail);\n    \n    if (sortedMail.length === 0) {\n        document.getElementById('emptyState').style.display = 'block';\n        return;\n    }\n    \n    document.getElementById('emptyState').style.display = 'none';\n    \n    sortedMail.forEach((mail, index) => {\n        // Generate ID if it doesn't exist\n        if (!mail.id) {\n            mail.id = `mail_${Date.now()}_${index}`;\n        }\n        \n        const mailItem = document.createElement('div');\n        mailItem.className = 'inbox-item';\n        mailItem.dataset.mailId = mail.id;\n        \n        const date = new Date(mail.date);\n        const formattedDate = date.toLocaleDateString('en-US', {\n            month: '2-digit',\n            day: '2-digit',\n            year: 'numeric'\n        });\n        \n        // Get reward icon and description\n        let rewardIcon = 'üéÅ';\n        let rewardDescription = '';\n        let expiryText = '';\n        \n        // Handle new format (rewards object)\n        if (mail.rewards) {\n            const rewardParts = [];\n            \n            if (mail.rewards.gp) {\n                rewardIcon = 'üí∞';\n                rewardParts.push(`${mail.rewards.gp.toLocaleString()} GP`);\n            }\n            if (mail.rewards.eCoins) {\n                rewardIcon = 'ü™ô';\n                rewardParts.push(`${mail.rewards.eCoins} eFootball‚Ñ¢ Coins`);\n            }\n            if (mail.rewards.players && mail.rewards.players.length > 0) {\n                mail.rewards.players.forEach(player => {\n                    rewardIcon = 'üë§';\n                    rewardParts.push(`${player.name} x1`);\n                });\n            }\n            if (mail.rewards.packs && mail.rewards.packs.length > 0) {\n                mail.rewards.packs.forEach(pack => {\n                    rewardIcon = '‚≠ê';\n                    rewardParts.push(`${pack} Pack x1`);\n                });\n            }\n            \n            rewardDescription = rewardParts.join(', ');\n        }\n        // Handle old format (type, amount, rarity fields)\n        else if (mail.type) {\n            if (mail.type === 'gp') {\n                rewardIcon = 'üí∞';\n                rewardDescription = `${(mail.amount || 0).toLocaleString()} GP`;\n            } else if (mail.type === 'eCoins') {\n                rewardIcon = 'ü™ô';\n                rewardDescription = `${mail.amount || 0} eFootball‚Ñ¢ Coins`;\n            } else if (mail.type === 'pack') {\n                rewardIcon = '‚≠ê';\n                rewardDescription = `${mail.rarity || 'Free'} Pack x1`;\n            } else if (mail.type === 'trainer') {\n                rewardIcon = 'üìö';\n                rewardDescription = `${mail.trainerName || 'Trainer'} x1`;\n            }\n        }\n        \n        // Check if mail has expiry\n        if (mail.expiry) {\n            const expiryDate = new Date(mail.expiry);\n            const now = new Date();\n            const diffTime = expiryDate - now;\n            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n            const diffHours = Math.ceil((diffTime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n            \n            if (diffTime > 0) {\n                expiryText = `<div class=\"inbox-expiry\">Expires in: ${diffDays} day(s) ${diffHours} hr(s)</div>`;\n            }\n        }\n        \n        mailItem.innerHTML = `\n            <div class=\"inbox-icon\" style=\"background: ${getRewardColor(mail)}\">\n                <span>${rewardIcon}</span>\n            </div>\n            <div class=\"inbox-content\">\n                <div class=\"inbox-title\">${mail.title || (mail.type ? (mail.type === 'pack' ? 'Free Pack' : mail.type === 'eCoins' ? 'eCoins Reward' : mail.type === 'gp' ? 'GP Reward' : 'Reward') : 'Reward')}</div>\n                <div class=\"inbox-description\">${rewardDescription || 'You have received rewards!'}</div>\n            </div>\n            <div class=\"inbox-meta\">\n                <div class=\"inbox-date\">${formattedDate}</div>\n                ${expiryText}\n            </div>\n        `;\n        \n        container.appendChild(mailItem);\n    });\n}\n\n// Get reward background color based on type\nfunction getRewardColor(mail) {\n    // Handle new format (rewards object)\n    if (mail.rewards) {\n        const rewards = mail.rewards;\n        if (rewards.players && rewards.players.length > 0) {\n            return 'linear-gradient(135deg, #4CAF50, #45a049)'; // Green for players\n        }\n        if (rewards.eCoins) {\n            return 'linear-gradient(135deg, #FFD700, #FFA500)'; // Gold for coins\n        }\n        if (rewards.packs && rewards.packs.length > 0) {\n            return 'linear-gradient(135deg, #FFEB3B, #FBC02D)'; // Yellow for packs\n        }\n        if (rewards.gp) {\n            return 'linear-gradient(135deg, #2196F3, #1976D2)'; // Blue for GP\n        }\n    }\n    // Handle old format (type field)\n    else if (mail.type) {\n        if (mail.type === 'pack') {\n            return 'linear-gradient(135deg, #FFEB3B, #FBC02D)'; // Yellow for packs\n        }\n        if (mail.type === 'eCoins') {\n            return 'linear-gradient(135deg, #FFD700, #FFA500)'; // Gold for coins\n        }\n        if (mail.type === 'gp') {\n            return 'linear-gradient(135deg, #2196F3, #1976D2)'; // Blue for GP\n        }\n        if (mail.type === 'trainer') {\n            return 'linear-gradient(135deg, #9C27B0, #7B1FA2)'; // Purple for trainers\n        }\n    }\n    \n    return 'linear-gradient(135deg, #4CAF50, #45a049)'; // Green default\n}\n\n// Update stats\nfunction updateStats() {\n    const unclaimed = mailData.filter(m => !m.claimed).length;\n    \n    // Update badge\n    const badge = document.getElementById('mailBadge');\n    if (badge) {\n        if (unclaimed > 0) {\n            badge.textContent = unclaimed;\n            badge.style.display = 'block';\n        } else {\n            badge.style.display = 'none';\n        }\n    }\n    \n    // Enable/disable claim all button\n    const claimAllBtn = document.getElementById('claimAllBtn');\n    if (claimAllBtn) {\n        claimAllBtn.disabled = unclaimed === 0;\n    }\n}\n\n// Claim single mail\nasync function claimMail(mailId) {\n    if (!mailId) {\n        console.error('No mail ID provided');\n        showNotification('‚ùå Invalid mail ID', 'error');\n        return;\n    }\n    \n    try {\n        console.log('Claiming mail:', mailId);\n        \n        const response = await fetch('/api/mail/claim', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ mailId: mailId })\n        });\n        \n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        console.log('Claim response:', data);\n        \n        if (data.success) {\n            // Update local data\n            const mail = mailData.find(m => m.id == mailId || m.id === mailId);\n            if (mail) {\n                mail.claimed = true;\n            }\n            \n            // Show detailed success message\n            let message = '‚úÖ Claimed successfully!';\n            showNotification(message, 'success');\n            \n            // Re-render\n            renderMail();\n            updateStats();\n            \n            // Reload user data to update currency\n            await loadUserData();\n        } else {\n            console.error('Claim failed:', data.message);\n            showNotification('‚ùå ' + (data.message || 'Failed to claim reward'), 'error');\n        }\n    } catch (error) {\n        console.error('Error claiming mail:', error);\n        showNotification('‚ùå Error: ' + error.message, 'error');\n    }\n}\n\n// Claim all mail\nasync function claimAll() {\n    try {\n        const response = await fetch('/api/mail/claim-all', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        \n        const data = await response.json();\n        console.log('Claim all response:', data);\n        \n        if (data.success) {\n            // Update local data\n            mailData.forEach(mail => {\n                if (!mail.claimed) {\n                    mail.claimed = true;\n                }\n            });\n            \n            // Show success message\n            const count = data.claimedCount || 0;\n            let message = `‚úÖ Claimed ${count} reward(s) successfully!`;\n            showNotification(message, 'success');\n            \n            // Reload all data\n            await loadMail();\n            await loadUserData();\n        } else {\n            showNotification('‚ùå ' + (data.message || 'Failed to claim rewards'), 'error');\n        }\n    } catch (error) {\n        console.error('Error claiming all mail:', error);\n        showNotification('‚ùå Error claiming rewards', 'error');\n    }\n}\n\n// Show notification\nfunction showNotification(message, type = 'info') {\n    // Create notification element\n    const notification = document.createElement('div');\n    notification.className = `notification notification-${type}`;\n    notification.textContent = message;\n    notification.style.cssText = `\n        position: fixed;\n        top: 80px;\n        right: 20px;\n        background: ${type === 'success' ? '#27ae60' : '#e74c3c'};\n        color: white;\n        padding: 15px 25px;\n        border-radius: 10px;\n        font-weight: bold;\n        z-index: 10000;\n        animation: slideIn 0.3s ease-out;\n    `;\n    \n    document.body.appendChild(notification);\n    \n    // Remove after 3 seconds\n    setTimeout(() => {\n        notification.style.animation = 'slideOut 0.3s ease-out';\n        setTimeout(() => notification.remove(), 300);\n    }, 3000);\n}\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', init);\n","size_bytes":11889},"scripts/update-players-level.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\n// Rarity-based configuration\nconst RARITY_CONFIG = {\n    'Iconic': { maxLevel: 50, statMultiplier: 1.0, overallBonus: 0 },\n    'Legend': { maxLevel: 45, statMultiplier: 0.95, overallBonus: -2 },\n    'Black': { maxLevel: 40, statMultiplier: 0.90, overallBonus: -5 },\n    'Gold': { maxLevel: 35, statMultiplier: 0.85, overallBonus: -8 },\n    'Silver': { maxLevel: 30, statMultiplier: 0.80, overallBonus: -12 },\n    'Bronze': { maxLevel: 25, statMultiplier: 0.75, overallBonus: -16 },\n    'White': { maxLevel: 20, statMultiplier: 0.70, overallBonus: -20 }\n};\n\n// Position-based stat growth priorities\nconst POSITION_STAT_PRIORITY = {\n    'GK': { goalkeeping: 2.0, defending: 1.2, physicality: 1.1, passing: 0.8, attacking: 0.3, dribbling: 0.4 },\n    'CB': { defending: 1.8, physicality: 1.5, passing: 1.0, goalkeeping: 0.1, attacking: 0.4, dribbling: 0.5 },\n    'LB': { defending: 1.4, passing: 1.3, physicality: 1.1, dribbling: 1.0, attacking: 0.8, goalkeeping: 0.1 },\n    'RB': { defending: 1.4, passing: 1.3, physicality: 1.1, dribbling: 1.0, attacking: 0.8, goalkeeping: 0.1 },\n    'DMF': { defending: 1.5, passing: 1.4, physicality: 1.2, dribbling: 0.9, attacking: 0.7, goalkeeping: 0.1 },\n    'CMF': { passing: 1.6, dribbling: 1.3, defending: 1.0, physicality: 1.0, attacking: 1.1, goalkeeping: 0.1 },\n    'AMF': { passing: 1.5, dribbling: 1.4, attacking: 1.3, physicality: 0.8, defending: 0.6, goalkeeping: 0.1 },\n    'LMF': { dribbling: 1.4, passing: 1.3, attacking: 1.1, physicality: 1.0, defending: 0.8, goalkeeping: 0.1 },\n    'RMF': { dribbling: 1.4, passing: 1.3, attacking: 1.1, physicality: 1.0, defending: 0.8, goalkeeping: 0.1 },\n    'LWF': { dribbling: 1.5, attacking: 1.4, passing: 1.0, physicality: 0.9, defending: 0.5, goalkeeping: 0.1 },\n    'RWF': { dribbling: 1.5, attacking: 1.4, passing: 1.0, physicality: 0.9, defending: 0.5, goalkeeping: 0.1 },\n    'SS': { attacking: 1.6, dribbling: 1.4, passing: 1.2, physicality: 1.0, defending: 0.4, goalkeeping: 0.1 },\n    'CF': { attacking: 1.8, physicality: 1.3, dribbling: 1.1, passing: 1.0, defending: 0.3, goalkeeping: 0.1 }\n};\n\n// Playing style bonuses\nconst PLAYSTYLE_BONUSES = {\n    'Offensive Wingback': { attacking: 1.2, dribbling: 1.1 },\n    'Classic No. 10': { passing: 1.3, dribbling: 1.2 },\n    'Box-to-Box': { physicality: 1.2, passing: 1.1 },\n    'Destroyer': { defending: 1.3, physicality: 1.2 },\n    'Orchestrator': { passing: 1.4, dribbling: 1.1 },\n    'Hole Player': { attacking: 1.2, dribbling: 1.2 },\n    'Roaming Flank': { dribbling: 1.3, attacking: 1.1 },\n    'Cross Specialist': { passing: 1.2, attacking: 1.1 },\n    'Prolific Winger': { dribbling: 1.4, attacking: 1.2 },\n    'Goal Poacher': { attacking: 1.5 },\n    'Target Man': { physicality: 1.4, attacking: 1.2 },\n    'Deep-lying Forward': { passing: 1.3, attacking: 1.1 }\n};\n\nfunction calculateOverall(stats, rarity) {\n    const rarityConfig = RARITY_CONFIG[rarity] || RARITY_CONFIG['White'];\n    \n    // Calculate base overall from stats (excluding goalkeeping for outfield players)\n    const statEntries = Object.entries(stats);\n    const relevantStats = statEntries.filter(([name]) => name !== 'goalkeeping' || stats.goalkeeping > 50);\n    const avgStat = relevantStats.reduce((sum, [, stat]) => sum + stat, 0) / relevantStats.length;\n    \n    // Apply rarity bonus\n    let overall = Math.floor(avgStat + rarityConfig.overallBonus);\n    \n    // Add some randomness for variety (¬±2)\n    overall += Math.floor(Math.random() * 5) - 2;\n    \n    // Ensure overall is within reasonable bounds\n    return Math.max(30, Math.min(99, overall));\n}\n\nfunction calculateLevel1Stats(maxStats, position, playingStyle, rarity) {\n    const rarityConfig = RARITY_CONFIG[rarity] || RARITY_CONFIG['White'];\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    const styleBonuses = PLAYSTYLE_BONUSES[playingStyle] || {};\n    \n    const level1Stats = {};\n    \n    for (const [statName, maxStat] of Object.entries(maxStats)) {\n        const positionMultiplier = positionPriority[statName] || 1.0;\n        const styleMultiplier = styleBonuses[statName] || 1.0;\n        const rarityMultiplier = rarityConfig.statMultiplier;\n        \n        // Calculate level 1 stat (reduced from max level)\n        // Higher priority stats start closer to max, lower priority stats start much lower\n        let reductionFactor;\n        if (positionMultiplier >= 1.5) {\n            reductionFactor = 0.75; // Important stats start at 75% of max\n        } else if (positionMultiplier >= 1.0) {\n            reductionFactor = 0.65; // Normal stats start at 65% of max\n        } else {\n            reductionFactor = 0.50; // Unimportant stats start at 50% of max\n        }\n        \n        // Apply style bonuses to reduction factor\n        if (styleMultiplier > 1.0) {\n            reductionFactor += 0.05; // Slightly higher starting point for style bonuses\n        }\n        \n        // Add some randomness (¬±5%)\n        const randomFactor = (Math.random() * 0.1) - 0.05;\n        reductionFactor = Math.max(0.4, Math.min(0.8, reductionFactor + randomFactor));\n        \n        level1Stats[statName] = Math.max(10, Math.min(85, Math.floor(maxStat * reductionFactor)));\n    }\n    \n    return level1Stats;\n}\n\nfunction updatePlayersWithLevels() {\n    const playersPath = path.join(__dirname, '..', 'players.json');\n    \n    console.log('Reading players.json...');\n    const players = JSON.parse(fs.readFileSync(playersPath, 'utf8'));\n    \n    console.log(`Updating ${players.length} players with level system...`);\n    \n    const updatedPlayers = players.map((player, index) => {\n        if (index % 1000 === 0) {\n            console.log(`Processing player ${index + 1}/${players.length}...`);\n        }\n        \n        const rarityConfig = RARITY_CONFIG[player.rarity] || RARITY_CONFIG['White'];\n        \n        // Store current stats and overall as max level values\n        const maxStats = { ...player.stats };\n        const maxOverall = player.overall;\n        \n        // Calculate level 1 stats\n        const level1Stats = calculateLevel1Stats(maxStats, player.position, player.playingStyle, player.rarity);\n        const level1Overall = calculateOverall(level1Stats, player.rarity);\n        \n        // Update player with level system\n        return {\n            ...player,\n            level: 1,\n            exp: 0,\n            maxLevel: rarityConfig.maxLevel,\n            stats: level1Stats,\n            overall: level1Overall,\n            maxStats: maxStats,\n            maxOverall: maxOverall\n        };\n    });\n    \n    console.log('Writing updated players.json...');\n    fs.writeFileSync(playersPath, JSON.stringify(updatedPlayers, null, 2));\n    \n    console.log('‚úÖ Successfully updated all players with level system!');\n    \n    // Print some statistics\n    const rarityStats = {};\n    updatedPlayers.forEach(player => {\n        if (!rarityStats[player.rarity]) {\n            rarityStats[player.rarity] = { count: 0, avgLevel1Overall: 0, avgMaxLevel: 0 };\n        }\n        rarityStats[player.rarity].count++;\n        rarityStats[player.rarity].avgLevel1Overall += player.overall;\n        rarityStats[player.rarity].avgMaxLevel += player.maxLevel;\n    });\n    \n    console.log('\\nüìä Update Statistics:');\n    for (const [rarity, stats] of Object.entries(rarityStats)) {\n        const avgOverall = Math.round(stats.avgLevel1Overall / stats.count);\n        const avgMaxLevel = Math.round(stats.avgMaxLevel / stats.count);\n        console.log(`${rarity}: ${stats.count} players, Avg Level 1 Overall: ${avgOverall}, Max Level: ${avgMaxLevel}`);\n    }\n}\n\n// Run the update\nupdatePlayersWithLevels();\n","size_bytes":7721},"index.js":{"content":"require('dotenv').config();\nconst fs = require('fs');\nconst path = require('path');\nconst { Client, GatewayIntentBits, Collection, EmbedBuilder } = require('discord.js');\nconst config = require('./config.json');\n\n// --- Healthcheck Setup (Keep Bot Alive) ---\nconst HEALTHCHECK_URL = process.env.HEALTHCHECK_URL;\n\n// Function to send the \"I'm alive!\" signal\nfunction sendHealthcheck() {\n    if (HEALTHCHECK_URL) {\n        // Use fetch (built into Node.js 18+)\n        fetch(HEALTHCHECK_URL)\n            .then(res => console.log('‚úÖ Healthcheck sent successfully:', res.status))\n            .catch(err => console.error('‚ùå Healthcheck failed:', err));\n    } else {\n        console.warn(\"‚ö†Ô∏è HEALTHCHECK_URL not set. Skipping health check.\");\n    }\n}\n\n// Ping every 25 minutes (just under the 30-minute period)\nconst PING_INTERVAL_MS = 5 * 60 * 1000;\n\n// Start the interval timer\nsetInterval(sendHealthcheck, PING_INTERVAL_MS);\n\n// Run the first check immediately\nsendHealthcheck();\n\n// --- Discord Bot Setup ---\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n    ]\n});\n\n// --- Command Handler ---\nclient.commands = new Collection();\nconst commandFiles = fs.readdirSync(path.join(__dirname, 'commands')).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n    const command = require(path.join(__dirname, 'commands', file));\n    client.commands.set(command.data.name, command);\n}\n\n// --- User Data Management ---\nconst dataPath = path.join(__dirname, 'data');\nif (!fs.existsSync(dataPath)) {\n    fs.mkdirSync(dataPath);\n}\n\nclient.getUserData = (userId) => {\n    const userFile = path.join(dataPath, `${userId}.json`);\n    if (fs.existsSync(userFile)) {\n        const data = JSON.parse(fs.readFileSync(userFile));\n        // Backfill new fields\n        if (!data.players) data.players = [];\n        if (!data.squad) data.squad = { main: [], bench: [] };\n        if (!data.mail) data.mail = [];\n        if (!data.inventory) data.inventory = { freePacks: { Iconic: 0, Legend: 0, Black: 0 } };\n        if (!data.inventory.freePacks) data.inventory.freePacks = { Iconic: 0, Legend: 0, Black: 0 };\n        if (!data.minigames) data.minigames = {};\n        if (!data.daily) data.daily = { lastClaim: '' };\n        return data;\n    } else {\n        // Create a new user profile\n        const newUser = {\n            id: userId,\n            gp: 10000, // Starting GP\n            eCoins: 100, // Starting eCoins\n            players: [],\n            squad: { main: [], bench: [] },\n            mail: [],\n            inventory: { freePacks: { Iconic: 0, Legend: 0, Black: 0 } },\n            minigames: {},\n            daily: { lastClaim: '' },\n        };\n        fs.writeFileSync(userFile, JSON.stringify(newUser, null, 2));\n        return newUser;\n    }\n};\n\nclient.setUserData = (userId, data) => {\n    const userFile = path.join(dataPath, `${userId}.json`);\n    fs.writeFileSync(userFile, JSON.stringify(data, null, 2));\n};\n\n// List all known user IDs from the data directory\nclient.listAllUserIds = () => {\n    try {\n        return fs.readdirSync(dataPath)\n            .filter(f => f.endsWith('.json'))\n            .map(f => path.basename(f, '.json'));\n    } catch (e) {\n        return [];\n    }\n};\n\n// --- Helpers ---\nfunction todayKey() {\n    const d = new Date();\n    return d.toISOString().slice(0, 10); // YYYY-MM-DD\n}\n\n// --- Bot Events ---\nclient.once('clientReady', async () => {\n    // Fetch application to determine bot owner (for owner-only commands)\n    try {\n        await client.application.fetch();\n        client.botOwnerId = client.application?.owner?.id || process.env.BOT_OWNER_ID || null;\n    } catch (e) {\n        client.botOwnerId = process.env.BOT_OWNER_ID || null;\n    }\n    console.log(`Logged in as ${client.user.tag}! Bot is ready.`);\n});\n\nclient.on('interactionCreate', async interaction => {\n    try {\n        // Handle button interactions for /collection pagination\n        if (interaction.isButton()) {\n            if (interaction.customId && interaction.customId.startsWith('collection:')) {\n                const collectionCmd = client.commands.get('collection');\n                if (collectionCmd && typeof collectionCmd.handleButton === 'function') {\n                    return await collectionCmd.handleButton(interaction);\n                }\n            }\n            if (interaction.customId && interaction.customId.startsWith('mail:')) {\n                const mailCmd = client.commands.get('mail');\n                if (mailCmd && typeof mailCmd.handleButton === 'function') {\n                    return await mailCmd.handleButton(interaction);\n                }\n            }\n            if (interaction.customId && interaction.customId.startsWith('penalty_')) {\n                const penaltyCmd = client.commands.get('penalty');\n                if (penaltyCmd && typeof penaltyCmd.handleButton === 'function') {\n                    return await penaltyCmd.handleButton(interaction);\n                }\n            }\n            if (interaction.customId && interaction.customId.startsWith('shoot_')) {\n                const matchCmd = client.commands.get('match');\n                if (matchCmd && typeof matchCmd.handleButton === 'function') {\n                    return await matchCmd.handleButton(interaction, client);\n                }\n            }\n            if (interaction.customId && interaction.customId.startsWith('pvpshoot_')) {\n                const pvpCmd = client.commands.get('pvp');\n                if (pvpCmd && typeof pvpCmd.handleButton === 'function') {\n                    return await pvpCmd.handleButton(interaction, client);\n                }\n            }\n            if (interaction.customId && interaction.customId.startsWith('leaderboard_')) {\n                const leaderboardCmd = client.commands.get('leaderboard');\n                if (leaderboardCmd && typeof leaderboardCmd.handleButton === 'function') {\n                    return await leaderboardCmd.handleButton(interaction);\n                }\n            }\n            return; // ignore other buttons\n        }\n\n        // Autocomplete routing\n        if (interaction.isAutocomplete()) {\n            const command = client.commands.get(interaction.commandName);\n            if (command && typeof command.autocomplete === 'function') {\n                return await command.autocomplete(interaction);\n            }\n            return;\n        }\n\n        if (!interaction.isChatInputCommand()) return;\n\n        const command = client.commands.get(interaction.commandName);\n\n        if (!command) {\n            console.error(`No command matching ${interaction.commandName} was found.`);\n            return;\n        }\n\n        await command.execute(interaction);\n\n        // Auto-claim daily reward once per day (after any successful command)\n        try {\n            const userId = interaction.user.id;\n            const userData = client.getUserData(userId);\n            const today = todayKey();\n            if (!userData.daily) userData.daily = { lastClaim: '' };\n            if (userData.daily.lastClaim !== today) {\n                // Grant daily reward\n                const dailyReward = { gp: 2000, eCoins: 5 };\n                userData.gp = (userData.gp || 0) + dailyReward.gp;\n                userData.eCoins = (userData.eCoins || 0) + dailyReward.eCoins;\n                userData.daily.lastClaim = today;\n                client.setUserData(userId, userData);\n\n                const embed = new EmbedBuilder()\n                    .setTitle('üóìÔ∏è Daily Reward Claimed!')\n                    .setColor('#27ae60')\n                    .setDescription(`Thanks for playing today! Here are your daily rewards:`)\n                    .addFields(\n                        { name: 'GP', value: `+${dailyReward.gp.toLocaleString()}`, inline: true },\n                        { name: 'eCoins', value: `+${dailyReward.eCoins}`, inline: true },\n                    )\n                    .setFooter({ text: 'Come back tomorrow for more!' });\n\n                // Send as a separate message so it appears alongside the command result\n                await interaction.followUp({ embeds: [embed] });\n            }\n        } catch (e) {\n            // Don't let daily errors break commands\n            console.error('daily reward error:', e);\n        }\n    } catch (error) {\n        console.error(error);\n        try {\n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ content: 'There was an error while executing this command!', ephemeral: true });\n            } else {\n                await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });\n            }\n        } catch {}\n    }\n});\n\nclient.login(process.env.DISCORD_TOKEN);\n","size_bytes":8796},"RESERVES_AUTO_SCROLL.md":{"content":"# üéÆ Reserves & Auto-Scroll Feature\n\n## ‚úÖ **New Features Added:**\n\n### **1. Reserves Section** üì¶\nA third storage area for your players!\n\n**Structure:**\n- **Squad** (11 players) - Your starting XI\n- **Bench** (Max 8 players) - Substitutes\n- **Reserves** (Unlimited) - Extra players\n\n### **2. Auto-Scroll** üîÑ\nPage automatically scrolls when dragging near top/bottom!\n\n---\n\n## üéØ **How Reserves Work:**\n\n### **What are Reserves?**\n- Extra player storage beyond the 8-player bench limit\n- Unlimited capacity\n- Players can be moved between Squad ‚Üî Bench ‚Üî Reserves\n\n### **Visual Design:**\n- **Blue border** (vs yellow for bench)\n- **Blue accent** color\n- Located below bench section\n\n---\n\n## üîÑ **All Drag & Drop Combinations:**\n\n### **Squad ‚Üî Bench ‚Üî Reserves:**\n\n```\nSquad ‚Üí Bench ‚úÖ\nSquad ‚Üí Reserves ‚úÖ\nBench ‚Üí Squad ‚úÖ\nBench ‚Üí Reserves ‚úÖ\nReserves ‚Üí Squad ‚úÖ\nReserves ‚Üí Bench ‚úÖ\nAvailable ‚Üí Squad ‚úÖ\nAvailable ‚Üí Bench ‚úÖ\nAvailable ‚Üí Reserves ‚úÖ\n```\n\n### **Examples:**\n\n#### **1. Move Player to Reserves:**\n```\nDrag player from Squad\nDrop on Reserves section\n‚Üí Player moves to reserves\n‚Üí Squad position becomes empty\n```\n\n#### **2. Promote from Reserves:**\n```\nDrag player from Reserves\nDrop on Squad position\n‚Üí Player joins squad\n‚Üí If position occupied, old player goes to reserves\n```\n\n#### **3. Bench Full? Use Reserves:**\n```\nBench has 8 players (full)\nDrag 9th player to Reserves\n‚Üí Stored in reserves instead\n‚Üí No limit!\n```\n\n---\n\n## üìú **Auto-Scroll Feature:**\n\n### **How It Works:**\nWhen dragging a player, the page automatically scrolls if you're near the edge!\n\n### **Scroll Zones:**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚Üë Scroll Up Zone    ‚îÇ ‚Üê Top 100px\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ                     ‚îÇ\n‚îÇ   Normal Zone       ‚îÇ\n‚îÇ   (no scroll)       ‚îÇ\n‚îÇ                     ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ ‚Üì Scroll Down Zone  ‚îÇ ‚Üê Bottom 100px\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### **Usage:**\n1. **Start dragging** a player\n2. **Move mouse** near top of screen ‚Üí Auto-scrolls up\n3. **Move mouse** near bottom ‚Üí Auto-scrolls down\n4. **Drop player** ‚Üí Scrolling stops\n\n### **Settings:**\n- **Scroll Zone:** 100 pixels from edge\n- **Scroll Speed:** 10 pixels per frame\n- **Smooth** and automatic\n\n---\n\n## üé® **Visual Indicators:**\n\n### **Bench (Yellow):**\n```css\nü™ë Bench (Max 8 players - Drag here)\nBorder: Yellow dashed\nHighlight: Yellow glow when dragging over\n```\n\n### **Reserves (Blue):**\n```css\nüì¶ Reserves (Drag here)\nBorder: Blue dashed\nHighlight: Blue glow when dragging over\n```\n\n---\n\n## üí° **Use Cases:**\n\n### **Case 1: Organize Your Collection**\n```\nSquad: Your best 11 players\nBench: Top 8 substitutes\nReserves: Rest of your collection\n```\n\n### **Case 2: Rotation System**\n```\nWeek 1: Player A in squad\nWeek 2: Swap Player A to reserves, Player B to squad\nEasy rotation!\n```\n\n### **Case 3: Bench Full**\n```\nAlready have 8 bench players\nNew player arrives\n‚Üí Put in reserves\n‚Üí Swap later when needed\n```\n\n---\n\n## üéØ **Drag & Drop Examples:**\n\n### **Example 1: Squad ‚Üí Reserves**\n```\n1. Grab player from CMF position\n2. Drag down to Reserves section (blue box)\n3. Page auto-scrolls as you approach bottom\n4. Drop on reserves\n5. Player moves to reserves\n6. CMF position now empty\n```\n\n### **Example 2: Reserves ‚Üí Squad**\n```\n1. Scroll down to reserves\n2. Grab reserve player\n3. Drag up toward squad\n4. Page auto-scrolls as you approach top\n5. Drop on squad position\n6. Player joins squad\n```\n\n### **Example 3: Bench ‚Üí Reserves**\n```\n1. Bench is full (8 players)\n2. Need to add new player to bench\n3. Drag one bench player to reserves\n4. Now bench has space\n5. Add new player to bench\n```\n\n---\n\n## üöÄ **Quick Actions:**\n\n### **Free Up Bench Space:**\n```\nDrag bench player ‚Üí Drop on reserves\n‚Üí Bench space freed\n```\n\n### **Promote Reserve Player:**\n```\nDrag reserve player ‚Üí Drop on squad\n‚Üí Instant promotion\n```\n\n### **Swap Squad Players:**\n```\nDrag squad player ‚Üí Drop on another position\n‚Üí They swap\n```\n\n### **Long-Distance Drag:**\n```\nDrag from top ‚Üí Auto-scroll down ‚Üí Drop at bottom\n‚Üí Smooth scrolling all the way\n```\n\n---\n\n## üìä **Capacity Limits:**\n\n| Section | Limit | Notes |\n|---------|-------|-------|\n| **Squad** | 11 players | Starting XI |\n| **Bench** | 8 players | Max limit enforced |\n| **Reserves** | Unlimited | No limit! |\n\n---\n\n## üéÆ **Keyboard & Mouse:**\n\n- **Grab** - Click and hold player\n- **Drag** - Move mouse while holding\n- **Near Edge** - Auto-scroll activates\n- **Drop** - Release mouse button\n- **Escape** - Cancel drag (browser default)\n\n---\n\n## ‚úÖ **Benefits:**\n\n### **1. Better Organization**\n- Clear separation: Squad / Bench / Reserves\n- Easy to see who's where\n\n### **2. No More Scrolling Hassle**\n- Auto-scroll handles long drags\n- Smooth experience\n\n### **3. Unlimited Storage**\n- Reserves have no limit\n- Store entire collection\n\n### **4. Flexible Management**\n- Easy swaps between all sections\n- Drag anywhere to anywhere\n\n---\n\n## üêõ **Troubleshooting:**\n\n### **Auto-scroll not working?**\n- Make sure you're dragging (not just hovering)\n- Move mouse within 100px of top/bottom edge\n\n### **Can't drop on reserves?**\n- Look for blue highlight when dragging over\n- Make sure reserves section is visible\n\n### **Player not moving?**\n- Check for duplicate alerts\n- Ensure player isn't already in that section\n\n---\n\n## üéâ **Summary:**\n\n‚úÖ **Reserves section** - Unlimited player storage\n‚úÖ **Auto-scroll** - Smooth dragging experience  \n‚úÖ **Full drag & drop** - Squad ‚Üî Bench ‚Üî Reserves\n‚úÖ **Visual feedback** - Yellow (bench) / Blue (reserves)\n‚úÖ **No limits** - Store as many players as you want in reserves\n\n**Enjoy the enhanced squad management!** ‚öΩüéÆ\n","size_bytes":5932},"scripts/update-user-players.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\n// Rarity-based configuration\nconst RARITY_CONFIG = {\n    'Iconic': { maxLevel: 50, statMultiplier: 1.0, overallBonus: 0 },\n    'Legend': { maxLevel: 45, statMultiplier: 0.95, overallBonus: -2 },\n    'Black': { maxLevel: 40, statMultiplier: 0.90, overallBonus: -5 },\n    'Gold': { maxLevel: 35, statMultiplier: 0.85, overallBonus: -8 },\n    'Silver': { maxLevel: 30, statMultiplier: 0.80, overallBonus: -12 },\n    'Bronze': { maxLevel: 25, statMultiplier: 0.75, overallBonus: -16 },\n    'White': { maxLevel: 20, statMultiplier: 0.70, overallBonus: -20 }\n};\n\nfunction initializePlayerLevel(player) {\n    const rarityConfig = RARITY_CONFIG[player.rarity] || RARITY_CONFIG['White'];\n    \n    // If player doesn't have level data, initialize it\n    if (!player.level) {\n        player.level = 1;\n        player.exp = 0;\n        player.maxLevel = rarityConfig.maxLevel;\n        \n        // Store original stats as max level stats\n        player.maxStats = { ...player.stats };\n        player.maxOverall = player.overall;\n        \n        // Calculate level 1 stats (reduced from current)\n        const level1Stats = {};\n        for (const [statName, maxStat] of Object.entries(player.maxStats)) {\n            // Reduce stats for level 1 (about 70% of max)\n            level1Stats[statName] = Math.max(10, Math.floor(maxStat * 0.7));\n        }\n        \n        player.stats = level1Stats;\n        \n        // Calculate new overall based on level 1 stats\n        const statValues = Object.values(level1Stats);\n        const avgStat = statValues.reduce((sum, stat) => sum + stat, 0) / statValues.length;\n        player.overall = Math.max(30, Math.min(99, Math.floor(avgStat + rarityConfig.overallBonus)));\n    }\n    \n    return player;\n}\n\nfunction updateUserData() {\n    const dataDir = path.join(__dirname, '..', 'data');\n    \n    if (!fs.existsSync(dataDir)) {\n        console.log('No data directory found. No user data to update.');\n        return;\n    }\n    \n    const files = fs.readdirSync(dataDir).filter(file => file.endsWith('.json'));\n    \n    if (files.length === 0) {\n        console.log('No user data files found.');\n        return;\n    }\n    \n    console.log(`Updating ${files.length} user data files...`);\n    \n    let totalPlayersUpdated = 0;\n    \n    files.forEach((file, index) => {\n        try {\n            const filePath = path.join(dataDir, file);\n            const userData = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n            \n            if (userData.players && Array.isArray(userData.players)) {\n                let playersUpdated = 0;\n                \n                userData.players.forEach(player => {\n                    if (!player.level) {\n                        initializePlayerLevel(player);\n                        playersUpdated++;\n                        totalPlayersUpdated++;\n                    }\n                });\n                \n                if (playersUpdated > 0) {\n                    fs.writeFileSync(filePath, JSON.stringify(userData, null, 2));\n                    console.log(`Updated ${playersUpdated} players for user ${userData.id || file}`);\n                }\n            }\n        } catch (error) {\n            console.error(`Error updating user data file ${file}:`, error.message);\n        }\n    });\n    \n    console.log(`‚úÖ Successfully updated ${totalPlayersUpdated} players across ${files.length} users!`);\n}\n\n// Run the update\nupdateUserData();\n","size_bytes":3470},"scripts/fix-max-stats.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\n// Import the same stat priorities and calculations from training.js\nconst POSITION_STAT_PRIORITY = {\n    'GK': { goalkeeping: 2.0, defending: 1.2, physicality: 1.1 },\n    'CB': { defending: 1.8, physicality: 1.4, passing: 1.1 },\n    'LB': { defending: 1.5, physicality: 1.2, passing: 1.3, dribbling: 1.1 },\n    'RB': { defending: 1.5, physicality: 1.2, passing: 1.3, dribbling: 1.1 },\n    'DMF': { defending: 1.6, physicality: 1.3, passing: 1.2 },\n    'CMF': { passing: 1.4, physicality: 1.2, defending: 1.1, attacking: 1.1, dribbling: 1.1 },\n    'AMF': { passing: 1.3, attacking: 1.4, dribbling: 1.3 },\n    'LMF': { passing: 1.2, dribbling: 1.4, physicality: 1.1, attacking: 1.1 },\n    'RMF': { passing: 1.2, dribbling: 1.4, physicality: 1.1, attacking: 1.1 },\n    'CF': { attacking: 1.6, dribbling: 1.2, physicality: 1.3 },\n    'LWF': { attacking: 1.4, dribbling: 1.5, passing: 1.1 },\n    'RWF': { attacking: 1.4, dribbling: 1.5, passing: 1.1 }\n};\n\nfunction calculateTargetOverall(stats, position) {\n    // Weight stats based on position importance (same as training.js)\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    \n    let weightedSum = 0;\n    let totalWeight = 0;\n    \n    for (const [statName, statValue] of Object.entries(stats)) {\n        if (statName === 'goalkeeping' && position !== 'GK') {\n            continue; // Skip GK stat for outfield players\n        }\n        const weight = positionPriority[statName] || 1.0;\n        weightedSum += statValue * weight;\n        totalWeight += weight;\n    }\n    \n    const weightedAvg = totalWeight > 0 ? weightedSum / totalWeight : 50;\n    return Math.max(30, Math.min(99, Math.round(weightedAvg)));\n}\n\nfunction adjustStatsToMatchOverall(currentStats, targetOverall, position) {\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    const currentOverall = calculateTargetOverall(currentStats, position);\n    \n    if (Math.abs(currentOverall - targetOverall) <= 1) {\n        return currentStats; // Already close enough\n    }\n    \n    const adjustedStats = { ...currentStats };\n    const difference = targetOverall - currentOverall;\n    \n    // Get stats sorted by position importance (most important first)\n    const statsByImportance = Object.entries(positionPriority)\n        .filter(([statName]) => statName !== 'goalkeeping' || position === 'GK')\n        .sort((a, b) => b[1] - a[1])\n        .map(([statName]) => statName);\n    \n    // Distribute the difference across stats based on importance\n    let remainingDifference = difference;\n    const adjustmentPerStat = Math.ceil(Math.abs(difference) / statsByImportance.length);\n    \n    for (const statName of statsByImportance) {\n        if (remainingDifference === 0) break;\n        \n        const currentValue = adjustedStats[statName];\n        const adjustment = Math.sign(remainingDifference) * Math.min(adjustmentPerStat, Math.abs(remainingDifference));\n        const newValue = Math.max(10, Math.min(99, currentValue + adjustment));\n        \n        adjustedStats[statName] = newValue;\n        remainingDifference -= (newValue - currentValue);\n    }\n    \n    return adjustedStats;\n}\n\nfunction fixMaxStats() {\n    const playersPath = path.join(__dirname, '..', 'players.json');\n    const players = JSON.parse(fs.readFileSync(playersPath, 'utf8'));\n    \n    console.log(`Processing ${players.length} players...`);\n    \n    let fixed = 0;\n    let unchanged = 0;\n    let skipped = 0;\n    \n    for (const player of players) {\n        // Skip Lionel Messi\n        if (player.name === 'Lionel Messi‚òÖ') {\n            console.log(`Skipped ${player.name} (special case)`);\n            skipped++;\n            continue;\n        }\n        \n        // Only process players that have maxStats and maxOverall\n        if (!player.maxStats || !player.maxOverall) {\n            unchanged++;\n            continue;\n        }\n        \n        const currentOverall = calculateTargetOverall(player.maxStats, player.position);\n        const targetOverall = player.maxOverall;\n        \n        if (Math.abs(currentOverall - targetOverall) > 1) {\n            const oldMaxStats = { ...player.maxStats };\n            player.maxStats = adjustStatsToMatchOverall(player.maxStats, targetOverall, player.position);\n            const newOverall = calculateTargetOverall(player.maxStats, player.position);\n            \n            console.log(`Fixed ${player.name} (${player.position}) maxStats: ${currentOverall} ‚Üí ${newOverall} (target: ${targetOverall})`);\n            fixed++;\n        } else {\n            unchanged++;\n        }\n    }\n    \n    // Write back to file\n    fs.writeFileSync(playersPath, JSON.stringify(players, null, 2));\n    \n    console.log(`\\nCompleted:`);\n    console.log(`- Fixed maxStats: ${fixed} players`);\n    console.log(`- Unchanged: ${unchanged} players`);\n    console.log(`- Skipped (Messi): ${skipped} players`);\n    console.log(`- Total: ${players.length} players`);\n}\n\n// Run the fix\nfixMaxStats();\n","size_bytes":5072},"IMAGE_FIX.md":{"content":"# üñºÔ∏è Player Face Image Fix\n\n## ‚úÖ **Problem Fixed:**\n\nPlayer face images were not loading properly - showing only circular placeholders with text instead of actual photos.\n\n---\n\n## üîß **Changes Made:**\n\n### **1. Added Assets Folder to Static Serving**\n\n**Files Updated:**\n- `web-server.js`\n- `server.js`\n\n**Change:**\n```javascript\n// Before:\napp.use(express.static(path.join(__dirname, 'public')));\n\n// After:\napp.use(express.static(path.join(__dirname, 'public')));\napp.use('/assets', express.static(path.join(__dirname, 'assets')));\n```\n\n**Why:** The `assets` folder wasn't being served by the web server, so images couldn't be accessed.\n\n---\n\n### **2. Updated Image Loading Logic**\n\n**Files Updated:**\n- `dashboard.js` (Squad cards)\n- `dashboard.js` (Bench cards)\n- `dashboard.js` (Available player cards)\n\n**Change:**\n```javascript\n// Before:\nconst playerImage = `/assets/faces/${player.name}.png`;\n<img src=\"${playerImage}\" onerror=\"this.src='/assets/faces/default_player.png'\">\n\n// After:\nconst playerImagePng = `/assets/faces/${player.name}.png`;\nconst playerImageJpg = `/assets/faces/${player.name}.jpg`;\n<img src=\"${playerImagePng}\" \n     onerror=\"this.onerror=null; this.src='${playerImageJpg}'; \n              this.onerror=function(){this.src='/assets/faces/default_player.png'}\">\n```\n\n**Why:** \n- Tries PNG first (like Discord bot)\n- Falls back to JPG if PNG not found\n- Finally uses default_player.png if neither exists\n- Matches Discord bot behavior exactly\n\n---\n\n## üìÅ **File Structure:**\n\n```\nassets/\n  faces/\n    ‚îú‚îÄ‚îÄ default_player.png (required!)\n    ‚îú‚îÄ‚îÄ Lionel Messi.png\n    ‚îú‚îÄ‚îÄ Lionel Messi.jpg\n    ‚îú‚îÄ‚îÄ Kiera Feil.png\n    ‚îú‚îÄ‚îÄ Kenny Abshire.jpg\n    ‚îî‚îÄ‚îÄ [exact player name].[png/jpg]\n```\n\n---\n\n## üéØ **Image Loading Priority:**\n\n1. **First:** `/assets/faces/[Player Name].png`\n2. **Second:** `/assets/faces/[Player Name].jpg`\n3. **Fallback:** `/assets/faces/default_player.png`\n\n---\n\n## ‚úÖ **Now Works Like Discord Bot:**\n\n### **Discord Bot (training.js):**\n```javascript\n// Checks in order:\n1. [name].jpg\n2. [name].png\n3. default_player.png\n```\n\n### **Web Dashboard (dashboard.js):**\n```javascript\n// Checks in order:\n1. [name].png\n2. [name].jpg\n3. default_player.png\n```\n\n**Both now support PNG and JPG formats!**\n\n---\n\n## üöÄ **How to Use:**\n\n### **1. Make Sure Assets Folder Exists:**\n```\nCreate: assets/faces/\n```\n\n### **2. Add Player Images:**\n```\nFormat: [Exact Player Name].png or .jpg\nExamples:\n- Lionel Messi.png\n- Kiera Feil.jpg\n- Kenny Abshire.png\n```\n\n### **3. Add Default Image:**\n```\nRequired: assets/faces/default_player.png\nUsed when player image not found\n```\n\n### **4. Restart Server:**\n```bash\n# Stop the server (Ctrl+C)\n# Start again:\nnode web-server.js\n# or\nnode server.js\n```\n\n### **5. Refresh Browser:**\n```\nCtrl + F5 (Windows)\nCmd + Shift + R (Mac)\n```\n\n---\n\n## üé® **Result:**\n\n### **Before:**\n- ‚ùå Circular placeholder with text only\n- ‚ùå No actual face photos\n- ‚ùå Assets folder not served\n\n### **After:**\n- ‚úÖ Real player face photos\n- ‚úÖ PNG and JPG support\n- ‚úÖ Fallback to default image\n- ‚úÖ Matches Discord bot exactly\n\n---\n\n## üìä **Image Format Support:**\n\n| Format | Supported | Priority |\n|--------|-----------|----------|\n| **PNG** | ‚úÖ | 1st |\n| **JPG** | ‚úÖ | 2nd |\n| **Default** | ‚úÖ | Fallback |\n\n---\n\n## üí° **Tips:**\n\n### **Image Naming:**\n- Must match player name exactly\n- Case-sensitive\n- Include spaces if name has spaces\n- Example: \"Lionel Messi.png\" not \"lionel-messi.png\"\n\n### **Image Quality:**\n- Any size (auto-scaled)\n- Square images work best\n- Transparent background recommended for PNG\n\n### **Default Image:**\n- Create a generic player silhouette\n- Used for all players without custom images\n- Must be named exactly: `default_player.png`\n\n---\n\n## üîç **Troubleshooting:**\n\n### **Images Still Not Loading?**\n\n1. **Check file names:**\n   - Must match player name exactly\n   - Check for extra spaces or special characters\n\n2. **Check file location:**\n   - Must be in `assets/faces/` folder\n   - Not in `public/assets/faces/`\n\n3. **Check server:**\n   - Restart web server after adding images\n   - Check console for errors\n\n4. **Check browser:**\n   - Hard refresh (Ctrl+F5)\n   - Clear cache\n   - Check browser console (F12)\n\n5. **Check default image:**\n   - Must exist: `assets/faces/default_player.png`\n   - If missing, all images will fail\n\n---\n\n## üéâ **Summary:**\n\n‚úÖ **Assets folder** now served by web server\n‚úÖ **PNG and JPG** support added\n‚úÖ **Fallback system** implemented\n‚úÖ **Matches Discord bot** behavior\n‚úÖ **All sections updated** (Squad, Bench, Available)\n\n**Player faces will now display like in the Discord training info command!** üñºÔ∏è‚öΩ\n\n**Just add your images to `assets/faces/` and restart the server!**\n","size_bytes":4771},"commands/profile.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('profile')\n        .setDescription('View your eFotbal profile and currencies'),\n    async execute(interaction) {\n        const { client } = interaction;\n        const userData = client.getUserData(interaction.user.id);\n\n        const profileEmbed = new EmbedBuilder()\n            .setTitle(`${interaction.user.username}'s eFotbal Profile`)\n            .setColor('#0099ff')\n            .setThumbnail(interaction.user.displayAvatarURL())\n            .addFields(\n                { name: 'GP (General Points)', value: `üí∞ ${userData.gp.toLocaleString()}`, inline: true },\n                { name: 'eCoins', value: `ü™ô ${userData.eCoins.toLocaleString()}`, inline: true },\n                { name: 'Players Owned', value: `üë• ${userData.players.length}`, inline: true }\n            );\n\n        // Player collection moved to /collection\n        profileEmbed.addFields({ name: 'Commands', value: 'Use `/collection` to view your players.' });\n\n        await interaction.reply({ embeds: [profileEmbed] });\n    },\n};\n","size_bytes":1153},"WEB_DASHBOARD_SETUP.md":{"content":"# üåê Web Dashboard Setup Guide\n\nYour eFotball bot now has a **full web dashboard** where users can:\n- ‚úÖ Login with Discord OAuth2\n- ‚úÖ View their player collection\n- ‚úÖ Build and manage their squad visually\n- ‚úÖ Drag-and-drop squad builder\n- ‚úÖ See stats and currency\n\n---\n\n## üöÄ Quick Setup\n\n### **Step 1: Get Discord OAuth2 Credentials**\n\n1. Go to **Discord Developer Portal**: https://discord.com/developers/applications\n2. Select your application (or create a new one)\n3. Go to **\"OAuth2\"** section on the left\n4. Click **\"Add Redirect\"** and add:\n   - For local testing: `http://localhost:3000/auth/discord/callback`\n   - For production: `https://your-app-url.com/auth/discord/callback`\n5. Copy your **Client ID** and **Client Secret**\n\n### **Step 2: Update Environment Variables**\n\nAdd these to your `.env` file (or Replit Secrets):\n\n```env\n# Your existing bot token\nDISCORD_TOKEN=your_bot_token_here\n\n# New OAuth2 credentials\nDISCORD_CLIENT_ID=your_client_id_here\nDISCORD_CLIENT_SECRET=your_client_secret_here\n\n# Callback URL (update for production)\nCALLBACK_URL=http://localhost:3000/auth/discord/callback\n\n# Session secret (any random string)\nSESSION_SECRET=my-super-secret-key-12345\n```\n\n### **Step 3: Install Dependencies**\n\n```bash\nnpm install\n```\n\n### **Step 4: Start the Server**\n\n```bash\nnpm start\n```\n\n### **Step 5: Access the Dashboard**\n\n1. Open your browser: `http://localhost:3000`\n2. Click **\"Login with Discord\"**\n3. Authorize the application\n4. You'll be redirected to your dashboard!\n\n---\n\n## üéØ Features\n\n### **Home Page** (`/`)\n- Beautiful landing page\n- Login with Discord button\n- Feature showcase\n\n### **Dashboard** (`/dashboard`)\n- **Overview Tab**: View GP, eCoins, player count, team rating\n- **Squad Builder Tab**: \n  - Visual football pitch\n  - Drag-and-drop interface (coming soon)\n  - Formation selector (4-3-3, 4-4-2, 3-5-2, 4-2-3-1)\n  - Bench management\n  - Save squad to sync with Discord bot\n- **My Players Tab**:\n  - View all your players\n  - Filter by rarity, position, name\n  - Click to see detailed stats\n\n---\n\n## üîß For Replit Deployment\n\n### **1. Add Secrets in Replit**\n\nClick the üîí **Secrets** tab and add:\n\n| Key | Value |\n|-----|-------|\n| `DISCORD_TOKEN` | Your bot token |\n| `DISCORD_CLIENT_ID` | Your OAuth2 Client ID |\n| `DISCORD_CLIENT_SECRET` | Your OAuth2 Client Secret |\n| `CALLBACK_URL` | `https://your-repl.repl.co/auth/discord/callback` |\n| `SESSION_SECRET` | Any random string |\n\n### **2. Update Discord Developer Portal**\n\n1. Go to your Discord application\n2. OAuth2 ‚Üí Redirects\n3. Add: `https://your-repl-name.your-username.repl.co/auth/discord/callback`\n4. Save changes\n\n### **3. Run the Bot**\n\nClick the **Run** button in Replit!\n\n---\n\n## üåê For Render.com Deployment\n\n### **1. Add Environment Variables**\n\nIn Render dashboard, add:\n- `DISCORD_TOKEN`\n- `DISCORD_CLIENT_ID`\n- `DISCORD_CLIENT_SECRET`\n- `CALLBACK_URL` = `https://your-app.onrender.com/auth/discord/callback`\n- `SESSION_SECRET`\n\n### **2. Update Discord Redirect URI**\n\nAdd `https://your-app.onrender.com/auth/discord/callback` to Discord OAuth2 redirects\n\n### **3. Deploy**\n\nRender will automatically deploy your app!\n\n---\n\n## üì± API Endpoints\n\nYour web server provides these API endpoints:\n\n### **Authentication**\n- `GET /auth/discord` - Start Discord OAuth2 flow\n- `GET /auth/discord/callback` - OAuth2 callback\n- `GET /logout` - Logout user\n\n### **User Data**\n- `GET /api/user` - Get current user info\n- `GET /api/players` - Get user's players\n- `GET /api/squad` - Get user's squad\n- `POST /api/squad/update` - Update squad\n\n### **Bot Status**\n- `GET /api/status` - Bot status (uptime, restarts)\n- `GET /health` - Health check\n- `GET /ping` - Keep-alive endpoint\n\n---\n\n## üé® Customization\n\n### **Change Colors**\n\nEdit `public/styles.css`:\n\n```css\n:root {\n    --primary: #667eea;  /* Main color */\n    --secondary: #764ba2; /* Secondary color */\n    --success: #27ae60;   /* Success color */\n}\n```\n\n### **Add More Features**\n\nThe dashboard is built with vanilla JavaScript, making it easy to extend:\n\n1. **Add new tabs**: Edit `public/dashboard.html`\n2. **Add new API endpoints**: Edit `web-server.js`\n3. **Add new functionality**: Edit `public/dashboard.js`\n\n---\n\n## üîí Security Notes\n\n1. **Never commit `.env` file** - It's already in `.gitignore`\n2. **Use strong SESSION_SECRET** - Generate a random string\n3. **HTTPS in production** - Always use HTTPS for OAuth2\n4. **Validate user input** - Server-side validation is implemented\n\n---\n\n## üêõ Troubleshooting\n\n### **\"401 Unauthorized\" when logging in**\n- Check your `DISCORD_CLIENT_ID` and `DISCORD_CLIENT_SECRET`\n- Verify redirect URI matches in Discord Developer Portal\n\n### **\"Cannot find module\" errors**\n- Run `npm install` to install all dependencies\n- Delete `node_modules` and `package-lock.json`, then reinstall\n\n### **Squad not saving**\n- Check browser console for errors\n- Verify user data directory exists\n- Check server logs\n\n### **Players not showing**\n- Ensure `players.json` exists and is valid JSON\n- Check if user has players in their collection\n- Use Discord bot commands to get players first\n\n---\n\n## üìä How It Works\n\n1. **User logs in** via Discord OAuth2\n2. **Session is created** and stored server-side\n3. **User data is loaded** from `data/{userId}.json`\n4. **Dashboard displays** player collection and squad\n5. **User makes changes** via web interface\n6. **Changes are saved** to JSON files\n7. **Discord bot reads** the same JSON files\n8. **Everything stays in sync!** üéâ\n\n---\n\n## üéØ Next Steps\n\n1. ‚úÖ Set up OAuth2 credentials\n2. ‚úÖ Add environment variables\n3. ‚úÖ Deploy to Replit/Render\n4. ‚úÖ Test the dashboard\n5. ‚úÖ Share with your Discord server!\n\n---\n\n## üí° Tips\n\n- **Mobile Responsive**: Dashboard works on phones and tablets\n- **Real-time Sync**: Changes sync instantly with Discord bot\n- **No Database Needed**: Uses JSON files (same as bot)\n- **Easy to Deploy**: Works on all free hosting platforms\n\n---\n\n## üÜò Need Help?\n\nIf you encounter issues:\n1. Check the browser console (F12)\n2. Check server logs\n3. Verify all environment variables are set\n4. Make sure Discord OAuth2 redirect URI is correct\n\n---\n\n**Your web dashboard is ready! üéâ‚öΩ**\n\nUsers can now manage their squads visually instead of using Discord commands!\n","size_bytes":6290},"scripts/fix-player-stats.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\n// Import the same stat priorities and calculations from training.js\nconst POSITION_STAT_PRIORITY = {\n    'GK': { goalkeeping: 2.0, defending: 1.2, physicality: 1.1 },\n    'CB': { defending: 1.8, physicality: 1.4, passing: 1.1 },\n    'LB': { defending: 1.5, physicality: 1.2, passing: 1.3, dribbling: 1.1 },\n    'RB': { defending: 1.5, physicality: 1.2, passing: 1.3, dribbling: 1.1 },\n    'DMF': { defending: 1.6, physicality: 1.3, passing: 1.2 },\n    'CMF': { passing: 1.4, physicality: 1.2, defending: 1.1, attacking: 1.1, dribbling: 1.1 },\n    'AMF': { passing: 1.3, attacking: 1.4, dribbling: 1.3 },\n    'LMF': { passing: 1.2, dribbling: 1.4, physicality: 1.1, attacking: 1.1 },\n    'RMF': { passing: 1.2, dribbling: 1.4, physicality: 1.1, attacking: 1.1 },\n    'CF': { attacking: 1.6, dribbling: 1.2, physicality: 1.3 },\n    'LWF': { attacking: 1.4, dribbling: 1.5, passing: 1.1 },\n    'RWF': { attacking: 1.4, dribbling: 1.5, passing: 1.1 }\n};\n\nfunction calculateTargetOverall(stats, position) {\n    // Weight stats based on position importance (same as training.js)\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    \n    let weightedSum = 0;\n    let totalWeight = 0;\n    \n    for (const [statName, statValue] of Object.entries(stats)) {\n        if (statName === 'goalkeeping' && position !== 'GK') {\n            continue; // Skip GK stat for outfield players\n        }\n        const weight = positionPriority[statName] || 1.0;\n        weightedSum += statValue * weight;\n        totalWeight += weight;\n    }\n    \n    const weightedAvg = totalWeight > 0 ? weightedSum / totalWeight : 50;\n    return Math.max(30, Math.min(99, Math.round(weightedAvg)));\n}\n\nfunction adjustStatsToMatchOverall(currentStats, targetOverall, position) {\n    const positionPriority = POSITION_STAT_PRIORITY[position] || POSITION_STAT_PRIORITY['CMF'];\n    const currentOverall = calculateTargetOverall(currentStats, position);\n    \n    if (Math.abs(currentOverall - targetOverall) <= 1) {\n        return currentStats; // Already close enough\n    }\n    \n    const adjustedStats = { ...currentStats };\n    const difference = targetOverall - currentOverall;\n    \n    // Get stats sorted by position importance (most important first)\n    const statsByImportance = Object.entries(positionPriority)\n        .filter(([statName]) => statName !== 'goalkeeping' || position === 'GK')\n        .sort((a, b) => b[1] - a[1])\n        .map(([statName]) => statName);\n    \n    // Distribute the difference across stats based on importance\n    let remainingDifference = difference;\n    const adjustmentPerStat = Math.ceil(Math.abs(difference) / statsByImportance.length);\n    \n    for (const statName of statsByImportance) {\n        if (remainingDifference === 0) break;\n        \n        const currentValue = adjustedStats[statName];\n        const adjustment = Math.sign(remainingDifference) * Math.min(adjustmentPerStat, Math.abs(remainingDifference));\n        const newValue = Math.max(10, Math.min(99, currentValue + adjustment));\n        \n        adjustedStats[statName] = newValue;\n        remainingDifference -= (newValue - currentValue);\n    }\n    \n    return adjustedStats;\n}\n\nfunction fixPlayerStats() {\n    const playersPath = path.join(__dirname, '..', 'players.json');\n    const players = JSON.parse(fs.readFileSync(playersPath, 'utf8'));\n    \n    console.log(`Processing ${players.length} players...`);\n    \n    let fixed = 0;\n    let unchanged = 0;\n    \n    for (const player of players) {\n        const currentOverall = calculateTargetOverall(player.stats, player.position);\n        const targetOverall = player.overall;\n        \n        if (Math.abs(currentOverall - targetOverall) > 1) {\n            const oldStats = { ...player.stats };\n            player.stats = adjustStatsToMatchOverall(player.stats, targetOverall, player.position);\n            const newOverall = calculateTargetOverall(player.stats, player.position);\n            \n            console.log(`Fixed ${player.name} (${player.position}): ${currentOverall} ‚Üí ${newOverall} (target: ${targetOverall})`);\n            fixed++;\n        } else {\n            unchanged++;\n        }\n    }\n    \n    // Write back to file\n    fs.writeFileSync(playersPath, JSON.stringify(players, null, 2));\n    \n    console.log(`\\nCompleted:`);\n    console.log(`- Fixed: ${fixed} players`);\n    console.log(`- Unchanged: ${unchanged} players`);\n    console.log(`- Total: ${players.length} players`);\n}\n\n// Run the fix\nfixPlayerStats();\n","size_bytes":4566},"DEPLOYMENT.md":{"content":"# üöÄ Deploy eFotball Discord Bot 24/7\n\nYour bot now has a web server that keeps it online 24/7! Here are your deployment options:\n\n## üìã Prerequisites\n\nBefore deploying, make sure you have:\n- ‚úÖ Discord Bot Token (in `.env` file)\n- ‚úÖ All files committed to a Git repository (GitHub recommended)\n\n---\n\n## üåê Option 1: Render.com (RECOMMENDED - Free & Easy)\n\n**Why Render?** Free tier, auto-deploys from GitHub, keeps bot running 24/7\n\n### Steps:\n\n1. **Create a GitHub Repository**\n   - Go to https://github.com/new\n   - Create a new repository (e.g., `efotball-bot`)\n   - Push your code:\n     ```bash\n     git init\n     git add .\n     git commit -m \"Initial commit\"\n     git branch -M main\n     git remote add origin https://github.com/YOUR_USERNAME/efotball-bot.git\n     git push -u origin main\n     ```\n\n2. **Deploy to Render**\n   - Go to https://render.com\n   - Sign up/Login with GitHub\n   - Click \"New +\" ‚Üí \"Web Service\"\n   - Connect your GitHub repository\n   - Configure:\n     - **Name:** efotball-bot\n     - **Environment:** Node\n     - **Build Command:** `npm install`\n     - **Start Command:** `npm start`\n     - **Plan:** Free\n   - Add Environment Variable:\n     - Key: `DISCORD_TOKEN`\n     - Value: (paste your Discord bot token)\n   - Click \"Create Web Service\"\n\n3. **Done!** Your bot will be live at: `https://efotball-bot.onrender.com`\n\n**Note:** Free tier may sleep after 15 min of inactivity. Use UptimeRobot (below) to keep it awake!\n\n---\n\n## üîÑ Option 2: Railway.app (Easy, $5 free credit)\n\n1. Go to https://railway.app\n2. Sign up with GitHub\n3. Click \"New Project\" ‚Üí \"Deploy from GitHub repo\"\n4. Select your repository\n5. Add environment variable: `DISCORD_TOKEN`\n6. Railway will auto-detect and deploy!\n\n**Your bot URL:** `https://your-app.up.railway.app`\n\n---\n\n## üíª Option 3: Replit (Easiest for beginners)\n\n1. Go to https://replit.com\n2. Click \"Create Repl\" ‚Üí \"Import from GitHub\"\n3. Paste your GitHub repo URL\n4. In \"Secrets\" tab (üîí), add:\n   - Key: `DISCORD_TOKEN`\n   - Value: (your token)\n5. Click \"Run\" button\n6. Keep the Repl tab open or use \"Always On\" (paid feature)\n\n**Your bot URL:** `https://your-repl.your-username.repl.co`\n\n---\n\n## ü§ñ Option 4: Heroku (Classic option)\n\n1. Install Heroku CLI: https://devcenter.heroku.com/articles/heroku-cli\n2. Login: `heroku login`\n3. Create app:\n   ```bash\n   heroku create efotball-bot\n   heroku config:set DISCORD_TOKEN=your_token_here\n   git push heroku main\n   ```\n\n**Your bot URL:** `https://efotball-bot.herokuapp.com`\n\n---\n\n## ‚è∞ Keep Your Bot Awake 24/7 (For Free Tier)\n\nFree hosting services may sleep after inactivity. Use **UptimeRobot** to ping your bot every 5 minutes:\n\n1. Go to https://uptimerobot.com\n2. Sign up (free)\n3. Add New Monitor:\n   - **Monitor Type:** HTTP(s)\n   - **Friendly Name:** eFotball Bot\n   - **URL:** Your deployed URL + `/ping` (e.g., `https://efotball-bot.onrender.com/ping`)\n   - **Monitoring Interval:** 5 minutes\n4. Save!\n\nYour bot will now stay awake 24/7! üéâ\n\n---\n\n## üìä Access Your Dashboard\n\nOnce deployed, visit your bot's URL to see the status dashboard:\n- `https://your-app-url.com` - Beautiful status page\n- `https://your-app-url.com/api/status` - JSON status API\n- `https://your-app-url.com/health` - Health check\n- `https://your-app-url.com/ping` - Keep-alive endpoint\n\n---\n\n## üîß Local Testing\n\nTest the web server locally before deploying:\n\n```bash\n# Install dependencies (if not done)\nnpm install\n\n# Start the server\nnpm start\n```\n\nVisit: http://localhost:3000\n\n---\n\n## üêõ Troubleshooting\n\n### Bot not starting?\n- Check your `DISCORD_TOKEN` is correct\n- View logs in your hosting dashboard\n- Make sure all dependencies are installed\n\n### Website shows but bot is offline?\n- Check Discord Developer Portal - bot token is valid\n- Verify environment variables are set correctly\n- Check hosting service logs for errors\n\n### Bot keeps restarting?\n- Check for errors in the logs\n- Ensure `players.json` exists and is valid JSON\n- Verify all command files are present\n\n---\n\n## üìù Environment Variables Needed\n\nMake sure to set these in your hosting service:\n\n| Variable | Description | Required |\n|----------|-------------|----------|\n| `DISCORD_TOKEN` | Your Discord bot token | ‚úÖ Yes |\n| `PORT` | Port for web server (auto-set by host) | ‚ùå No |\n\n---\n\n## üéØ Next Steps\n\n1. ‚úÖ Deploy your bot using one of the options above\n2. ‚úÖ Set up UptimeRobot to keep it awake\n3. ‚úÖ Share your bot's invite link\n4. ‚úÖ Monitor the dashboard to see uptime and stats\n\n---\n\n## üí° Tips\n\n- **Free Tier Limits:** Most free tiers have limited resources. Your bot should work fine for small-medium servers.\n- **Scaling:** If your bot grows, consider upgrading to paid tiers for better performance.\n- **Backups:** The `data/` folder contains user data. Consider backing it up regularly.\n- **Updates:** Push to GitHub and your hosting service will auto-deploy updates!\n\n---\n\n## üÜò Need Help?\n\nIf you encounter issues:\n1. Check the hosting service logs\n2. Verify all files are committed to GitHub\n3. Ensure environment variables are set correctly\n4. Test locally first with `npm start`\n\n---\n\n**Your bot is now ready for 24/7 deployment! üöÄ‚öΩ**\n","size_bytes":5189}},"version":2}